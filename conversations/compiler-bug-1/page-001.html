<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Claude Code transcript - page 1</title>
    <style>
:root { --bg-color: #f5f5f5; --card-bg: #ffffff; --user-bg: #e3f2fd; --user-border: #1976d2; --assistant-bg: #f5f5f5; --assistant-border: #9e9e9e; --thinking-bg: #fff8e1; --thinking-border: #ffc107; --thinking-text: #666; --tool-bg: #f3e5f5; --tool-border: #9c27b0; --tool-result-bg: #e8f5e9; --tool-error-bg: #ffebee; --text-color: #212121; --text-muted: #757575; --code-bg: #263238; --code-text: #aed581; }
* { box-sizing: border-box; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: var(--bg-color); color: var(--text-color); margin: 0; padding: 16px; line-height: 1.6; }
.container { max-width: 800px; margin: 0 auto; }
h1 { font-size: 1.5rem; margin-bottom: 24px; padding-bottom: 8px; border-bottom: 2px solid var(--user-border); }
.header-row { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 12px; border-bottom: 2px solid var(--user-border); padding-bottom: 8px; margin-bottom: 24px; }
.header-row h1 { border-bottom: none; padding-bottom: 0; margin-bottom: 0; flex: 1; min-width: 200px; }
.message { margin-bottom: 16px; border-radius: 12px; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
.message.user { background: var(--user-bg); border-left: 4px solid var(--user-border); }
.message.assistant { background: var(--card-bg); border-left: 4px solid var(--assistant-border); }
.message.tool-reply { background: #fff8e1; border-left: 4px solid #ff9800; }
.tool-reply .role-label { color: #e65100; }
.tool-reply .tool-result { background: transparent; padding: 0; margin: 0; }
.tool-reply .tool-result .truncatable.truncated::after { background: linear-gradient(to bottom, transparent, #fff8e1); }
.message-header { display: flex; justify-content: space-between; align-items: center; padding: 8px 16px; background: rgba(0,0,0,0.03); font-size: 0.85rem; }
.role-label { font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; }
.user .role-label { color: var(--user-border); }
time { color: var(--text-muted); font-size: 0.8rem; }
.timestamp-link { color: inherit; text-decoration: none; }
.timestamp-link:hover { text-decoration: underline; }
.message:target { animation: highlight 2s ease-out; }
@keyframes highlight { 0% { background-color: rgba(25, 118, 210, 0.2); } 100% { background-color: transparent; } }
.message-content { padding: 16px; }
.message-content p { margin: 0 0 12px 0; }
.message-content p:last-child { margin-bottom: 0; }
.thinking { background: var(--thinking-bg); border: 1px solid var(--thinking-border); border-radius: 8px; padding: 12px; margin: 12px 0; font-size: 0.9rem; color: var(--thinking-text); }
.thinking-label { font-size: 0.75rem; font-weight: 600; text-transform: uppercase; color: #f57c00; margin-bottom: 8px; }
.thinking p { margin: 8px 0; }
.assistant-text { margin: 8px 0; }
.tool-use { background: var(--tool-bg); border: 1px solid var(--tool-border); border-radius: 8px; padding: 12px; margin: 12px 0; }
.tool-header { font-weight: 600; color: var(--tool-border); margin-bottom: 8px; display: flex; align-items: center; gap: 8px; }
.tool-icon { font-size: 1.1rem; }
.tool-description { font-size: 0.9rem; color: var(--text-muted); margin-bottom: 8px; font-style: italic; }
.tool-result { background: var(--tool-result-bg); border-radius: 8px; padding: 12px; margin: 12px 0; }
.tool-result.tool-error { background: var(--tool-error-bg); }
.file-tool { border-radius: 8px; padding: 12px; margin: 12px 0; }
.write-tool { background: linear-gradient(135deg, #e3f2fd 0%, #e8f5e9 100%); border: 1px solid #4caf50; }
.edit-tool { background: linear-gradient(135deg, #fff3e0 0%, #fce4ec 100%); border: 1px solid #ff9800; }
.file-tool-header { font-weight: 600; margin-bottom: 4px; display: flex; align-items: center; gap: 8px; font-size: 0.95rem; }
.write-header { color: #2e7d32; }
.edit-header { color: #e65100; }
.file-tool-icon { font-size: 1rem; }
.file-tool-path { font-family: monospace; background: rgba(0,0,0,0.08); padding: 2px 8px; border-radius: 4px; }
.file-tool-fullpath { font-family: monospace; font-size: 0.8rem; color: var(--text-muted); margin-bottom: 8px; word-break: break-all; }
.file-content { margin: 0; }
.edit-section { display: flex; margin: 4px 0; border-radius: 4px; overflow: hidden; }
.edit-label { padding: 8px 12px; font-weight: bold; font-family: monospace; display: flex; align-items: flex-start; }
.edit-old { background: #fce4ec; }
.edit-old .edit-label { color: #b71c1c; background: #f8bbd9; }
.edit-old .edit-content { color: #880e4f; }
.edit-new { background: #e8f5e9; }
.edit-new .edit-label { color: #1b5e20; background: #a5d6a7; }
.edit-new .edit-content { color: #1b5e20; }
.edit-content { margin: 0; flex: 1; background: transparent; font-size: 0.85rem; }
.edit-replace-all { font-size: 0.75rem; font-weight: normal; color: var(--text-muted); }
.write-tool .truncatable.truncated::after { background: linear-gradient(to bottom, transparent, #e6f4ea); }
.edit-tool .truncatable.truncated::after { background: linear-gradient(to bottom, transparent, #fff0e5); }
.todo-list { background: linear-gradient(135deg, #e8f5e9 0%, #f1f8e9 100%); border: 1px solid #81c784; border-radius: 8px; padding: 12px; margin: 12px 0; }
.todo-header { font-weight: 600; color: #2e7d32; margin-bottom: 10px; display: flex; align-items: center; gap: 8px; font-size: 0.95rem; }
.todo-items { list-style: none; margin: 0; padding: 0; }
.todo-item { display: flex; align-items: flex-start; gap: 10px; padding: 6px 0; border-bottom: 1px solid rgba(0,0,0,0.06); font-size: 0.9rem; }
.todo-item:last-child { border-bottom: none; }
.todo-icon { flex-shrink: 0; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-weight: bold; border-radius: 50%; }
.todo-completed .todo-icon { color: #2e7d32; background: rgba(46, 125, 50, 0.15); }
.todo-completed .todo-content { color: #558b2f; text-decoration: line-through; }
.todo-in-progress .todo-icon { color: #f57c00; background: rgba(245, 124, 0, 0.15); }
.todo-in-progress .todo-content { color: #e65100; font-weight: 500; }
.todo-pending .todo-icon { color: #757575; background: rgba(0,0,0,0.05); }
.todo-pending .todo-content { color: #616161; }
pre { background: var(--code-bg); color: var(--code-text); padding: 12px; border-radius: 6px; overflow-x: auto; font-size: 0.85rem; line-height: 1.5; margin: 8px 0; white-space: pre-wrap; word-wrap: break-word; }
pre.json { color: #e0e0e0; }
code { background: rgba(0,0,0,0.08); padding: 2px 6px; border-radius: 4px; font-size: 0.9em; }
pre code { background: none; padding: 0; }
.user-content { margin: 0; }
.truncatable { position: relative; }
.truncatable.truncated .truncatable-content { max-height: 200px; overflow: hidden; }
.truncatable.truncated::after { content: ''; position: absolute; bottom: 32px; left: 0; right: 0; height: 60px; background: linear-gradient(to bottom, transparent, var(--card-bg)); pointer-events: none; }
.message.user .truncatable.truncated::after { background: linear-gradient(to bottom, transparent, var(--user-bg)); }
.message.tool-reply .truncatable.truncated::after { background: linear-gradient(to bottom, transparent, #fff8e1); }
.tool-use .truncatable.truncated::after { background: linear-gradient(to bottom, transparent, var(--tool-bg)); }
.tool-result .truncatable.truncated::after { background: linear-gradient(to bottom, transparent, var(--tool-result-bg)); }
.expand-btn { display: none; width: 100%; padding: 8px 16px; margin-top: 4px; background: rgba(0,0,0,0.05); border: 1px solid rgba(0,0,0,0.1); border-radius: 6px; cursor: pointer; font-size: 0.85rem; color: var(--text-muted); }
.expand-btn:hover { background: rgba(0,0,0,0.1); }
.truncatable.truncated .expand-btn, .truncatable.expanded .expand-btn { display: block; }
.pagination { display: flex; justify-content: center; gap: 8px; margin: 24px 0; flex-wrap: wrap; }
.pagination a, .pagination span { padding: 5px 10px; border-radius: 6px; text-decoration: none; font-size: 0.85rem; }
.pagination a { background: var(--card-bg); color: var(--user-border); border: 1px solid var(--user-border); }
.pagination a:hover { background: var(--user-bg); }
.pagination .current { background: var(--user-border); color: white; }
.pagination .disabled { color: var(--text-muted); border: 1px solid #ddd; }
.pagination .index-link { background: var(--user-border); color: white; }
details.continuation { margin-bottom: 16px; }
details.continuation summary { cursor: pointer; padding: 12px 16px; background: var(--user-bg); border-left: 4px solid var(--user-border); border-radius: 12px; font-weight: 500; color: var(--text-muted); }
details.continuation summary:hover { background: rgba(25, 118, 210, 0.15); }
details.continuation[open] summary { border-radius: 12px 12px 0 0; margin-bottom: 0; }
.index-item { margin-bottom: 16px; border-radius: 12px; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.1); background: var(--user-bg); border-left: 4px solid var(--user-border); }
.index-item a { display: block; text-decoration: none; color: inherit; }
.index-item a:hover { background: rgba(25, 118, 210, 0.1); }
.index-item-header { display: flex; justify-content: space-between; align-items: center; padding: 8px 16px; background: rgba(0,0,0,0.03); font-size: 0.85rem; }
.index-item-number { font-weight: 600; color: var(--user-border); }
.index-item-content { padding: 16px; }
.index-item-stats { padding: 8px 16px 12px 32px; font-size: 0.85rem; color: var(--text-muted); border-top: 1px solid rgba(0,0,0,0.06); }
.index-item-commit { margin-top: 6px; padding: 4px 8px; background: #fff3e0; border-radius: 4px; font-size: 0.85rem; color: #e65100; }
.index-item-commit code { background: rgba(0,0,0,0.08); padding: 1px 4px; border-radius: 3px; font-size: 0.8rem; margin-right: 6px; }
.commit-card { margin: 8px 0; padding: 10px 14px; background: #fff3e0; border-left: 4px solid #ff9800; border-radius: 6px; }
.commit-card a { text-decoration: none; color: #5d4037; display: block; }
.commit-card a:hover { color: #e65100; }
.commit-card-hash { font-family: monospace; color: #e65100; font-weight: 600; margin-right: 8px; }
.index-commit { margin-bottom: 12px; padding: 10px 16px; background: #fff3e0; border-left: 4px solid #ff9800; border-radius: 8px; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
.index-commit a { display: block; text-decoration: none; color: inherit; }
.index-commit a:hover { background: rgba(255, 152, 0, 0.1); margin: -10px -16px; padding: 10px 16px; border-radius: 8px; }
.index-commit-header { display: flex; justify-content: space-between; align-items: center; font-size: 0.85rem; margin-bottom: 4px; }
.index-commit-hash { font-family: monospace; color: #e65100; font-weight: 600; }
.index-commit-msg { color: #5d4037; }
.index-item-long-text { margin-top: 8px; padding: 12px; background: var(--card-bg); border-radius: 8px; border-left: 3px solid var(--assistant-border); }
.index-item-long-text .truncatable.truncated::after { background: linear-gradient(to bottom, transparent, var(--card-bg)); }
.index-item-long-text-content { color: var(--text-color); }
#search-box { display: none; align-items: center; gap: 8px; }
#search-box input { padding: 6px 12px; border: 1px solid var(--assistant-border); border-radius: 6px; font-size: 16px; width: 180px; }
#search-box button, #modal-search-btn, #modal-close-btn { background: var(--user-border); color: white; border: none; border-radius: 6px; padding: 6px 10px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
#search-box button:hover, #modal-search-btn:hover { background: #1565c0; }
#modal-close-btn { background: var(--text-muted); margin-left: 8px; }
#modal-close-btn:hover { background: #616161; }
#search-modal[open] { border: none; border-radius: 12px; box-shadow: 0 4px 24px rgba(0,0,0,0.2); padding: 0; width: 90vw; max-width: 900px; height: 80vh; max-height: 80vh; display: flex; flex-direction: column; }
#search-modal::backdrop { background: rgba(0,0,0,0.5); }
.search-modal-header { display: flex; align-items: center; gap: 8px; padding: 16px; border-bottom: 1px solid var(--assistant-border); background: var(--bg-color); border-radius: 12px 12px 0 0; }
.search-modal-header input { flex: 1; padding: 8px 12px; border: 1px solid var(--assistant-border); border-radius: 6px; font-size: 16px; }
#search-status { padding: 8px 16px; font-size: 0.85rem; color: var(--text-muted); border-bottom: 1px solid rgba(0,0,0,0.06); }
#search-results { flex: 1; overflow-y: auto; padding: 16px; }
.search-result { margin-bottom: 16px; border-radius: 8px; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
.search-result a { display: block; text-decoration: none; color: inherit; }
.search-result a:hover { background: rgba(25, 118, 210, 0.05); }
.search-result-page { padding: 6px 12px; background: rgba(0,0,0,0.03); font-size: 0.8rem; color: var(--text-muted); border-bottom: 1px solid rgba(0,0,0,0.06); }
.search-result-content { padding: 12px; }
.search-result mark { background: #fff59d; padding: 1px 2px; border-radius: 2px; }
@media (max-width: 600px) { body { padding: 8px; } .message, .index-item { border-radius: 8px; } .message-content, .index-item-content { padding: 12px; } pre { font-size: 0.8rem; padding: 8px; } #search-box input { width: 120px; } #search-modal[open] { width: 95vw; height: 90vh; } }
</style>
</head>
<body>
    <div class="container">
        <h1><a href="index.html" style="color: inherit; text-decoration: none;">Claude Code transcript</a> - page 1/2</h1>
        

<div class="pagination">
<a href="index.html" class="index-link">Index</a>
<span class="disabled">&larr; Prev</span>
<span class="current">1</span>
<a href="page-002.html">2</a>
<a href="page-002.html">Next &rarr;</a>
</div>

        
<div class="message user" id="msg-2026-02-19T05-05-34-930Z"><div class="message-header"><span class="role-label">User</span><a href="#msg-2026-02-19T05-05-34-930Z" class="timestamp-link"><time datetime="2026-02-19T05:05:34.930Z" data-timestamp="2026-02-19T05:05:34.930Z">2026-02-19T05:05:34.930Z</time></a></div><div class="message-content">
<div class="user-content"><p>Implement the following plan:</p>
<h1>Fix Parser Infinite Loop &amp; Support Course Library Transpilation</h1>
<h2>Context</h2>
<p>When transpiling programs that <code>#INCLUDE "course.module"</code>, the parser enters an infinite loop causing OOM. The root cause is that occam allows multiple declarations (specifications) scoped before a process in IF/CASE/ALT/WHILE branch bodies, but the parser only calls <code>parseStatement()</code> once per body. After parsing the first declaration, it tries to interpret subsequent declarations as new branch conditions, looping forever.</p>
<p>A secondary issue is that channel direction annotations at call sites (<code>out!</code>, <code>in?</code>) aren't handled in expression parsing, causing the first parse error at line 188 of the preprocessed output.</p>
<h2>Changes</h2>
<h3>1. AST: Change <code>Body</code> from <code>Statement</code> to <code>[]Statement</code> (ast/ast.go)</h3>
<p>Change in four structs:
- <code>IfChoice.Body</code> (line ~207)
- <code>CaseChoice.Body</code> (line ~223)
- <code>AltCase.Body</code> (line ~397)
- <code>WhileLoop.Body</code> (line ~192)</p>
<h3>2. Parser: Add <code>parseBodyStatements()</code> helper (parser/parser.go)</h3>
<p>Add a new function modeled on <code>parseBlockStatements()</code> (line 1649) that:
- Is called after the caller has consumed the INDENT token
- Loops parsing statements at the current indent level until DEDENT
- Includes a "no progress" safety guard to prevent infinite loops
- Returns <code>[]ast.Statement</code></p>
<p>Update four call sites to use it:
- <code>parseIfStatement()</code> (line ~2225): replace <code>parseStatement()</code> with <code>parseBodyStatements()</code>
- <code>parseCaseStatement()</code> (line ~2305): same
- <code>parseWhileLoop()</code> (line ~2148): same
- <code>parseAltCase()</code> (line ~1635): same</p>
<h3>3. Parser: Handle channel direction at call sites (parser/parser.go)</h3>
<p>In <code>parseProcCall()</code> (line 1893): after each <code>parseExpression(LOWEST)</code> for an argument, check if <code>peekToken</code> is <code>SEND</code> (<code>!</code>) or <code>RECEIVE</code> (<code>?</code>) and consume it. The direction annotation is informational — in Go codegen we just pass the channel.</p>
<h3>4. Codegen: Update to iterate over body slices (codegen/codegen.go)</h3>
<p><strong>Generators</strong> — change <code>g.generateStatement(x.Body)</code> to loop:
- <code>generateWhileLoop()</code> (line 1503)
- <code>generateIfStatement()</code> (lines 1551, 1574)
- <code>generateCaseStatement()</code> (line 1605)
- <code>generateAltBlock()</code> (line 1252)</p>
<p><strong>Scanner functions</strong> — change <code>containsX(x.Body)</code> to loop over slice:
- <code>containsPar()</code> — AltCase (198), WhileLoop (215), IfChoice (220), CaseChoice (226)
- <code>containsPrint()</code> — same pattern at ~258, 275, 280, 286
- <code>containsTimer()</code> — same pattern at ~309, 338, 343, 349
- <code>containsStop()</code> — same pattern at ~381, 398, 403, 409
- <code>containsMostExpr()</code> — same pattern at ~468, 476, 490, 511
- <code>collectChanProtocols()</code> — same pattern at ~901, 906, 912, 918
- <code>collectRecordVars()</code> — same pattern at ~957, 962, 968, 974</p>
<p>Note: <code>VariantCase.Body</code> has the same single-statement pattern but is left for a follow-up.</p>
<h3>5. Tests</h3>
<ul>
<li>Update existing parser tests that access <code>.Body</code> (change <code>nil</code> checks to <code>len()</code> checks, access <code>Body[0]</code> instead of <code>Body</code>)</li>
<li>Add parser test for multi-statement IF body</li>
<li>Add parser test for channel direction at call site</li>
<li>Add e2e tests for both features</li>
</ul>
<h3>6. Documentation</h3>
<p>Update TODO.md to note these features are supported.</p>
<h2>Implementation Order</h2>
<ol>
<li>AST changes (will cause compile errors)</li>
<li>Parser changes (fixes parser compile errors)</li>
<li>Codegen changes (fixes codegen compile errors)</li>
<li>Test updates + new tests</li>
<li><code>go test ./...</code> to verify</li>
<li>Try transpiling course library demo</li>
</ol>
<h2>Verification</h2>
<pre><code class="language-bash">go test ./...                    # all existing tests pass
go build -o occam2go .
./occam2go gen-module -o kroc/modules/course/libsrc/course.module kroc/modules/course/libsrc/SConscript
./occam2go -I kroc/modules/course/libsrc kroc/demos/complexity/concurrent_hello_1.occ
</code></pre>
<p>Note: The full course library transpilation may surface additional unsupported constructs (e.g., <code>RETYPES</code> in float_io.occ). Those would be addressed as follow-up work. The immediate goal is fixing the infinite loop and the two feature gaps that block parsing.</p>
<p>If you need specific details from before exiting plan mode (like exact code snippets, error messages, or content you generated), read the full transcript at: /home/david/.claude/projects/-home-david-projects-code-associates-occam2go/c48afd9c-f64c-4ecf-931b-d6fbb0089261.jsonl</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-05-37-366Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-05-37-366Z" class="timestamp-link"><time datetime="2026-02-19T05:05:37.366Z" data-timestamp="2026-02-19T05:05:37.366Z">2026-02-19T05:05:37.366Z</time></a></div><div class="message-content">
<div class="assistant-text"></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-05-38-259Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-05-38-259Z" class="timestamp-link"><time datetime="2026-02-19T05:05:38.259Z" data-timestamp="2026-02-19T05:05:38.259Z">2026-02-19T05:05:38.259Z</time></a></div><div class="message-content">
<div class="thinking"><div class="thinking-label">Thinking</div><p>Let me start by understanding the current codebase state and then implement the changes in order. Let me read the key files first.</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-05-38-790Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-05-38-790Z" class="timestamp-link"><time datetime="2026-02-19T05:05:38.790Z" data-timestamp="2026-02-19T05:05:38.790Z">2026-02-19T05:05:38.790Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>I'll implement this step by step. Let me start by reading the key files.</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-05-39-447Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-05-39-447Z" class="timestamp-link"><time datetime="2026-02-19T05:05:39.447Z" data-timestamp="2026-02-19T05:05:39.447Z">2026-02-19T05:05:39.447Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01GFSN4BBGiNkvE5CpQzmgwZ"><div class="tool-header"><span class="tool-icon">⚙</span> Read</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;file_path&#34;: &#34;/home/david/projects/code-associates/occam2go/ast/ast.go&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-05-39-454Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-05-39-454Z" class="timestamp-link"><time datetime="2026-02-19T05:05:39.454Z" data-timestamp="2026-02-19T05:05:39.454Z">2026-02-19T05:05:39.454Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>     1→package ast
     2→
     3→import (
     4→	&quot;github.com/codeassociates/occam2go/lexer&quot;
     5→)
     6→
     7→// Node is the base interface for all AST nodes
     8→type Node interface {
     9→	TokenLiteral() string
    10→}
    11→
    12→// Statement represents a statement node
    13→type Statement interface {
    14→	Node
    15→	statementNode()
    16→}
    17→
    18→// Expression represents an expression node
    19→type Expression interface {
    20→	Node
    21→	expressionNode()
    22→}
    23→
    24→// Program is the root node of every AST
    25→type Program struct {
    26→	Statements []Statement
    27→}
    28→
    29→func (p *Program) TokenLiteral() string {
    30→	if len(p.Statements) &gt; 0 {
    31→		return p.Statements[0].TokenLiteral()
    32→	}
    33→	return &quot;&quot;
    34→}
    35→
    36→// VarDecl represents a variable declaration: INT x:
    37→type VarDecl struct {
    38→	Token lexer.Token // the type token (INT, BYTE, BOOL)
    39→	Type  string      // &quot;INT&quot;, &quot;BYTE&quot;, &quot;BOOL&quot;, etc.
    40→	Names []string    // variable names (can declare multiple: INT x, y, z:)
    41→}
    42→
    43→func (v *VarDecl) statementNode()       {}
    44→func (v *VarDecl) TokenLiteral() string { return v.Token.Literal }
    45→
    46→// ArrayDecl represents an array declaration: [5]INT arr:
    47→type ArrayDecl struct {
    48→	Token lexer.Token // the [ token
    49→	Size  Expression  // array size
    50→	Type  string      // element type (&quot;INT&quot;, &quot;BYTE&quot;, &quot;BOOL&quot;, etc.)
    51→	Names []string    // variable names
    52→}
    53→
    54→func (a *ArrayDecl) statementNode()       {}
    55→func (a *ArrayDecl) TokenLiteral() string { return a.Token.Literal }
    56→
    57→// Assignment represents an assignment: x := 5 or arr[i] := 5 or [arr FROM n FOR m] := value
    58→type Assignment struct {
    59→	Token       lexer.Token // the := token
    60→	Name        string      // variable name
    61→	Index       Expression  // optional: index expression for arr[i] := x (nil for simple assignments)
    62→	SliceTarget *SliceExpr  // optional: slice target for [arr FROM n FOR m] := value
    63→	Value       Expression  // the value being assigned
    64→}
    65→
    66→func (a *Assignment) statementNode()       {}
    67→func (a *Assignment) TokenLiteral() string { return a.Token.Literal }
    68→
    69→// MultiAssignTarget represents one target in a multi-assignment.
    70→// Name is always set. Index is non-nil for indexed targets like arr[i].
    71→type MultiAssignTarget struct {
    72→	Name  string     // variable name
    73→	Index Expression // optional: index expression for arr[i] (nil for simple ident)
    74→}
    75→
    76→// MultiAssignment represents a multi-target assignment: a, b := func(x)
    77→type MultiAssignment struct {
    78→	Token   lexer.Token         // the := token
    79→	Targets []MultiAssignTarget // targets on the left side
    80→	Values  []Expression        // expressions on the right side
    81→}
    82→
    83→func (m *MultiAssignment) statementNode()       {}
    84→func (m *MultiAssignment) TokenLiteral() string { return m.Token.Literal }
    85→
    86→// SeqBlock represents a SEQ block (sequential execution)
    87→// If Replicator is non-nil, this is a replicated SEQ (SEQ i = 0 FOR n)
    88→type SeqBlock struct {
    89→	Token      lexer.Token // the SEQ token
    90→	Statements []Statement
    91→	Replicator *Replicator // optional replicator
    92→}
    93→
    94→func (s *SeqBlock) statementNode()       {}
    95→func (s *SeqBlock) TokenLiteral() string { return s.Token.Literal }
    96→
    97→// ParBlock represents a PAR block (parallel execution)
    98→// If Replicator is non-nil, this is a replicated PAR (PAR i = 0 FOR n)
    99→type ParBlock struct {
   100→	Token      lexer.Token // the PAR token
   101→	Statements []Statement
   102→	Replicator *Replicator // optional replicator
   103→}
   104→
   105→func (p *ParBlock) statementNode()       {}
   106→func (p *ParBlock) TokenLiteral() string { return p.Token.Literal }
   107→
   108→// Replicator represents a replication spec: i = start FOR count [STEP step]
   109→type Replicator struct {
   110→	Variable string     // loop variable name
   111→	Start    Expression // start value
   112→	Count    Expression // number of iterations
   113→	Step     Expression // optional step value (nil means step of 1)
   114→}
   115→
   116→// Skip represents the SKIP statement (no-op)
   117→type Skip struct {
   118→	Token lexer.Token
   119→}
   120→
   121→func (s *Skip) statementNode()       {}
   122→func (s *Skip) TokenLiteral() string { return s.Token.Literal }
   123→
   124→// Stop represents the STOP statement (deadlock/halt)
   125→type Stop struct {
   126→	Token lexer.Token
   127→}
   128→
   129→func (s *Stop) statementNode()       {}
   130→func (s *Stop) TokenLiteral() string { return s.Token.Literal }
   131→
   132→// ProcDecl represents a procedure declaration
   133→type ProcDecl struct {
   134→	Token  lexer.Token // the PROC token
   135→	Name   string
   136→	Params []ProcParam
   137→	Body   []Statement // local declarations + body process
   138→}
   139→
   140→func (p *ProcDecl) statementNode()       {}
   141→func (p *ProcDecl) TokenLiteral() string { return p.Token.Literal }
   142→
   143→// ProcParam represents a procedure parameter
   144→type ProcParam struct {
   145→	IsVal        bool   // VAL parameter (pass by value)
   146→	Type         string // INT, BYTE, BOOL, etc.
   147→	Name         string
   148→	IsChan       bool   // true if this is a CHAN OF &lt;type&gt; parameter
   149→	IsChanArray  bool   // true for []CHAN OF TYPE params
   150→	IsOpenArray  bool   // true for []TYPE params (open array)
   151→	ChanElemType string // element type when IsChan (e.g., &quot;INT&quot;)
   152→	ChanDir      string // &quot;?&quot; for input, &quot;!&quot; for output, &quot;&quot; for bidirectional
   153→}
   154→
   155→// ProcCall represents a procedure call
   156→type ProcCall struct {
   157→	Token lexer.Token // the procedure name token
   158→	Name  string
   159→	Args  []Expression
   160→}
   161→
   162→func (p *ProcCall) statementNode()       {}
   163→func (p *ProcCall) TokenLiteral() string { return p.Token.Literal }
   164→
   165→// FuncDecl represents a function declaration (single or multi-result)
   166→type FuncDecl struct {
   167→	Token       lexer.Token    // the return type token
   168→	ReturnTypes []string       // return types: [&quot;INT&quot;], [&quot;INT&quot;, &quot;INT&quot;], etc.
   169→	Name        string
   170→	Params      []ProcParam
   171→	Body        []Statement    // local decls + body statements (VALOF form), empty for IS form
   172→	ResultExprs []Expression   // return expressions (from IS or RESULT)
   173→}
   174→
   175→func (f *FuncDecl) statementNode()       {}
   176→func (f *FuncDecl) TokenLiteral() string { return f.Token.Literal }
   177→
   178→// FuncCall represents a function call expression
   179→type FuncCall struct {
   180→	Token lexer.Token // the function name token
   181→	Name  string
   182→	Args  []Expression
   183→}
   184→
   185→func (f *FuncCall) expressionNode()      {}
   186→func (f *FuncCall) TokenLiteral() string { return f.Token.Literal }
   187→
   188→// WhileLoop represents a WHILE loop
   189→type WhileLoop struct {
   190→	Token     lexer.Token // the WHILE token
   191→	Condition Expression
   192→	Body      Statement
   193→}
   194→
   195→func (w *WhileLoop) statementNode()       {}
   196→func (w *WhileLoop) TokenLiteral() string { return w.Token.Literal }
   197→
   198→// IfStatement represents an IF statement
   199→type IfStatement struct {
   200→	Token      lexer.Token // the IF token
   201→	Choices    []IfChoice
   202→	Replicator *Replicator // optional replicator for IF i = start FOR count
   203→}
   204→
   205→type IfChoice struct {
   206→	Condition Expression
   207→	Body      Statement
   208→}
   209→
   210→func (i *IfStatement) statementNode()       {}
   211→func (i *IfStatement) TokenLiteral() string { return i.Token.Literal }
   212→
   213→// CaseStatement represents a CASE statement
   214→type CaseStatement struct {
   215→	Token    lexer.Token  // the CASE token
   216→	Selector Expression   // the selector expression
   217→	Choices  []CaseChoice
   218→}
   219→
   220→type CaseChoice struct {
   221→	Values []Expression // nil/empty for ELSE
   222→	IsElse bool
   223→	Body   Statement
   224→}
   225→
   226→func (c *CaseStatement) statementNode()       {}
   227→func (c *CaseStatement) TokenLiteral() string { return c.Token.Literal }
   228→
   229→// Expressions
   230→
   231→// Identifier represents a variable reference
   232→type Identifier struct {
   233→	Token lexer.Token
   234→	Value string
   235→}
   236→
   237→func (i *Identifier) expressionNode()      {}
   238→func (i *Identifier) TokenLiteral() string { return i.Token.Literal }
   239→
   240→// IntegerLiteral represents an integer literal
   241→type IntegerLiteral struct {
   242→	Token lexer.Token
   243→	Value int64
   244→}
   245→
   246→func (il *IntegerLiteral) expressionNode()      {}
   247→func (il *IntegerLiteral) TokenLiteral() string { return il.Token.Literal }
   248→
   249→// BooleanLiteral represents TRUE or FALSE
   250→type BooleanLiteral struct {
   251→	Token lexer.Token
   252→	Value bool
   253→}
   254→
   255→func (bl *BooleanLiteral) expressionNode()      {}
   256→func (bl *BooleanLiteral) TokenLiteral() string { return bl.Token.Literal }
   257→
   258→// StringLiteral represents a string literal: &quot;hello&quot;
   259→type StringLiteral struct {
   260→	Token lexer.Token
   261→	Value string
   262→}
   263→
   264→func (sl *StringLiteral) expressionNode()      {}
   265→func (sl *StringLiteral) TokenLiteral() string { return sl.Token.Literal }
   266→
   267→// ByteLiteral represents a byte literal: &#x27;A&#x27;, &#x27;*n&#x27;, etc.
   268→type ByteLiteral struct {
   269→	Token lexer.Token
   270→	Value byte
   271→}
   272→
   273→func (bl *ByteLiteral) expressionNode()      {}
   274→func (bl *ByteLiteral) TokenLiteral() string { return bl.Token.Literal }
   275→
   276→// BinaryExpr represents a binary operation: x + y
   277→type BinaryExpr struct {
   278→	Token    lexer.Token // the operator token
   279→	Left     Expression
   280→	Operator string
   281→	Right    Expression
   282→}
   283→
   284→func (be *BinaryExpr) expressionNode()      {}
   285→func (be *BinaryExpr) TokenLiteral() string { return be.Token.Literal }
   286→
   287→// UnaryExpr represents a unary operation: NOT x, -x
   288→type UnaryExpr struct {
   289→	Token    lexer.Token // the operator token
   290→	Operator string
   291→	Right    Expression
   292→}
   293→
   294→func (ue *UnaryExpr) expressionNode()      {}
   295→func (ue *UnaryExpr) TokenLiteral() string { return ue.Token.Literal }
   296→
   297→// TypeConversion represents a type conversion expression: INT x, BYTE n, etc.
   298→type TypeConversion struct {
   299→	Token      lexer.Token // the type token (INT, BYTE, etc.)
   300→	TargetType string      // &quot;INT&quot;, &quot;BYTE&quot;, &quot;BOOL&quot;, &quot;REAL&quot;
   301→	Expr       Expression  // the expression to convert
   302→}
   303→
   304→func (tc *TypeConversion) expressionNode()      {}
   305→func (tc *TypeConversion) TokenLiteral() string { return tc.Token.Literal }
   306→
   307→// SizeExpr represents a SIZE expression: SIZE arr
   308→type SizeExpr struct {
   309→	Token lexer.Token // the SIZE token
   310→	Expr  Expression  // the array/string expression
   311→}
   312→
   313→func (se *SizeExpr) expressionNode()      {}
   314→func (se *SizeExpr) TokenLiteral() string { return se.Token.Literal }
   315→
   316→// MostExpr represents MOSTNEG/MOSTPOS type expressions: MOSTNEG INT, MOSTPOS BYTE, etc.
   317→type MostExpr struct {
   318→	Token    lexer.Token // the MOSTNEG or MOSTPOS token
   319→	ExprType string      // &quot;INT&quot;, &quot;BYTE&quot;, &quot;REAL32&quot;, &quot;REAL64&quot;, etc.
   320→	IsNeg    bool        // true for MOSTNEG, false for MOSTPOS
   321→}
   322→
   323→func (me *MostExpr) expressionNode()      {}
   324→func (me *MostExpr) TokenLiteral() string { return me.Token.Literal }
   325→
   326→// ParenExpr represents a parenthesized expression
   327→type ParenExpr struct {
   328→	Token lexer.Token
   329→	Expr  Expression
   330→}
   331→
   332→func (pe *ParenExpr) expressionNode()      {}
   333→func (pe *ParenExpr) TokenLiteral() string { return pe.Token.Literal }
   334→
   335→// IndexExpr represents an array index expression: arr[i]
   336→type IndexExpr struct {
   337→	Token lexer.Token // the [ token
   338→	Left  Expression  // the array expression
   339→	Index Expression  // the index expression
   340→}
   341→
   342→func (ie *IndexExpr) expressionNode()      {}
   343→func (ie *IndexExpr) TokenLiteral() string { return ie.Token.Literal }
   344→
   345→// ChanDecl represents a channel declaration: CHAN OF INT c: or [n]CHAN OF INT cs:
   346→type ChanDecl struct {
   347→	Token    lexer.Token // the CHAN token
   348→	ElemType string      // the element type (INT, BYTE, etc.)
   349→	Names    []string    // channel names
   350→	IsArray  bool        // true for [n]CHAN OF TYPE
   351→	Size     Expression  // array size when IsArray
   352→}
   353→
   354→func (c *ChanDecl) statementNode()       {}
   355→func (c *ChanDecl) TokenLiteral() string { return c.Token.Literal }
   356→
   357→// Send represents a channel send: c ! x or c ! x ; y or c ! tag ; x
   358→type Send struct {
   359→	Token        lexer.Token  // the ! token
   360→	Channel      string       // channel name
   361→	ChannelIndex Expression   // non-nil for cs[i] ! value
   362→	Value        Expression   // value to send (simple send, backward compat)
   363→	Values       []Expression // additional values for sequential sends (c ! x ; y)
   364→	VariantTag   string       // variant tag name for variant sends (c ! tag ; x)
   365→}
   366→
   367→func (s *Send) statementNode()       {}
   368→func (s *Send) TokenLiteral() string { return s.Token.Literal }
   369→
   370→// Receive represents a channel receive: c ? x or c ? x ; y
   371→type Receive struct {
   372→	Token        lexer.Token // the ? token
   373→	Channel      string      // channel name
   374→	ChannelIndex Expression  // non-nil for cs[i] ? x
   375→	Variable     string      // variable to receive into (simple receive)
   376→	Variables    []string    // additional variables for sequential receives (c ? x ; y)
   377→}
   378→
   379→func (r *Receive) statementNode()       {}
   380→func (r *Receive) TokenLiteral() string { return r.Token.Literal }
   381→
   382→// AltBlock represents an ALT block (alternation/select)
   383→type AltBlock struct {
   384→	Token lexer.Token // the ALT token
   385→	Cases []AltCase
   386→}
   387→
   388→func (a *AltBlock) statementNode()       {}
   389→func (a *AltBlock) TokenLiteral() string { return a.Token.Literal }
   390→
   391→// AltCase represents a single case in an ALT block
   392→type AltCase struct {
   393→	Guard        Expression // optional guard condition (nil if no guard)
   394→	Channel      string     // channel name
   395→	ChannelIndex Expression // non-nil for cs[i] ? x in ALT
   396→	Variable     string     // variable to receive into
   397→	Body         Statement  // the body to execute
   398→	IsTimer      bool       // true if this is a timer AFTER case
   399→	Timer        string     // timer name (when IsTimer)
   400→	Deadline     Expression // AFTER deadline expression (when IsTimer)
   401→}
   402→
   403→// TimerDecl represents a timer declaration: TIMER tim:
   404→type TimerDecl struct {
   405→	Token lexer.Token // the TIMER token
   406→	Names []string    // timer variable names
   407→}
   408→
   409→func (td *TimerDecl) statementNode()       {}
   410→func (td *TimerDecl) TokenLiteral() string { return td.Token.Literal }
   411→
   412→// TimerRead represents a timer read: tim ? t
   413→type TimerRead struct {
   414→	Token    lexer.Token // the ? token
   415→	Timer    string      // timer name
   416→	Variable string      // variable to receive time into
   417→}
   418→
   419→func (tr *TimerRead) statementNode()       {}
   420→func (tr *TimerRead) TokenLiteral() string { return tr.Token.Literal }
   421→
   422→// ProtocolDecl represents a protocol declaration
   423→type ProtocolDecl struct {
   424→	Token    lexer.Token       // the PROTOCOL token
   425→	Name     string            // protocol name
   426→	Kind     string            // &quot;simple&quot;, &quot;sequential&quot;, or &quot;variant&quot;
   427→	Types    []string          // element types (simple: len=1, sequential: len&gt;1)
   428→	Variants []ProtocolVariant // only for Kind=&quot;variant&quot;
   429→}
   430→
   431→type ProtocolVariant struct {
   432→	Tag   string   // tag name (e.g., &quot;text&quot;, &quot;quit&quot;)
   433→	Types []string // associated types (empty for no-payload tags)
   434→}
   435→
   436→func (pd *ProtocolDecl) statementNode()       {}
   437→func (pd *ProtocolDecl) TokenLiteral() string { return pd.Token.Literal }
   438→
   439→// VariantReceive represents a variant protocol receive: c ? CASE ...
   440→type VariantReceive struct {
   441→	Token        lexer.Token // the ? token
   442→	Channel      string
   443→	ChannelIndex Expression // non-nil for cs[i] ? CASE ...
   444→	Cases        []VariantCase
   445→}
   446→
   447→type VariantCase struct {
   448→	Tag       string    // variant tag name
   449→	Variables []string  // variables to bind payload fields
   450→	Body      Statement
   451→}
   452→
   453→func (vr *VariantReceive) statementNode()       {}
   454→func (vr *VariantReceive) TokenLiteral() string { return vr.Token.Literal }
   455→
   456→// RecordDecl represents a record type declaration: RECORD POINT { INT x: INT y: }
   457→type RecordDecl struct {
   458→	Token  lexer.Token   // the RECORD token
   459→	Name   string        // record type name
   460→	Fields []RecordField // named fields
   461→}
   462→
   463→type RecordField struct {
   464→	Type string // &quot;INT&quot;, &quot;BYTE&quot;, &quot;BOOL&quot;, &quot;REAL&quot;
   465→	Name string
   466→}
   467→
   468→func (rd *RecordDecl) statementNode()       {}
   469→func (rd *RecordDecl) TokenLiteral() string { return rd.Token.Literal }
   470→
   471→// SliceExpr represents an array slice: [arr FROM start FOR length]
   472→type SliceExpr struct {
   473→	Token  lexer.Token // the [ token
   474→	Array  Expression  // the array being sliced
   475→	Start  Expression  // start index
   476→	Length Expression  // number of elements
   477→}
   478→
   479→func (se *SliceExpr) expressionNode()      {}
   480→func (se *SliceExpr) TokenLiteral() string { return se.Token.Literal }
   481→
   482→// Abbreviation represents an abbreviation: VAL INT x IS 42:, INT y IS z:, or INITIAL INT x IS 42:
   483→type Abbreviation struct {
   484→	Token     lexer.Token // VAL, INITIAL, or type token
   485→	IsVal     bool        // true for VAL abbreviations
   486→	IsInitial bool        // true for INITIAL declarations
   487→	Type      string      // &quot;INT&quot;, &quot;BYTE&quot;, &quot;BOOL&quot;, etc.
   488→	Name      string      // variable name
   489→	Value     Expression  // the expression
   490→}
   491→
   492→func (a *Abbreviation) statementNode()       {}
   493→func (a *Abbreviation) TokenLiteral() string { return a.Token.Literal }
   494→</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-05-39-793Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-05-39-793Z" class="timestamp-link"><time datetime="2026-02-19T05:05:39.793Z" data-timestamp="2026-02-19T05:05:39.793Z">2026-02-19T05:05:39.793Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01HT4BHihpmgQrDPpPNbpU8F"><div class="tool-header"><span class="tool-icon">⚙</span> Read</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;file_path&#34;: &#34;/home/david/projects/code-associates/occam2go/parser/parser.go&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-05-40-114Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-05-40-114Z" class="timestamp-link"><time datetime="2026-02-19T05:05:40.114Z" data-timestamp="2026-02-19T05:05:40.114Z">2026-02-19T05:05:40.114Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>     1→package parser
     2→
     3→import (
     4→	&quot;fmt&quot;
     5→	&quot;strconv&quot;
     6→	&quot;strings&quot;
     7→
     8→	&quot;github.com/codeassociates/occam2go/ast&quot;
     9→	&quot;github.com/codeassociates/occam2go/lexer&quot;
    10→)
    11→
    12→// Operator precedence levels
    13→const (
    14→	_ int = iota
    15→	LOWEST
    16→	OR_PREC      // OR
    17→	AND_PREC     // AND
    18→	EQUALS       // =, &lt;&gt;
    19→	LESSGREATER  // &lt;, &gt;, &lt;=, &gt;=
    20→	SUM          // +, -
    21→	PRODUCT      // *, /, \
    22→	PREFIX       // -x, NOT x
    23→	INDEX        // arr[i]
    24→)
    25→
    26→var precedences = map[lexer.TokenType]int{
    27→	lexer.OR:       OR_PREC,
    28→	lexer.AND:      AND_PREC,
    29→	lexer.EQ:       EQUALS,
    30→	lexer.NEQ:      EQUALS,
    31→	lexer.LT:       LESSGREATER,
    32→	lexer.GT:       LESSGREATER,
    33→	lexer.LE:       LESSGREATER,
    34→	lexer.GE:       LESSGREATER,
    35→	lexer.AFTER:    LESSGREATER,
    36→	lexer.PLUS:     SUM,
    37→	lexer.MINUS:    SUM,
    38→	lexer.PLUS_KW:  SUM,
    39→	lexer.MINUS_KW: SUM,
    40→	lexer.MULTIPLY: PRODUCT,
    41→	lexer.DIVIDE:   PRODUCT,
    42→	lexer.MODULO:   PRODUCT,
    43→	lexer.TIMES:    PRODUCT,
    44→	lexer.BITAND:   PRODUCT,
    45→	lexer.LSHIFT:   PRODUCT,
    46→	lexer.RSHIFT:   PRODUCT,
    47→	lexer.BITOR:    SUM,
    48→	lexer.BITXOR:   SUM,
    49→	lexer.LBRACKET: INDEX,
    50→}
    51→
    52→type Parser struct {
    53→	l      *lexer.Lexer
    54→	errors []string
    55→
    56→	curToken  lexer.Token
    57→	peekToken lexer.Token
    58→
    59→	// Track current indentation level
    60→	indentLevel int
    61→
    62→	// Track timer names to distinguish timer reads from channel receives
    63→	timerNames map[string]bool
    64→
    65→	// Track protocol names and definitions
    66→	protocolNames map[string]bool
    67→	protocolDefs  map[string]*ast.ProtocolDecl
    68→
    69→	// Track record type names and definitions
    70→	recordNames map[string]bool
    71→	recordDefs  map[string]*ast.RecordDecl
    72→}
    73→
    74→func New(l *lexer.Lexer) *Parser {
    75→	p := &amp;Parser{
    76→		l:             l,
    77→		errors:        []string{},
    78→		timerNames:    make(map[string]bool),
    79→		protocolNames: make(map[string]bool),
    80→		protocolDefs:  make(map[string]*ast.ProtocolDecl),
    81→		recordNames:   make(map[string]bool),
    82→		recordDefs:    make(map[string]*ast.RecordDecl),
    83→	}
    84→	// Read two tokens to initialize curToken and peekToken
    85→	p.nextToken()
    86→	p.nextToken()
    87→	return p
    88→}
    89→
    90→func (p *Parser) Errors() []string {
    91→	return p.errors
    92→}
    93→
    94→func (p *Parser) addError(msg string) {
    95→	p.errors = append(p.errors, fmt.Sprintf(&quot;line %d: %s&quot;, p.curToken.Line, msg))
    96→}
    97→
    98→func (p *Parser) nextToken() {
    99→	p.curToken = p.peekToken
   100→	p.peekToken = p.l.NextToken()
   101→
   102→	// Track indentation level
   103→	if p.curToken.Type == lexer.INDENT {
   104→		p.indentLevel++
   105→	} else if p.curToken.Type == lexer.DEDENT {
   106→		p.indentLevel--
   107→	}
   108→}
   109→
   110→func (p *Parser) curTokenIs(t lexer.TokenType) bool {
   111→	return p.curToken.Type == t
   112→}
   113→
   114→func (p *Parser) peekTokenIs(t lexer.TokenType) bool {
   115→	return p.peekToken.Type == t
   116→}
   117→
   118→func (p *Parser) expectPeek(t lexer.TokenType) bool {
   119→	if p.peekTokenIs(t) {
   120→		p.nextToken()
   121→		return true
   122→	}
   123→	p.addError(fmt.Sprintf(&quot;expected %s, got %s&quot;, t, p.peekToken.Type))
   124→	return false
   125→}
   126→
   127→func (p *Parser) peekPrecedence() int {
   128→	if prec, ok := precedences[p.peekToken.Type]; ok {
   129→		return prec
   130→	}
   131→	return LOWEST
   132→}
   133→
   134→func (p *Parser) curPrecedence() int {
   135→	if prec, ok := precedences[p.curToken.Type]; ok {
   136→		return prec
   137→	}
   138→	return LOWEST
   139→}
   140→
   141→// ParseProgram parses the entire program
   142→func (p *Parser) ParseProgram() *ast.Program {
   143→	program := &amp;ast.Program{}
   144→	program.Statements = []ast.Statement{}
   145→
   146→	for !p.curTokenIs(lexer.EOF) {
   147→		stmt := p.parseStatement()
   148→		if stmt != nil {
   149→			program.Statements = append(program.Statements, stmt)
   150→		}
   151→		p.nextToken()
   152→	}
   153→
   154→	return program
   155→}
   156→
   157→func (p *Parser) parseStatement() ast.Statement {
   158→	// Skip newlines
   159→	for p.curTokenIs(lexer.NEWLINE) {
   160→		p.nextToken()
   161→	}
   162→
   163→	switch p.curToken.Type {
   164→	case lexer.VAL:
   165→		return p.parseAbbreviation()
   166→	case lexer.INITIAL:
   167→		return p.parseInitialDecl()
   168→	case lexer.INT_TYPE, lexer.BYTE_TYPE, lexer.BOOL_TYPE, lexer.REAL_TYPE, lexer.REAL32_TYPE, lexer.REAL64_TYPE:
   169→		if p.peekTokenIs(lexer.FUNCTION) || p.peekTokenIs(lexer.FUNC) || p.peekTokenIs(lexer.COMMA) {
   170→			return p.parseFuncDecl()
   171→		}
   172→		return p.parseVarDeclOrAbbreviation()
   173→	case lexer.LBRACKET:
   174→		return p.parseArrayDecl()
   175→	case lexer.CHAN:
   176→		return p.parseChanDecl()
   177→	case lexer.PROTOCOL:
   178→		return p.parseProtocolDecl()
   179→	case lexer.RECORD:
   180→		return p.parseRecordDecl()
   181→	case lexer.TIMER:
   182→		return p.parseTimerDecl()
   183→	case lexer.SEQ:
   184→		return p.parseSeqBlock()
   185→	case lexer.PAR:
   186→		return p.parseParBlock()
   187→	case lexer.ALT:
   188→		return p.parseAltBlock()
   189→	case lexer.SKIP:
   190→		return &amp;ast.Skip{Token: p.curToken}
   191→	case lexer.STOP:
   192→		return &amp;ast.Stop{Token: p.curToken}
   193→	case lexer.PROC:
   194→		return p.parseProcDecl()
   195→	case lexer.WHILE:
   196→		return p.parseWhileLoop()
   197→	case lexer.IF:
   198→		return p.parseIfStatement()
   199→	case lexer.CASE:
   200→		return p.parseCaseStatement()
   201→	case lexer.IDENT:
   202→		// Check for record variable declaration: TYPENAME var:
   203→		if p.recordNames[p.curToken.Literal] &amp;&amp; p.peekTokenIs(lexer.IDENT) {
   204→			return p.parseRecordVarDecl()
   205→		}
   206→		// Could be assignment, indexed assignment, indexed send/receive, send, receive, or procedure call
   207→		if p.peekTokenIs(lexer.LBRACKET) {
   208→			return p.parseIndexedOperation()
   209→		}
   210→		if p.peekTokenIs(lexer.ASSIGN) {
   211→			return p.parseAssignment()
   212→		}
   213→		if p.peekTokenIs(lexer.COMMA) {
   214→			return p.parseMultiAssignment()
   215→		}
   216→		if p.peekTokenIs(lexer.SEND) {
   217→			return p.parseSend()
   218→		}
   219→		if p.peekTokenIs(lexer.RECEIVE) {
   220→			if p.timerNames[p.curToken.Literal] {
   221→				return p.parseTimerRead()
   222→			}
   223→			return p.parseReceive()
   224→		}
   225→		return p.parseProcCall()
   226→	case lexer.INDENT, lexer.DEDENT, lexer.EOF:
   227→		return nil
   228→	default:
   229→		p.addError(fmt.Sprintf(&quot;unexpected token: %s&quot;, p.curToken.Type))
   230→		return nil
   231→	}
   232→}
   233→
   234→func (p *Parser) parseVarDecl() *ast.VarDecl {
   235→	decl := &amp;ast.VarDecl{
   236→		Token: p.curToken,
   237→		Type:  p.curToken.Literal,
   238→	}
   239→
   240→	// Parse variable names
   241→	for {
   242→		if !p.expectPeek(lexer.IDENT) {
   243→			return nil
   244→		}
   245→		decl.Names = append(decl.Names, p.curToken.Literal)
   246→
   247→		if p.peekTokenIs(lexer.COMMA) {
   248→			p.nextToken() // consume comma
   249→		} else {
   250→			break
   251→		}
   252→	}
   253→
   254→	if !p.expectPeek(lexer.COLON) {
   255→		return nil
   256→	}
   257→
   258→	return decl
   259→}
   260→
   261→// parseVarDeclOrAbbreviation parses either a variable declaration (INT x:)
   262→// or a non-VAL abbreviation (INT x IS expr:). Called when current token is a type keyword.
   263→func (p *Parser) parseVarDeclOrAbbreviation() ast.Statement {
   264→	typeToken := p.curToken
   265→	typeName := p.curToken.Literal
   266→
   267→	// Consume the name
   268→	if !p.expectPeek(lexer.IDENT) {
   269→		return nil
   270→	}
   271→	name := p.curToken.Literal
   272→
   273→	// Check if this is an abbreviation (next token is IS)
   274→	if p.peekTokenIs(lexer.IS) {
   275→		p.nextToken() // consume IS
   276→		p.nextToken() // move to expression
   277→		value := p.parseExpression(LOWEST)
   278→
   279→		if !p.expectPeek(lexer.COLON) {
   280→			return nil
   281→		}
   282→
   283→		return &amp;ast.Abbreviation{
   284→			Token: typeToken,
   285→			IsVal: false,
   286→			Type:  typeName,
   287→			Name:  name,
   288→			Value: value,
   289→		}
   290→	}
   291→
   292→	// Otherwise, it&#x27;s a regular variable declaration — continue parsing names
   293→	decl := &amp;ast.VarDecl{
   294→		Token: typeToken,
   295→		Type:  typeName,
   296→		Names: []string{name},
   297→	}
   298→
   299→	// Parse additional comma-separated names
   300→	for p.peekTokenIs(lexer.COMMA) {
   301→		p.nextToken() // consume comma
   302→		if !p.expectPeek(lexer.IDENT) {
   303→			return nil
   304→		}
   305→		decl.Names = append(decl.Names, p.curToken.Literal)
   306→	}
   307→
   308→	if !p.expectPeek(lexer.COLON) {
   309→		return nil
   310→	}
   311→
   312→	return decl
   313→}
   314→
   315→// parseAbbreviation parses a VAL abbreviation: VAL INT x IS expr:
   316→// Current token is VAL.
   317→func (p *Parser) parseAbbreviation() *ast.Abbreviation {
   318→	token := p.curToken // VAL token
   319→
   320→	// Expect a type keyword
   321→	p.nextToken()
   322→	if !p.curTokenIs(lexer.INT_TYPE) &amp;&amp; !p.curTokenIs(lexer.BYTE_TYPE) &amp;&amp;
   323→		!p.curTokenIs(lexer.BOOL_TYPE) &amp;&amp; !p.curTokenIs(lexer.REAL_TYPE) &amp;&amp;
   324→		!p.curTokenIs(lexer.REAL32_TYPE) &amp;&amp; !p.curTokenIs(lexer.REAL64_TYPE) {
   325→		p.addError(fmt.Sprintf(&quot;expected type after VAL, got %s&quot;, p.curToken.Type))
   326→		return nil
   327→	}
   328→	typeName := p.curToken.Literal
   329→
   330→	// Expect name
   331→	if !p.expectPeek(lexer.IDENT) {
   332→		return nil
   333→	}
   334→	name := p.curToken.Literal
   335→
   336→	// Expect IS
   337→	if !p.expectPeek(lexer.IS) {
   338→		return nil
   339→	}
   340→
   341→	// Parse expression
   342→	p.nextToken()
   343→	value := p.parseExpression(LOWEST)
   344→
   345→	// Expect colon
   346→	if !p.expectPeek(lexer.COLON) {
   347→		return nil
   348→	}
   349→
   350→	return &amp;ast.Abbreviation{
   351→		Token: token,
   352→		IsVal: true,
   353→		Type:  typeName,
   354→		Name:  name,
   355→		Value: value,
   356→	}
   357→}
   358→
   359→// parseInitialDecl parses an INITIAL declaration: INITIAL INT x IS expr:
   360→// Current token is INITIAL.
   361→func (p *Parser) parseInitialDecl() *ast.Abbreviation {
   362→	token := p.curToken // INITIAL token
   363→
   364→	// Expect a type keyword
   365→	p.nextToken()
   366→	if !p.curTokenIs(lexer.INT_TYPE) &amp;&amp; !p.curTokenIs(lexer.BYTE_TYPE) &amp;&amp;
   367→		!p.curTokenIs(lexer.BOOL_TYPE) &amp;&amp; !p.curTokenIs(lexer.REAL_TYPE) &amp;&amp;
   368→		!p.curTokenIs(lexer.REAL32_TYPE) &amp;&amp; !p.curTokenIs(lexer.REAL64_TYPE) {
   369→		p.addError(fmt.Sprintf(&quot;expected type after INITIAL, got %s&quot;, p.curToken.Type))
   370→		return nil
   371→	}
   372→	typeName := p.curToken.Literal
   373→
   374→	// Expect name
   375→	if !p.expectPeek(lexer.IDENT) {
   376→		return nil
   377→	}
   378→	name := p.curToken.Literal
   379→
   380→	// Expect IS
   381→	if !p.expectPeek(lexer.IS) {
   382→		return nil
   383→	}
   384→
   385→	// Parse expression
   386→	p.nextToken()
   387→	value := p.parseExpression(LOWEST)
   388→
   389→	// Expect colon
   390→	if !p.expectPeek(lexer.COLON) {
   391→		return nil
   392→	}
   393→
   394→	return &amp;ast.Abbreviation{
   395→		Token:     token,
   396→		IsInitial: true,
   397→		Type:      typeName,
   398→		Name:      name,
   399→		Value:     value,
   400→	}
   401→}
   402→
   403→func (p *Parser) parseAssignment() *ast.Assignment {
   404→	stmt := &amp;ast.Assignment{
   405→		Name: p.curToken.Literal,
   406→	}
   407→
   408→	p.nextToken() // move to :=
   409→	stmt.Token = p.curToken
   410→
   411→	p.nextToken() // move past :=
   412→	stmt.Value = p.parseExpression(LOWEST)
   413→
   414→	return stmt
   415→}
   416→
   417→func (p *Parser) parseMultiAssignment() *ast.MultiAssignment {
   418→	firstTarget := ast.MultiAssignTarget{Name: p.curToken.Literal}
   419→	return p.parseMultiAssignmentFrom(firstTarget)
   420→}
   421→
   422→// parseMultiAssignmentFrom parses a multi-assignment given the first target already parsed.
   423→// The current token should be on the first target&#x27;s last token (ident or &#x27;]&#x27;).
   424→// Peek token should be COMMA.
   425→func (p *Parser) parseMultiAssignmentFrom(firstTarget ast.MultiAssignTarget) *ast.MultiAssignment {
   426→	stmt := &amp;ast.MultiAssignment{
   427→		Targets: []ast.MultiAssignTarget{firstTarget},
   428→	}
   429→
   430→	// Parse comma-separated targets: a, b[i], c
   431→	for p.peekTokenIs(lexer.COMMA) {
   432→		p.nextToken() // consume comma
   433→		p.nextToken() // move to next target
   434→		target := ast.MultiAssignTarget{Name: p.curToken.Literal}
   435→		if p.peekTokenIs(lexer.LBRACKET) {
   436→			p.nextToken() // move to [
   437→			p.nextToken() // move past [
   438→			target.Index = p.parseExpression(LOWEST)
   439→			if !p.expectPeek(lexer.RBRACKET) {
   440→				return nil
   441→			}
   442→		}
   443→		stmt.Targets = append(stmt.Targets, target)
   444→	}
   445→
   446→	p.nextToken() // move to :=
   447→	stmt.Token = p.curToken
   448→
   449→	p.nextToken() // move past :=
   450→
   451→	// Parse comma-separated values
   452→	stmt.Values = []ast.Expression{p.parseExpression(LOWEST)}
   453→	for p.peekTokenIs(lexer.COMMA) {
   454→		p.nextToken() // consume comma
   455→		p.nextToken() // move to next expression
   456→		stmt.Values = append(stmt.Values, p.parseExpression(LOWEST))
   457→	}
   458→
   459→	return stmt
   460→}
   461→
   462→func (p *Parser) parseArrayDecl() ast.Statement {
   463→	lbracketToken := p.curToken
   464→
   465→	// Parse size expression after [
   466→	p.nextToken()
   467→	size := p.parseExpression(LOWEST)
   468→
   469→	// Check if this is a slice assignment: [arr FROM start FOR length] := value
   470→	if p.peekTokenIs(lexer.FROM) {
   471→		return p.parseSliceAssignment(lbracketToken, size)
   472→	}
   473→
   474→	// Expect ]
   475→	if !p.expectPeek(lexer.RBRACKET) {
   476→		return nil
   477→	}
   478→
   479→	// Check if this is a channel array: [n]CHAN OF TYPE
   480→	if p.peekTokenIs(lexer.CHAN) {
   481→		p.nextToken() // move to CHAN
   482→		chanDecl := &amp;ast.ChanDecl{
   483→			Token:   p.curToken,
   484→			IsArray: true,
   485→			Size:    size,
   486→		}
   487→
   488→		// Expect OF (optional — CHAN BYTE is shorthand for CHAN OF BYTE)
   489→		if p.peekTokenIs(lexer.OF) {
   490→			p.nextToken() // consume OF
   491→		}
   492→
   493→		// Expect type (INT, BYTE, BOOL, etc.) or protocol name (IDENT)
   494→		p.nextToken()
   495→		if p.curTokenIs(lexer.INT_TYPE) || p.curTokenIs(lexer.BYTE_TYPE) ||
   496→			p.curTokenIs(lexer.BOOL_TYPE) || p.curTokenIs(lexer.REAL_TYPE) ||
   497→			p.curTokenIs(lexer.REAL32_TYPE) || p.curTokenIs(lexer.REAL64_TYPE) {
   498→			chanDecl.ElemType = p.curToken.Literal
   499→		} else if p.curTokenIs(lexer.IDENT) {
   500→			chanDecl.ElemType = p.curToken.Literal
   501→		} else {
   502→			p.addError(fmt.Sprintf(&quot;expected type after CHAN, got %s&quot;, p.curToken.Type))
   503→			return nil
   504→		}
   505→
   506→		// Parse channel names
   507→		for {
   508→			if !p.expectPeek(lexer.IDENT) {
   509→				return nil
   510→			}
   511→			chanDecl.Names = append(chanDecl.Names, p.curToken.Literal)
   512→
   513→			if p.peekTokenIs(lexer.COMMA) {
   514→				p.nextToken() // consume comma
   515→			} else {
   516→				break
   517→			}
   518→		}
   519→
   520→		if !p.expectPeek(lexer.COLON) {
   521→			return nil
   522→		}
   523→
   524→		return chanDecl
   525→	}
   526→
   527→	// Regular array declaration
   528→	decl := &amp;ast.ArrayDecl{Token: lbracketToken, Size: size}
   529→
   530→	// Expect type (INT, BYTE, BOOL, REAL, REAL32, REAL64)
   531→	p.nextToken()
   532→	if !p.curTokenIs(lexer.INT_TYPE) &amp;&amp; !p.curTokenIs(lexer.BYTE_TYPE) &amp;&amp;
   533→		!p.curTokenIs(lexer.BOOL_TYPE) &amp;&amp; !p.curTokenIs(lexer.REAL_TYPE) &amp;&amp;
   534→		!p.curTokenIs(lexer.REAL32_TYPE) &amp;&amp; !p.curTokenIs(lexer.REAL64_TYPE) {
   535→		p.addError(fmt.Sprintf(&quot;expected type after array size, got %s&quot;, p.curToken.Type))
   536→		return nil
   537→	}
   538→	decl.Type = p.curToken.Literal
   539→
   540→	// Parse variable names
   541→	for {
   542→		if !p.expectPeek(lexer.IDENT) {
   543→			return nil
   544→		}
   545→		decl.Names = append(decl.Names, p.curToken.Literal)
   546→
   547→		if p.peekTokenIs(lexer.COMMA) {
   548→			p.nextToken() // consume comma
   549→		} else {
   550→			break
   551→		}
   552→	}
   553→
   554→	if !p.expectPeek(lexer.COLON) {
   555→		return nil
   556→	}
   557→
   558→	return decl
   559→}
   560→
   561→// parseSliceAssignment parses [arr FROM start FOR length] := value
   562→// Called from parseArrayDecl when FROM is detected after the array expression.
   563→// lbracketToken is the [ token, arrayExpr is the already-parsed array expression.
   564→func (p *Parser) parseSliceAssignment(lbracketToken lexer.Token, arrayExpr ast.Expression) ast.Statement {
   565→	p.nextToken() // consume FROM
   566→	p.nextToken() // move to start expression
   567→	startExpr := p.parseExpression(LOWEST)
   568→
   569→	if !p.expectPeek(lexer.FOR) {
   570→		return nil
   571→	}
   572→	p.nextToken() // move to length expression
   573→	lengthExpr := p.parseExpression(LOWEST)
   574→
   575→	if !p.expectPeek(lexer.RBRACKET) {
   576→		return nil
   577→	}
   578→
   579→	if !p.expectPeek(lexer.ASSIGN) {
   580→		return nil
   581→	}
   582→
   583→	assignToken := p.curToken
   584→	p.nextToken() // move past :=
   585→
   586→	value := p.parseExpression(LOWEST)
   587→
   588→	return &amp;ast.Assignment{
   589→		Token: assignToken,
   590→		SliceTarget: &amp;ast.SliceExpr{
   591→			Token:  lbracketToken,
   592→			Array:  arrayExpr,
   593→			Start:  startExpr,
   594→			Length: lengthExpr,
   595→		},
   596→		Value: value,
   597→	}
   598→}
   599→
   600→func (p *Parser) parseIndexedOperation() ast.Statement {
   601→	name := p.curToken.Literal
   602→
   603→	p.nextToken() // move to [
   604→	p.nextToken() // move past [
   605→	index := p.parseExpression(LOWEST)
   606→
   607→	// Expect ]
   608→	if !p.expectPeek(lexer.RBRACKET) {
   609→		return nil
   610→	}
   611→
   612→	// Check what follows ]
   613→	if p.peekTokenIs(lexer.COMMA) {
   614→		// Multi-assignment starting with indexed target: name[index], ... := ...
   615→		firstTarget := ast.MultiAssignTarget{Name: name, Index: index}
   616→		return p.parseMultiAssignmentFrom(firstTarget)
   617→	}
   618→	if p.peekTokenIs(lexer.ASSIGN) {
   619→		// Indexed assignment: name[index] := value
   620→		p.nextToken() // move to :=
   621→		stmt := &amp;ast.Assignment{
   622→			Name:  name,
   623→			Token: p.curToken,
   624→			Index: index,
   625→		}
   626→		p.nextToken() // move past :=
   627→		stmt.Value = p.parseExpression(LOWEST)
   628→		return stmt
   629→	}
   630→
   631→	if p.peekTokenIs(lexer.SEND) {
   632→		// Indexed channel send: cs[i] ! value
   633→		p.nextToken() // move to !
   634→		sendToken := p.curToken
   635→		p.nextToken() // move past !
   636→
   637→		stmt := &amp;ast.Send{
   638→			Token:        sendToken,
   639→			Channel:      name,
   640→			ChannelIndex: index,
   641→		}
   642→
   643→		// Check if this is a variant send: first token is an identifier that is a variant tag
   644→		if p.curTokenIs(lexer.IDENT) &amp;&amp; p.peekTokenIs(lexer.SEMICOLON) {
   645→			possibleTag := p.curToken.Literal
   646→			if p.isVariantTag(possibleTag) {
   647→				stmt.VariantTag = possibleTag
   648→				p.nextToken() // move to ;
   649→				for p.curTokenIs(lexer.SEMICOLON) {
   650→					p.nextToken() // move past ;
   651→					val := p.parseExpression(LOWEST)
   652→					stmt.Values = append(stmt.Values, val)
   653→				}
   654→				return stmt
   655→			}
   656→		}
   657→
   658→		stmt.Value = p.parseExpression(LOWEST)
   659→
   660→		// Check for sequential send
   661→		for p.peekTokenIs(lexer.SEMICOLON) {
   662→			p.nextToken() // move to ;
   663→			p.nextToken() // move past ;
   664→			val := p.parseExpression(LOWEST)
   665→			stmt.Values = append(stmt.Values, val)
   666→		}
   667→
   668→		return stmt
   669→	}
   670→
   671→	if p.peekTokenIs(lexer.RECEIVE) {
   672→		// Indexed channel receive: cs[i] ? x or cs[i] ? CASE ...
   673→		p.nextToken() // move to ?
   674→		recvToken := p.curToken
   675→
   676→		// Check for variant receive: cs[i] ? CASE
   677→		if p.peekTokenIs(lexer.CASE) {
   678→			p.nextToken() // move to CASE
   679→			return p.parseVariantReceiveWithIndex(name, index, recvToken)
   680→		}
   681→
   682→		stmt := &amp;ast.Receive{
   683→			Token:        recvToken,
   684→			Channel:      name,
   685→			ChannelIndex: index,
   686→		}
   687→
   688→		if !p.expectPeek(lexer.IDENT) {
   689→			return nil
   690→		}
   691→		stmt.Variable = p.curToken.Literal
   692→
   693→		// Check for sequential receive
   694→		for p.peekTokenIs(lexer.SEMICOLON) {
   695→			p.nextToken() // move to ;
   696→			if !p.expectPeek(lexer.IDENT) {
   697→				return nil
   698→			}
   699→			stmt.Variables = append(stmt.Variables, p.curToken.Literal)
   700→		}
   701→
   702→		return stmt
   703→	}
   704→
   705→	// Default: treat as indexed assignment (shouldn&#x27;t reach here normally)
   706→	p.addError(fmt.Sprintf(&quot;expected :=, !, or ? after %s[...], got %s&quot;, name, p.peekToken.Type))
   707→	return nil
   708→}
   709→
   710→func (p *Parser) parseIndexExpression(left ast.Expression) *ast.IndexExpr {
   711→	expr := &amp;ast.IndexExpr{
   712→		Token: p.curToken,
   713→		Left:  left,
   714→	}
   715→
   716→	p.nextToken() // move past [
   717→	expr.Index = p.parseExpression(LOWEST)
   718→
   719→	if !p.expectPeek(lexer.RBRACKET) {
   720→		return nil
   721→	}
   722→
   723→	return expr
   724→}
   725→
   726→func (p *Parser) parseChanDecl() *ast.ChanDecl {
   727→	decl := &amp;ast.ChanDecl{Token: p.curToken}
   728→
   729→	// Expect OF (optional — CHAN BYTE is shorthand for CHAN OF BYTE)
   730→	if p.peekTokenIs(lexer.OF) {
   731→		p.nextToken() // consume OF
   732→	}
   733→
   734→	// Expect type (INT, BYTE, BOOL, etc.) or protocol name (IDENT)
   735→	p.nextToken()
   736→	if p.curTokenIs(lexer.INT_TYPE) || p.curTokenIs(lexer.BYTE_TYPE) ||
   737→		p.curTokenIs(lexer.BOOL_TYPE) || p.curTokenIs(lexer.REAL_TYPE) ||
   738→		p.curTokenIs(lexer.REAL32_TYPE) || p.curTokenIs(lexer.REAL64_TYPE) {
   739→		decl.ElemType = p.curToken.Literal
   740→	} else if p.curTokenIs(lexer.IDENT) {
   741→		decl.ElemType = p.curToken.Literal
   742→	} else {
   743→		p.addError(fmt.Sprintf(&quot;expected type after CHAN, got %s&quot;, p.curToken.Type))
   744→		return nil
   745→	}
   746→
   747→	// Parse channel names
   748→	for {
   749→		if !p.expectPeek(lexer.IDENT) {
   750→			return nil
   751→		}
   752→		decl.Names = append(decl.Names, p.curToken.Literal)
   753→
   754→		if p.peekTokenIs(lexer.COMMA) {
   755→			p.nextToken() // consume comma
   756→		} else {
   757→			break
   758→		}
   759→	}
   760→
   761→	if !p.expectPeek(lexer.COLON) {
   762→		return nil
   763→	}
   764→
   765→	return decl
   766→}
   767→
   768→func (p *Parser) parseProtocolDecl() *ast.ProtocolDecl {
   769→	decl := &amp;ast.ProtocolDecl{Token: p.curToken}
   770→
   771→	// Expect protocol name
   772→	if !p.expectPeek(lexer.IDENT) {
   773→		return nil
   774→	}
   775→	decl.Name = p.curToken.Literal
   776→
   777→	// Check if this is IS form (simple/sequential) or CASE form (variant)
   778→	if p.peekTokenIs(lexer.NEWLINE) || p.peekTokenIs(lexer.INDENT) {
   779→		// Could be variant: PROTOCOL NAME \n INDENT CASE ...
   780→		// Skip newlines
   781→		for p.peekTokenIs(lexer.NEWLINE) {
   782→			p.nextToken()
   783→		}
   784→
   785→		if p.peekTokenIs(lexer.INDENT) {
   786→			p.nextToken() // consume INDENT
   787→			p.nextToken() // move into block
   788→
   789→			if p.curTokenIs(lexer.CASE) {
   790→				// Variant protocol
   791→				decl.Kind = &quot;variant&quot;
   792→				decl.Variants = p.parseProtocolVariants()
   793→				p.protocolNames[decl.Name] = true
   794→				p.protocolDefs[decl.Name] = decl
   795→				return decl
   796→			}
   797→		}
   798→
   799→		p.addError(&quot;expected IS or CASE in protocol declaration&quot;)
   800→		return nil
   801→	}
   802→
   803→	// IS form: PROTOCOL NAME IS TYPE [; TYPE]*
   804→	if !p.expectPeek(lexer.IS) {
   805→		return nil
   806→	}
   807→
   808→	// Parse type list
   809→	p.nextToken()
   810→	typeName := p.parseProtocolTypeName()
   811→	if typeName == &quot;&quot; {
   812→		return nil
   813→	}
   814→	decl.Types = append(decl.Types, typeName)
   815→
   816→	// Check for sequential: ; TYPE
   817→	for p.peekTokenIs(lexer.SEMICOLON) {
   818→		p.nextToken() // move to ;
   819→		p.nextToken() // move past ;
   820→		typeName = p.parseProtocolTypeName()
   821→		if typeName == &quot;&quot; {
   822→			return nil
   823→		}
   824→		decl.Types = append(decl.Types, typeName)
   825→	}
   826→
   827→	if len(decl.Types) == 1 {
   828→		decl.Kind = &quot;simple&quot;
   829→	} else {
   830→		decl.Kind = &quot;sequential&quot;
   831→	}
   832→
   833→	p.protocolNames[decl.Name] = true
   834→	p.protocolDefs[decl.Name] = decl
   835→	return decl
   836→}
   837→
   838→func (p *Parser) parseProtocolTypeName() string {
   839→	switch p.curToken.Type {
   840→	case lexer.INT_TYPE:
   841→		return &quot;INT&quot;
   842→	case lexer.BYTE_TYPE:
   843→		return &quot;BYTE&quot;
   844→	case lexer.BOOL_TYPE:
   845→		return &quot;BOOL&quot;
   846→	case lexer.REAL_TYPE:
   847→		return &quot;REAL&quot;
   848→	case lexer.REAL32_TYPE:
   849→		return &quot;REAL32&quot;
   850→	case lexer.REAL64_TYPE:
   851→		return &quot;REAL64&quot;
   852→	case lexer.IDENT:
   853→		return p.curToken.Literal
   854→	default:
   855→		p.addError(fmt.Sprintf(&quot;expected type name in protocol, got %s&quot;, p.curToken.Type))
   856→		return &quot;&quot;
   857→	}
   858→}
   859→
   860→func (p *Parser) parseProtocolVariants() []ast.ProtocolVariant {
   861→	var variants []ast.ProtocolVariant
   862→
   863→	// Skip to next line after CASE
   864→	for p.peekTokenIs(lexer.NEWLINE) {
   865→		p.nextToken()
   866→	}
   867→
   868→	// Expect INDENT
   869→	if !p.peekTokenIs(lexer.INDENT) {
   870→		p.addError(&quot;expected indented block after CASE in protocol&quot;)
   871→		return variants
   872→	}
   873→	p.nextToken() // consume INDENT
   874→	startLevel := p.indentLevel
   875→	p.nextToken() // move into block
   876→
   877→	for !p.curTokenIs(lexer.EOF) {
   878→		// Skip newlines
   879→		for p.curTokenIs(lexer.NEWLINE) {
   880→			p.nextToken()
   881→		}
   882→
   883→		// Handle DEDENT tokens
   884→		for p.curTokenIs(lexer.DEDENT) {
   885→			if p.indentLevel &lt; startLevel {
   886→				return variants
   887→			}
   888→			p.nextToken()
   889→		}
   890→
   891→		// Skip any more newlines after DEDENT
   892→		for p.curTokenIs(lexer.NEWLINE) {
   893→			p.nextToken()
   894→		}
   895→
   896→		if p.curTokenIs(lexer.EOF) {
   897→			break
   898→		}
   899→
   900→		if p.indentLevel &lt; startLevel {
   901→			break
   902→		}
   903→
   904→		// Parse variant: tag [; TYPE]*
   905→		if !p.curTokenIs(lexer.IDENT) {
   906→			p.addError(fmt.Sprintf(&quot;expected variant tag name, got %s&quot;, p.curToken.Type))
   907→			return variants
   908→		}
   909→
   910→		v := ast.ProtocolVariant{
   911→			Tag: p.curToken.Literal,
   912→		}
   913→
   914→		// Parse optional types after semicolons
   915→		for p.peekTokenIs(lexer.SEMICOLON) {
   916→			p.nextToken() // move to ;
   917→			p.nextToken() // move past ;
   918→			typeName := p.parseProtocolTypeName()
   919→			if typeName == &quot;&quot; {
   920→				return variants
   921→			}
   922→			v.Types = append(v.Types, typeName)
   923→		}
   924→
   925→		variants = append(variants, v)
   926→
   927→		// Advance past newline if needed
   928→		if !p.curTokenIs(lexer.NEWLINE) &amp;&amp; !p.curTokenIs(lexer.DEDENT) &amp;&amp; !p.curTokenIs(lexer.EOF) {
   929→			p.nextToken()
   930→		}
   931→	}
   932→
   933→	return variants
   934→}
   935→
   936→func (p *Parser) parseRecordDecl() *ast.RecordDecl {
   937→	decl := &amp;ast.RecordDecl{Token: p.curToken}
   938→
   939→	// Expect record name
   940→	if !p.expectPeek(lexer.IDENT) {
   941→		return nil
   942→	}
   943→	decl.Name = p.curToken.Literal
   944→
   945→	// Skip newlines
   946→	for p.peekTokenIs(lexer.NEWLINE) {
   947→		p.nextToken()
   948→	}
   949→
   950→	// Expect INDENT for field block
   951→	if !p.peekTokenIs(lexer.INDENT) {
   952→		p.addError(&quot;expected indented block after RECORD declaration&quot;)
   953→		return nil
   954→	}
   955→	p.nextToken() // consume INDENT
   956→	startLevel := p.indentLevel
   957→	p.nextToken() // move into block
   958→
   959→	// Parse field declarations: TYPE name[, name]*:
   960→	for !p.curTokenIs(lexer.EOF) {
   961→		// Skip newlines
   962→		for p.curTokenIs(lexer.NEWLINE) {
   963→			p.nextToken()
   964→		}
   965→
   966→		// Handle DEDENT tokens
   967→		for p.curTokenIs(lexer.DEDENT) {
   968→			if p.indentLevel &lt; startLevel {
   969→				p.recordNames[decl.Name] = true
   970→				p.recordDefs[decl.Name] = decl
   971→				return decl
   972→			}
   973→			p.nextToken()
   974→		}
   975→
   976→		// Skip any more newlines after DEDENT
   977→		for p.curTokenIs(lexer.NEWLINE) {
   978→			p.nextToken()
   979→		}
   980→
   981→		if p.curTokenIs(lexer.EOF) {
   982→			break
   983→		}
   984→
   985→		if p.indentLevel &lt; startLevel {
   986→			break
   987→		}
   988→
   989→		// Expect a type keyword (INT, BYTE, BOOL, REAL, REAL32, REAL64)
   990→		if !p.curTokenIs(lexer.INT_TYPE) &amp;&amp; !p.curTokenIs(lexer.BYTE_TYPE) &amp;&amp;
   991→			!p.curTokenIs(lexer.BOOL_TYPE) &amp;&amp; !p.curTokenIs(lexer.REAL_TYPE) &amp;&amp;
   992→			!p.curTokenIs(lexer.REAL32_TYPE) &amp;&amp; !p.curTokenIs(lexer.REAL64_TYPE) {
   993→			p.addError(fmt.Sprintf(&quot;expected type in record field, got %s&quot;, p.curToken.Type))
   994→			return nil
   995→		}
   996→		fieldType := p.curToken.Literal
   997→
   998→		// Parse field names (comma-separated)
   999→		for {
  1000→			if !p.expectPeek(lexer.IDENT) {
  1001→				return nil
  1002→			}
  1003→			decl.Fields = append(decl.Fields, ast.RecordField{
  1004→				Type: fieldType,
  1005→				Name: p.curToken.Literal,
  1006→			})
  1007→
  1008→			if p.peekTokenIs(lexer.COMMA) {
  1009→				p.nextToken() // consume comma
  1010→			} else {
  1011→				break
  1012→			}
  1013→		}
  1014→
  1015→		// Expect colon
  1016→		if !p.expectPeek(lexer.COLON) {
  1017→			return nil
  1018→		}
  1019→
  1020→		// Advance past newline if needed
  1021→		if !p.curTokenIs(lexer.NEWLINE) &amp;&amp; !p.curTokenIs(lexer.DEDENT) &amp;&amp; !p.curTokenIs(lexer.EOF) {
  1022→			p.nextToken()
  1023→		}
  1024→	}
  1025→
  1026→	p.recordNames[decl.Name] = true
  1027→	p.recordDefs[decl.Name] = decl
  1028→	return decl
  1029→}
  1030→
  1031→func (p *Parser) parseRecordVarDecl() *ast.VarDecl {
  1032→	decl := &amp;ast.VarDecl{
  1033→		Token: p.curToken,
  1034→		Type:  p.curToken.Literal,
  1035→	}
  1036→
  1037→	// Parse variable names
  1038→	for {
  1039→		if !p.expectPeek(lexer.IDENT) {
  1040→			return nil
  1041→		}
  1042→		decl.Names = append(decl.Names, p.curToken.Literal)
  1043→
  1044→		if p.peekTokenIs(lexer.COMMA) {
  1045→			p.nextToken() // consume comma
  1046→		} else {
  1047→			break
  1048→		}
  1049→	}
  1050→
  1051→	if !p.expectPeek(lexer.COLON) {
  1052→		return nil
  1053→	}
  1054→
  1055→	return decl
  1056→}
  1057→
  1058→func (p *Parser) parseTimerDecl() *ast.TimerDecl {
  1059→	decl := &amp;ast.TimerDecl{Token: p.curToken}
  1060→
  1061→	// Parse timer names
  1062→	for {
  1063→		if !p.expectPeek(lexer.IDENT) {
  1064→			return nil
  1065→		}
  1066→		decl.Names = append(decl.Names, p.curToken.Literal)
  1067→		p.timerNames[p.curToken.Literal] = true
  1068→
  1069→		if p.peekTokenIs(lexer.COMMA) {
  1070→			p.nextToken() // consume comma
  1071→		} else {
  1072→			break
  1073→		}
  1074→	}
  1075→
  1076→	if !p.expectPeek(lexer.COLON) {
  1077→		return nil
  1078→	}
  1079→
  1080→	return decl
  1081→}
  1082→
  1083→func (p *Parser) parseTimerRead() *ast.TimerRead {
  1084→	stmt := &amp;ast.TimerRead{
  1085→		Timer: p.curToken.Literal,
  1086→	}
  1087→
  1088→	p.nextToken() // move to ?
  1089→	stmt.Token = p.curToken
  1090→
  1091→	if !p.expectPeek(lexer.IDENT) {
  1092→		return nil
  1093→	}
  1094→	stmt.Variable = p.curToken.Literal
  1095→
  1096→	return stmt
  1097→}
  1098→
  1099→func (p *Parser) parseSend() *ast.Send {
  1100→	stmt := &amp;ast.Send{
  1101→		Channel: p.curToken.Literal,
  1102→	}
  1103→
  1104→	p.nextToken() // move to !
  1105→	stmt.Token = p.curToken
  1106→
  1107→	p.nextToken() // move past !
  1108→
  1109→	// Check if this is a variant send: first token is an identifier that is a variant tag
  1110→	// We detect this by checking if the identifier is followed by SEMICOLON
  1111→	// and the identifier is NOT followed by an operator (i.e., it&#x27;s a bare tag name)
  1112→	if p.curTokenIs(lexer.IDENT) &amp;&amp; p.peekTokenIs(lexer.SEMICOLON) {
  1113→		// Could be variant send (tag ; values) or expression ; values
  1114→		// Check if the identifier is a known protocol variant tag
  1115→		// For simplicity, if IDENT is followed by SEMICOLON and the ident is
  1116→		// not followed by an operator, treat it as a variant tag
  1117→		// We save the ident and check further
  1118→		possibleTag := p.curToken.Literal
  1119→		// Check if this identifier is a protocol variant tag
  1120→		if p.isVariantTag(possibleTag) {
  1121→			stmt.VariantTag = possibleTag
  1122→			p.nextToken() // move to ;
  1123→			// Parse remaining values after the tag
  1124→			for p.curTokenIs(lexer.SEMICOLON) {
  1125→				p.nextToken() // move past ;
  1126→				val := p.parseExpression(LOWEST)
  1127→				stmt.Values = append(stmt.Values, val)
  1128→			}
  1129→			return stmt
  1130→		}
  1131→	}
  1132→
  1133→	stmt.Value = p.parseExpression(LOWEST)
  1134→
  1135→	// Check for sequential send: c ! expr ; expr ; ...
  1136→	for p.peekTokenIs(lexer.SEMICOLON) {
  1137→		p.nextToken() // move to ;
  1138→		p.nextToken() // move past ;
  1139→		val := p.parseExpression(LOWEST)
  1140→		stmt.Values = append(stmt.Values, val)
  1141→	}
  1142→
  1143→	return stmt
  1144→}
  1145→
  1146→func (p *Parser) isVariantTag(name string) bool {
  1147→	for _, proto := range p.protocolDefs {
  1148→		if proto.Kind == &quot;variant&quot; {
  1149→			for _, v := range proto.Variants {
  1150→				if v.Tag == name {
  1151→					return true
  1152→				}
  1153→			}
  1154→		}
  1155→	}
  1156→	return false
  1157→}
  1158→
  1159→func (p *Parser) parseReceive() ast.Statement {
  1160→	channel := p.curToken.Literal
  1161→
  1162→	p.nextToken() // move to ?
  1163→	recvToken := p.curToken
  1164→
  1165→	// Check for variant receive: c ? CASE
  1166→	if p.peekTokenIs(lexer.CASE) {
  1167→		p.nextToken() // move to CASE
  1168→		return p.parseVariantReceive(channel, recvToken)
  1169→	}
  1170→
  1171→	stmt := &amp;ast.Receive{
  1172→		Channel: channel,
  1173→		Token:   recvToken,
  1174→	}
  1175→
  1176→	if !p.expectPeek(lexer.IDENT) {
  1177→		return nil
  1178→	}
  1179→	stmt.Variable = p.curToken.Literal
  1180→
  1181→	// Check for sequential receive: c ? x ; y ; z
  1182→	for p.peekTokenIs(lexer.SEMICOLON) {
  1183→		p.nextToken() // move to ;
  1184→		if !p.expectPeek(lexer.IDENT) {
  1185→			return nil
  1186→		}
  1187→		stmt.Variables = append(stmt.Variables, p.curToken.Literal)
  1188→	}
  1189→
  1190→	return stmt
  1191→}
  1192→
  1193→func (p *Parser) parseVariantReceive(channel string, token lexer.Token) *ast.VariantReceive {
  1194→	stmt := &amp;ast.VariantReceive{
  1195→		Token:   token,
  1196→		Channel: channel,
  1197→	}
  1198→
  1199→	// Skip to next line
  1200→	for p.peekTokenIs(lexer.NEWLINE) {
  1201→		p.nextToken()
  1202→	}
  1203→
  1204→	// Expect INDENT
  1205→	if !p.peekTokenIs(lexer.INDENT) {
  1206→		p.addError(&quot;expected indented block after ? CASE&quot;)
  1207→		return stmt
  1208→	}
  1209→	p.nextToken() // consume INDENT
  1210→	startLevel := p.indentLevel
  1211→	p.nextToken() // move into block
  1212→
  1213→	// Parse variant cases (similar to parseCaseStatement pattern)
  1214→	for !p.curTokenIs(lexer.EOF) {
  1215→		// Skip newlines
  1216→		for p.curTokenIs(lexer.NEWLINE) {
  1217→			p.nextToken()
  1218→		}
  1219→
  1220→		// Handle DEDENT tokens
  1221→		for p.curTokenIs(lexer.DEDENT) {
  1222→			if p.indentLevel &lt; startLevel {
  1223→				return stmt
  1224→			}
  1225→			p.nextToken()
  1226→		}
  1227→
  1228→		// Skip any more newlines after DEDENT
  1229→		for p.curTokenIs(lexer.NEWLINE) {
  1230→			p.nextToken()
  1231→		}
  1232→
  1233→		if p.curTokenIs(lexer.EOF) {
  1234→			break
  1235→		}
  1236→
  1237→		if p.indentLevel &lt; startLevel {
  1238→			break
  1239→		}
  1240→
  1241→		// Parse a variant case: tag [; var]* \n INDENT body
  1242→		vc := ast.VariantCase{}
  1243→
  1244→		if !p.curTokenIs(lexer.IDENT) {
  1245→			p.addError(fmt.Sprintf(&quot;expected variant tag name, got %s&quot;, p.curToken.Type))
  1246→			return stmt
  1247→		}
  1248→		vc.Tag = p.curToken.Literal
  1249→
  1250→		// Parse optional variables after semicolons: tag ; x ; y
  1251→		for p.peekTokenIs(lexer.SEMICOLON) {
  1252→			p.nextToken() // move to ;
  1253→			if !p.expectPeek(lexer.IDENT) {
  1254→				return stmt
  1255→			}
  1256→			vc.Variables = append(vc.Variables, p.curToken.Literal)
  1257→		}
  1258→
  1259→		// Skip newlines and expect INDENT for body
  1260→		for p.peekTokenIs(lexer.NEWLINE) {
  1261→			p.nextToken()
  1262→		}
  1263→
  1264→		if p.peekTokenIs(lexer.INDENT) {
  1265→			p.nextToken() // consume INDENT
  1266→			p.nextToken() // move to body
  1267→			vc.Body = p.parseStatement()
  1268→
  1269→			// Advance past the last token of the statement if needed
  1270→			if !p.curTokenIs(lexer.NEWLINE) &amp;&amp; !p.curTokenIs(lexer.DEDENT) &amp;&amp; !p.curTokenIs(lexer.EOF) {
  1271→				p.nextToken()
  1272→			}
  1273→		}
  1274→
  1275→		stmt.Cases = append(stmt.Cases, vc)
  1276→	}
  1277→
  1278→	return stmt
  1279→}
  1280→
  1281→func (p *Parser) parseVariantReceiveWithIndex(channel string, channelIndex ast.Expression, token lexer.Token) *ast.VariantReceive {
  1282→	stmt := &amp;ast.VariantReceive{
  1283→		Token:        token,
  1284→		Channel:      channel,
  1285→		ChannelIndex: channelIndex,
  1286→	}
  1287→
  1288→	// Skip to next line
  1289→	for p.peekTokenIs(lexer.NEWLINE) {
  1290→		p.nextToken()
  1291→	}
  1292→
  1293→	// Expect INDENT
  1294→	if !p.peekTokenIs(lexer.INDENT) {
  1295→		p.addError(&quot;expected indented block after ? CASE&quot;)
  1296→		return stmt
  1297→	}
  1298→	p.nextToken() // consume INDENT
  1299→	startLevel := p.indentLevel
  1300→	p.nextToken() // move into block
  1301→
  1302→	for !p.curTokenIs(lexer.EOF) {
  1303→		for p.curTokenIs(lexer.NEWLINE) {
  1304→			p.nextToken()
  1305→		}
  1306→
  1307→		for p.curTokenIs(lexer.DEDENT) {
  1308→			if p.indentLevel &lt; startLevel {
  1309→				return stmt
  1310→			}
  1311→			p.nextToken()
  1312→		}
  1313→
  1314→		for p.curTokenIs(lexer.NEWLINE) {
  1315→			p.nextToken()
  1316→		}
  1317→
  1318→		if p.curTokenIs(lexer.EOF) {
  1319→			break
  1320→		}
  1321→
  1322→		if p.indentLevel &lt; startLevel {
  1323→			break
  1324→		}
  1325→
  1326→		vc := ast.VariantCase{}
  1327→
  1328→		if !p.curTokenIs(lexer.IDENT) {
  1329→			p.addError(fmt.Sprintf(&quot;expected variant tag name, got %s&quot;, p.curToken.Type))
  1330→			return stmt
  1331→		}
  1332→		vc.Tag = p.curToken.Literal
  1333→
  1334→		for p.peekTokenIs(lexer.SEMICOLON) {
  1335→			p.nextToken() // move to ;
  1336→			if !p.expectPeek(lexer.IDENT) {
  1337→				return stmt
  1338→			}
  1339→			vc.Variables = append(vc.Variables, p.curToken.Literal)
  1340→		}
  1341→
  1342→		for p.peekTokenIs(lexer.NEWLINE) {
  1343→			p.nextToken()
  1344→		}
  1345→
  1346→		if p.peekTokenIs(lexer.INDENT) {
  1347→			p.nextToken() // consume INDENT
  1348→			p.nextToken() // move to body
  1349→			vc.Body = p.parseStatement()
  1350→
  1351→			if !p.curTokenIs(lexer.NEWLINE) &amp;&amp; !p.curTokenIs(lexer.DEDENT) &amp;&amp; !p.curTokenIs(lexer.EOF) {
  1352→				p.nextToken()
  1353→			}
  1354→		}
  1355→
  1356→		stmt.Cases = append(stmt.Cases, vc)
  1357→	}
  1358→
  1359→	return stmt
  1360→}
  1361→
  1362→func (p *Parser) parseSeqBlock() *ast.SeqBlock {
  1363→	block := &amp;ast.SeqBlock{Token: p.curToken}
  1364→
  1365→	// Check for replicator: SEQ i = start FOR count
  1366→	if p.peekTokenIs(lexer.IDENT) {
  1367→		// Save position to check if it&#x27;s a replicator
  1368→		p.nextToken() // move to identifier
  1369→		if p.peekTokenIs(lexer.EQ) {
  1370→			// This is a replicator
  1371→			block.Replicator = p.parseReplicator()
  1372→		} else {
  1373→			// Not a replicator, this shouldn&#x27;t happen in valid Occam
  1374→			// (SEQ followed by identifier at same indentation level)
  1375→			p.addError(&quot;unexpected identifier after SEQ&quot;)
  1376→			return block
  1377→		}
  1378→	}
  1379→
  1380→	// Skip to next line
  1381→	for p.peekTokenIs(lexer.NEWLINE) {
  1382→		p.nextToken()
  1383→	}
  1384→
  1385→	// Expect INDENT
  1386→	if !p.peekTokenIs(lexer.INDENT) {
  1387→		p.addError(&quot;expected indented block after SEQ&quot;)
  1388→		return block
  1389→	}
  1390→	p.nextToken() // consume INDENT
  1391→
  1392→	block.Statements = p.parseBlockStatements()
  1393→
  1394→	return block
  1395→}
  1396→
  1397→func (p *Parser) parseParBlock() *ast.ParBlock {
  1398→	block := &amp;ast.ParBlock{Token: p.curToken}
  1399→
  1400→	// Check for replicator: PAR i = start FOR count
  1401→	if p.peekTokenIs(lexer.IDENT) {
  1402→		// Save position to check if it&#x27;s a replicator
  1403→		p.nextToken() // move to identifier
  1404→		if p.peekTokenIs(lexer.EQ) {
  1405→			// This is a replicator
  1406→			block.Replicator = p.parseReplicator()
  1407→		} else {
  1408→			// Not a replicator, this shouldn&#x27;t happen in valid Occam
  1409→			// (PAR followed by identifier at same indentation level)
  1410→			p.addError(&quot;unexpected identifier after PAR&quot;)
  1411→			return block
  1412→		}
  1413→	}
  1414→
  1415→	// Skip to next line
  1416→	for p.peekTokenIs(lexer.NEWLINE) {
  1417→		p.nextToken()
  1418→	}
  1419→
  1420→	// Expect INDENT
  1421→	if !p.peekTokenIs(lexer.INDENT) {
  1422→		p.addError(&quot;expected indented block after PAR&quot;)
  1423→		return block
  1424→	}
  1425→	p.nextToken() // consume INDENT
  1426→
  1427→	block.Statements = p.parseBlockStatements()
  1428→
  1429→	return block
  1430→}
  1431→
  1432→// parseReplicator parses: variable = start FOR count [STEP step]
  1433→// Assumes the variable identifier has already been consumed and is in curToken
  1434→func (p *Parser) parseReplicator() *ast.Replicator {
  1435→	rep := &amp;ast.Replicator{
  1436→		Variable: p.curToken.Literal,
  1437→	}
  1438→
  1439→	// Expect =
  1440→	if !p.expectPeek(lexer.EQ) {
  1441→		return nil
  1442→	}
  1443→
  1444→	// Parse start expression
  1445→	p.nextToken()
  1446→	rep.Start = p.parseExpression(LOWEST)
  1447→
  1448→	// Expect FOR
  1449→	if !p.expectPeek(lexer.FOR) {
  1450→		return nil
  1451→	}
  1452→
  1453→	// Parse count expression
  1454→	p.nextToken()
  1455→	rep.Count = p.parseExpression(LOWEST)
  1456→
  1457→	// Optional STEP
  1458→	if p.peekTokenIs(lexer.STEP) {
  1459→		p.nextToken() // consume STEP
  1460→		p.nextToken() // move to step expression
  1461→		rep.Step = p.parseExpression(LOWEST)
  1462→	}
  1463→
  1464→	return rep
  1465→}
  1466→
  1467→func (p *Parser) parseAltBlock() *ast.AltBlock {
  1468→	block := &amp;ast.AltBlock{Token: p.curToken}
  1469→
  1470→	// Skip to next line
  1471→	for p.peekTokenIs(lexer.NEWLINE) {
  1472→		p.nextToken()
  1473→	}
  1474→
  1475→	// Expect INDENT
  1476→	if !p.peekTokenIs(lexer.INDENT) {
  1477→		p.addError(&quot;expected indented block after ALT&quot;)
  1478→		return block
  1479→	}
  1480→	p.nextToken() // consume INDENT
  1481→
  1482→	block.Cases = p.parseAltCases()
  1483→
  1484→	return block
  1485→}
  1486→
  1487→func (p *Parser) parseAltCases() []ast.AltCase {
  1488→	var cases []ast.AltCase
  1489→	startLevel := p.indentLevel
  1490→
  1491→	p.nextToken() // move past INDENT
  1492→
  1493→	for !p.curTokenIs(lexer.EOF) {
  1494→		// Skip newlines
  1495→		for p.curTokenIs(lexer.NEWLINE) {
  1496→			p.nextToken()
  1497→		}
  1498→
  1499→		// Handle DEDENT tokens
  1500→		for p.curTokenIs(lexer.DEDENT) {
  1501→			if p.indentLevel &lt; startLevel {
  1502→				return cases
  1503→			}
  1504→			p.nextToken()
  1505→		}
  1506→
  1507→		// Skip any more newlines after DEDENT
  1508→		for p.curTokenIs(lexer.NEWLINE) {
  1509→			p.nextToken()
  1510→		}
  1511→
  1512→		if p.curTokenIs(lexer.EOF) {
  1513→			break
  1514→		}
  1515→
  1516→		if p.indentLevel &lt; startLevel {
  1517→			break
  1518→		}
  1519→
  1520→		// Parse an ALT case: [guard &amp;] channel ? var
  1521→		altCase := p.parseAltCase()
  1522→		if altCase != nil {
  1523→			cases = append(cases, *altCase)
  1524→		}
  1525→	}
  1526→
  1527→	return cases
  1528→}
  1529→
  1530→func (p *Parser) parseAltCase() *ast.AltCase {
  1531→	altCase := &amp;ast.AltCase{}
  1532→
  1533→	// Check for guard: expression &amp; channel ? var
  1534→	// For now, we expect: channel ? var (no guard support yet)
  1535→	// or: guard &amp; channel ? var
  1536→
  1537→	// First token should be identifier (channel name or guard start)
  1538→	if !p.curTokenIs(lexer.IDENT) &amp;&amp; !p.curTokenIs(lexer.TRUE) &amp;&amp; !p.curTokenIs(lexer.FALSE) {
  1539→		p.addError(fmt.Sprintf(&quot;expected channel name or guard in ALT case, got %s&quot;, p.curToken.Type))
  1540→		return nil
  1541→	}
  1542→
  1543→	// Look ahead to determine if this is a guard or channel
  1544→	// If next token is &amp; then we have a guard
  1545→	// If next token is ? then it&#x27;s a channel/timer receive
  1546→	if p.peekTokenIs(lexer.RECEIVE) {
  1547→		name := p.curToken.Literal
  1548→		if p.timerNames[name] {
  1549→			// Timer case: tim ? AFTER deadline
  1550→			altCase.IsTimer = true
  1551→			altCase.Timer = name
  1552→			p.nextToken() // move to ?
  1553→			if !p.expectPeek(lexer.AFTER) {
  1554→				return nil
  1555→			}
  1556→			p.nextToken() // move past AFTER
  1557→			altCase.Deadline = p.parseExpression(LOWEST)
  1558→		} else {
  1559→			// Simple case: channel ? var
  1560→			altCase.Channel = name
  1561→			p.nextToken() // move to ?
  1562→			if !p.expectPeek(lexer.IDENT) {
  1563→				return nil
  1564→			}
  1565→			altCase.Variable = p.curToken.Literal
  1566→		}
  1567→	} else if p.peekTokenIs(lexer.LBRACKET) {
  1568→		// Indexed channel case: cs[i] ? var
  1569→		name := p.curToken.Literal
  1570→		altCase.Channel = name
  1571→		p.nextToken() // move to [
  1572→		p.nextToken() // move past [
  1573→		altCase.ChannelIndex = p.parseExpression(LOWEST)
  1574→		if !p.expectPeek(lexer.RBRACKET) {
  1575→			return nil
  1576→		}
  1577→		if !p.expectPeek(lexer.RECEIVE) {
  1578→			return nil
  1579→		}
  1580→		if !p.expectPeek(lexer.IDENT) {
  1581→			return nil
  1582→		}
  1583→		altCase.Variable = p.curToken.Literal
  1584→	} else {
  1585→		// Could be a guard followed by &amp; channel ? var
  1586→		// For simplicity, parse expression until we hit &amp;
  1587→		// For now, only support simple TRUE/FALSE or identifier guards
  1588→		guard := p.parseExpression(LOWEST)
  1589→		altCase.Guard = guard
  1590→
  1591→		// Expect &amp;
  1592→		if !p.peekTokenIs(lexer.AMPERSAND) {
  1593→			p.addError(&quot;expected &amp; after guard in ALT case&quot;)
  1594→			return nil
  1595→		}
  1596→		p.nextToken() // move to &amp;
  1597→		p.nextToken() // move past &amp;
  1598→
  1599→		// Now expect channel ? var or channel[index] ? var
  1600→		if !p.curTokenIs(lexer.IDENT) {
  1601→			p.addError(fmt.Sprintf(&quot;expected channel name after guard, got %s&quot;, p.curToken.Type))
  1602→			return nil
  1603→		}
  1604→		altCase.Channel = p.curToken.Literal
  1605→
  1606→		if p.peekTokenIs(lexer.LBRACKET) {
  1607→			// Indexed channel with guard: guard &amp; cs[i] ? var
  1608→			p.nextToken() // move to [
  1609→			p.nextToken() // move past [
  1610→			altCase.ChannelIndex = p.parseExpression(LOWEST)
  1611→			if !p.expectPeek(lexer.RBRACKET) {
  1612→				return nil
  1613→			}
  1614→		}
  1615→
  1616→		if !p.expectPeek(lexer.RECEIVE) {
  1617→			return nil
  1618→		}
  1619→		if !p.expectPeek(lexer.IDENT) {
  1620→			return nil
  1621→		}
  1622→		altCase.Variable = p.curToken.Literal
  1623→	}
  1624→
  1625→	// Skip to next line for the body
  1626→	for p.peekTokenIs(lexer.NEWLINE) {
  1627→		p.nextToken()
  1628→	}
  1629→
  1630→	// Expect INDENT for body
  1631→	if !p.peekTokenIs(lexer.INDENT) {
  1632→		p.addError(&quot;expected indented body after ALT case&quot;)
  1633→		return altCase
  1634→	}
  1635→	p.nextToken() // consume INDENT
  1636→	p.nextToken() // move into body
  1637→
  1638→	// Parse the body (first statement)
  1639→	altCase.Body = p.parseStatement()
  1640→
  1641→	// Skip to end of body block
  1642→	for !p.curTokenIs(lexer.DEDENT) &amp;&amp; !p.curTokenIs(lexer.EOF) {
  1643→		p.nextToken()
  1644→	}
  1645→
  1646→	return altCase
  1647→}
  1648→
  1649→func (p *Parser) parseBlockStatements() []ast.Statement {
  1650→	var statements []ast.Statement
  1651→	startLevel := p.indentLevel
  1652→
  1653→	p.nextToken() // move past INDENT
  1654→
  1655→	for !p.curTokenIs(lexer.EOF) {
  1656→		// Skip newlines
  1657→		for p.curTokenIs(lexer.NEWLINE) {
  1658→			p.nextToken()
  1659→		}
  1660→
  1661→		// Handle DEDENT tokens
  1662→		// If we&#x27;re at a DEDENT and indentLevel has dropped below startLevel,
  1663→		// this DEDENT ends our block - stop parsing
  1664→		// If indentLevel &gt;= startLevel, this DEDENT is from a nested block - skip it
  1665→		for p.curTokenIs(lexer.DEDENT) {
  1666→			if p.indentLevel &lt; startLevel {
  1667→				return statements
  1668→			}
  1669→			p.nextToken() // skip nested block&#x27;s DEDENT
  1670→		}
  1671→
  1672→		// Skip any more newlines after DEDENT
  1673→		for p.curTokenIs(lexer.NEWLINE) {
  1674→			p.nextToken()
  1675→		}
  1676→
  1677→		if p.curTokenIs(lexer.EOF) {
  1678→			break
  1679→		}
  1680→
  1681→		// Double-check we haven&#x27;t gone below our level
  1682→		if p.indentLevel &lt; startLevel {
  1683→			break
  1684→		}
  1685→
  1686→		stmt := p.parseStatement()
  1687→		if stmt != nil {
  1688→			statements = append(statements, stmt)
  1689→		}
  1690→
  1691→		// After parsing a statement, we need to advance.
  1692→		// But if we&#x27;re already at NEWLINE/DEDENT/EOF, the next iteration will handle it.
  1693→		// Only advance if we&#x27;re still on the last token of the statement.
  1694→		if !p.curTokenIs(lexer.NEWLINE) &amp;&amp; !p.curTokenIs(lexer.DEDENT) &amp;&amp; !p.curTokenIs(lexer.EOF) {
  1695→			p.nextToken()
  1696→		}
  1697→	}
  1698→
  1699→	return statements
  1700→}
  1701→
  1702→func (p *Parser) parseProcDecl() *ast.ProcDecl {
  1703→	proc := &amp;ast.ProcDecl{Token: p.curToken}
  1704→
  1705→	if !p.expectPeek(lexer.IDENT) {
  1706→		return nil
  1707→	}
  1708→	proc.Name = p.curToken.Literal
  1709→
  1710→	if !p.expectPeek(lexer.LPAREN) {
  1711→		return nil
  1712→	}
  1713→
  1714→	proc.Params = p.parseProcParams()
  1715→
  1716→	if !p.expectPeek(lexer.RPAREN) {
  1717→		return nil
  1718→	}
  1719→
  1720→	// Skip to next line and expect indented body
  1721→	for p.peekTokenIs(lexer.NEWLINE) {
  1722→		p.nextToken()
  1723→	}
  1724→
  1725→	if !p.peekTokenIs(lexer.INDENT) {
  1726→		p.addError(&quot;expected indented body after PROC declaration&quot;)
  1727→		return proc
  1728→	}
  1729→	p.nextToken() // consume INDENT
  1730→
  1731→	// Parse all statements in the body (local declarations + body process)
  1732→	bodyLevel := p.indentLevel
  1733→	p.nextToken()
  1734→
  1735→	for !p.curTokenIs(lexer.EOF) {
  1736→		// Skip newlines
  1737→		for p.curTokenIs(lexer.NEWLINE) {
  1738→			p.nextToken()
  1739→		}
  1740→
  1741→		// Handle DEDENTs
  1742→		for p.curTokenIs(lexer.DEDENT) {
  1743→			if p.indentLevel &lt; bodyLevel {
  1744→				goto procBodyDone
  1745→			}
  1746→			p.nextToken()
  1747→		}
  1748→
  1749→		// Skip more newlines after DEDENT
  1750→		for p.curTokenIs(lexer.NEWLINE) {
  1751→			p.nextToken()
  1752→		}
  1753→
  1754→		if p.curTokenIs(lexer.EOF) || p.indentLevel &lt; bodyLevel {
  1755→			break
  1756→		}
  1757→
  1758→		stmt := p.parseStatement()
  1759→		if stmt != nil {
  1760→			proc.Body = append(proc.Body, stmt)
  1761→		}
  1762→
  1763→		if !p.curTokenIs(lexer.NEWLINE) &amp;&amp; !p.curTokenIs(lexer.DEDENT) &amp;&amp; !p.curTokenIs(lexer.EOF) {
  1764→			p.nextToken()
  1765→		}
  1766→	}
  1767→procBodyDone:
  1768→
  1769→	// Optionally consume KRoC-style colon terminator
  1770→	if p.peekTokenIs(lexer.COLON) {
  1771→		p.nextToken()
  1772→	}
  1773→
  1774→	return proc
  1775→}
  1776→
  1777→func (p *Parser) parseProcParams() []ast.ProcParam {
  1778→	var params []ast.ProcParam
  1779→
  1780→	if p.peekTokenIs(lexer.RPAREN) {
  1781→		return params
  1782→	}
  1783→
  1784→	p.nextToken()
  1785→
  1786→	for {
  1787→		param := ast.ProcParam{}
  1788→
  1789→		// Check for VAL keyword
  1790→		if p.curTokenIs(lexer.VAL) {
  1791→			param.IsVal = true
  1792→			p.nextToken()
  1793→		}
  1794→
  1795→		// Check for []CHAN OF &lt;type&gt; or []TYPE (open array parameter)
  1796→		if p.curTokenIs(lexer.LBRACKET) &amp;&amp; p.peekTokenIs(lexer.RBRACKET) {
  1797→			p.nextToken() // consume ]
  1798→			p.nextToken() // move past ]
  1799→			if p.curTokenIs(lexer.CHAN) {
  1800→				// []CHAN OF &lt;type&gt; or []CHAN &lt;type&gt; (channel array parameter)
  1801→				param.IsChan = true
  1802→				param.IsChanArray = true
  1803→				if p.peekTokenIs(lexer.OF) {
  1804→					p.nextToken() // consume OF
  1805→				}
  1806→				p.nextToken() // move to element type
  1807→				if p.curTokenIs(lexer.INT_TYPE) || p.curTokenIs(lexer.BYTE_TYPE) ||
  1808→					p.curTokenIs(lexer.BOOL_TYPE) || p.curTokenIs(lexer.REAL_TYPE) ||
  1809→					p.curTokenIs(lexer.REAL32_TYPE) || p.curTokenIs(lexer.REAL64_TYPE) {
  1810→					param.ChanElemType = p.curToken.Literal
  1811→				} else if p.curTokenIs(lexer.IDENT) {
  1812→					param.ChanElemType = p.curToken.Literal
  1813→				} else {
  1814→					p.addError(fmt.Sprintf(&quot;expected type after []CHAN, got %s&quot;, p.curToken.Type))
  1815→					return params
  1816→				}
  1817→				p.nextToken()
  1818→			} else if p.curTokenIs(lexer.INT_TYPE) || p.curTokenIs(lexer.BYTE_TYPE) ||
  1819→				p.curTokenIs(lexer.BOOL_TYPE) || p.curTokenIs(lexer.REAL_TYPE) ||
  1820→				p.curTokenIs(lexer.REAL32_TYPE) || p.curTokenIs(lexer.REAL64_TYPE) {
  1821→				// []TYPE (open array parameter)
  1822→				param.IsOpenArray = true
  1823→				param.Type = p.curToken.Literal
  1824→				p.nextToken()
  1825→			} else if p.curTokenIs(lexer.IDENT) &amp;&amp; p.recordNames[p.curToken.Literal] {
  1826→				// []RECORD (open array of record type)
  1827→				param.IsOpenArray = true
  1828→				param.Type = p.curToken.Literal
  1829→				p.nextToken()
  1830→			} else {
  1831→				p.addError(fmt.Sprintf(&quot;expected type after [], got %s&quot;, p.curToken.Type))
  1832→				return params
  1833→			}
  1834→		} else if p.curTokenIs(lexer.CHAN) {
  1835→			// Check for CHAN OF &lt;type&gt; or CHAN &lt;type&gt;
  1836→			param.IsChan = true
  1837→			if p.peekTokenIs(lexer.OF) {
  1838→				p.nextToken() // consume OF
  1839→			}
  1840→			p.nextToken() // move to element type
  1841→			if p.curTokenIs(lexer.INT_TYPE) || p.curTokenIs(lexer.BYTE_TYPE) ||
  1842→				p.curTokenIs(lexer.BOOL_TYPE) || p.curTokenIs(lexer.REAL_TYPE) ||
  1843→				p.curTokenIs(lexer.REAL32_TYPE) || p.curTokenIs(lexer.REAL64_TYPE) {
  1844→				param.ChanElemType = p.curToken.Literal
  1845→			} else if p.curTokenIs(lexer.IDENT) {
  1846→				param.ChanElemType = p.curToken.Literal
  1847→			} else {
  1848→				p.addError(fmt.Sprintf(&quot;expected type after CHAN, got %s&quot;, p.curToken.Type))
  1849→				return params
  1850→			}
  1851→			p.nextToken()
  1852→		} else if p.curTokenIs(lexer.IDENT) &amp;&amp; p.recordNames[p.curToken.Literal] {
  1853→			// Record type parameter
  1854→			param.Type = p.curToken.Literal
  1855→			p.nextToken()
  1856→		} else {
  1857→			// Expect scalar type
  1858→			if !p.curTokenIs(lexer.INT_TYPE) &amp;&amp; !p.curTokenIs(lexer.BYTE_TYPE) &amp;&amp;
  1859→				!p.curTokenIs(lexer.BOOL_TYPE) &amp;&amp; !p.curTokenIs(lexer.REAL_TYPE) &amp;&amp;
  1860→				!p.curTokenIs(lexer.REAL32_TYPE) &amp;&amp; !p.curTokenIs(lexer.REAL64_TYPE) {
  1861→				p.addError(fmt.Sprintf(&quot;expected type in parameter, got %s&quot;, p.curToken.Type))
  1862→				return params
  1863→			}
  1864→			param.Type = p.curToken.Literal
  1865→			p.nextToken()
  1866→		}
  1867→
  1868→		// Expect identifier
  1869→		if !p.curTokenIs(lexer.IDENT) {
  1870→			p.addError(fmt.Sprintf(&quot;expected parameter name, got %s&quot;, p.curToken.Type))
  1871→			return params
  1872→		}
  1873→		param.Name = p.curToken.Literal
  1874→
  1875→		// Check for channel direction marker (? or !)
  1876→		if (param.IsChan || param.IsChanArray) &amp;&amp; (p.peekTokenIs(lexer.RECEIVE) || p.peekTokenIs(lexer.SEND)) {
  1877→			p.nextToken()
  1878→			param.ChanDir = p.curToken.Literal
  1879→		}
  1880→
  1881→		params = append(params, param)
  1882→
  1883→		if !p.peekTokenIs(lexer.COMMA) {
  1884→			break
  1885→		}
  1886→		p.nextToken() // consume comma
  1887→		p.nextToken() // move to next param
  1888→	}
  1889→
  1890→	return params
  1891→}
  1892→
  1893→func (p *Parser) parseProcCall() *ast.ProcCall {
  1894→	call := &amp;ast.ProcCall{
  1895→		Token: p.curToken,
  1896→		Name:  p.curToken.Literal,
  1897→	}
  1898→
  1899→	if !p.peekTokenIs(lexer.LPAREN) {
  1900→		// No arguments
  1901→		return call
  1902→	}
  1903→
  1904→	p.nextToken() // consume (
  1905→
  1906→	if p.peekTokenIs(lexer.RPAREN) {
  1907→		p.nextToken() // consume )
  1908→		return call
  1909→	}
  1910→
  1911→	p.nextToken() // move to first arg
  1912→	call.Args = append(call.Args, p.parseExpression(LOWEST))
  1913→
  1914→	for p.peekTokenIs(lexer.COMMA) {
  1915→		p.nextToken() // consume comma
  1916→		p.nextToken() // move to next arg
  1917→		call.Args = append(call.Args, p.parseExpression(LOWEST))
  1918→	}
  1919→
  1920→	if !p.expectPeek(lexer.RPAREN) {
  1921→		return nil
  1922→	}
  1923→
  1924→	return call
  1925→}
  1926→
  1927→func (p *Parser) parseFuncDecl() *ast.FuncDecl {
  1928→	fn := &amp;ast.FuncDecl{
  1929→		Token:       p.curToken,
  1930→		ReturnTypes: []string{p.curToken.Literal},
  1931→	}
  1932→
  1933→	// Parse additional return types for multi-result functions: INT, INT FUNCTION
  1934→	for p.peekTokenIs(lexer.COMMA) {
  1935→		p.nextToken() // consume comma
  1936→		p.nextToken() // move to next type
  1937→		fn.ReturnTypes = append(fn.ReturnTypes, p.curToken.Literal)
  1938→	}
  1939→
  1940→	// Consume FUNCTION keyword
  1941→	p.nextToken()
  1942→
  1943→	if !p.expectPeek(lexer.IDENT) {
  1944→		return nil
  1945→	}
  1946→	fn.Name = p.curToken.Literal
  1947→
  1948→	if !p.expectPeek(lexer.LPAREN) {
  1949→		return nil
  1950→	}
  1951→
  1952→	fn.Params = p.parseProcParams()
  1953→
  1954→	if !p.expectPeek(lexer.RPAREN) {
  1955→		return nil
  1956→	}
  1957→
  1958→	// Force all params to IsVal = true (occam FUNCTION params are always VAL)
  1959→	for i := range fn.Params {
  1960→		fn.Params[i].IsVal = true
  1961→	}
  1962→
  1963→	// Skip newlines, expect INDENT
  1964→	for p.peekTokenIs(lexer.NEWLINE) {
  1965→		p.nextToken()
  1966→	}
  1967→
  1968→	if !p.peekTokenIs(lexer.INDENT) {
  1969→		p.addError(&quot;expected indented body after FUNCTION declaration&quot;)
  1970→		return fn
  1971→	}
  1972→	funcLevel := p.indentLevel
  1973→	p.nextToken() // consume INDENT
  1974→	p.nextToken() // move into body
  1975→
  1976→	// IS form: simple expression return
  1977→	if p.curTokenIs(lexer.IS) {
  1978→		p.nextToken() // move past IS
  1979→		fn.ResultExprs = []ast.Expression{p.parseExpression(LOWEST)}
  1980→
  1981→		// Consume remaining tokens and DEDENTs back to function&#x27;s indentation level
  1982→		for !p.curTokenIs(lexer.EOF) {
  1983→			if p.curTokenIs(lexer.DEDENT) &amp;&amp; p.indentLevel &lt;= funcLevel {
  1984→				break
  1985→			}
  1986→			p.nextToken()
  1987→		}
  1988→
  1989→		// Optionally consume KRoC-style colon terminator
  1990→		if p.peekTokenIs(lexer.COLON) {
  1991→			p.nextToken()
  1992→		}
  1993→		return fn
  1994→	}
  1995→
  1996→	// VALOF form: local declarations, then VALOF keyword, then body, then RESULT
  1997→	// Parse local declarations (type keywords before VALOF)
  1998→	for p.curTokenIs(lexer.INT_TYPE) || p.curTokenIs(lexer.BYTE_TYPE) ||
  1999→		p.curTokenIs(lexer.BOOL_TYPE) || p.curTokenIs(lexer.REAL_TYPE) ||
  2000→		p.curTokenIs(lexer.REAL32_TYPE) || p.curTokenIs(lexer.REAL64_TYPE) {
  2001→		stmt := p.parseVarDecl()
  2002→		if stmt != nil {
  2003→			fn.Body = append(fn.Body, stmt)
  2004→		}
  2005→		// Advance past NEWLINE
  2006→		for p.peekTokenIs(lexer.NEWLINE) {
  2007→			p.nextToken()
  2008→		}
  2009→		p.nextToken()
  2010→	}
  2011→
  2012→	// Expect VALOF keyword
  2013→	if !p.curTokenIs(lexer.VALOF) {
  2014→		p.addError(fmt.Sprintf(&quot;expected VALOF or IS in function body, got %s&quot;, p.curToken.Type))
  2015→		return fn
  2016→	}
  2017→
  2018→	// Skip newlines and expect INDENT for VALOF body
  2019→	for p.peekTokenIs(lexer.NEWLINE) {
  2020→		p.nextToken()
  2021→	}
  2022→
  2023→	if !p.peekTokenIs(lexer.INDENT) {
  2024→		p.addError(&quot;expected indented block after VALOF&quot;)
  2025→		return fn
  2026→	}
  2027→	p.nextToken() // consume INDENT
  2028→	p.nextToken() // move into VALOF body
  2029→
  2030→	// Parse the body statement (e.g., SEQ, IF, etc.)
  2031→	bodyStmt := p.parseStatement()
  2032→	if bodyStmt != nil {
  2033→		fn.Body = append(fn.Body, bodyStmt)
  2034→	}
  2035→
  2036→	// Advance past nested DEDENTs/newlines to RESULT
  2037→	for !p.curTokenIs(lexer.RESULT) &amp;&amp; !p.curTokenIs(lexer.EOF) {
  2038→		p.nextToken()
  2039→	}
  2040→
  2041→	// Parse RESULT expression(s) — comma-separated for multi-result functions
  2042→	if p.curTokenIs(lexer.RESULT) {
  2043→		p.nextToken() // move past RESULT
  2044→		fn.ResultExprs = []ast.Expression{p.parseExpression(LOWEST)}
  2045→		for p.peekTokenIs(lexer.COMMA) {
  2046→			p.nextToken() // consume comma
  2047→			p.nextToken() // move to next expression
  2048→			fn.ResultExprs = append(fn.ResultExprs, p.parseExpression(LOWEST))
  2049→		}
  2050→	}
  2051→
  2052→	// Consume remaining tokens and DEDENTs back to function&#x27;s indentation level
  2053→	for !p.curTokenIs(lexer.EOF) {
  2054→		if p.curTokenIs(lexer.DEDENT) &amp;&amp; p.indentLevel &lt;= funcLevel {
  2055→			break
  2056→		}
  2057→		p.nextToken()
  2058→	}
  2059→
  2060→	// Optionally consume KRoC-style colon terminator
  2061→	if p.peekTokenIs(lexer.COLON) {
  2062→		p.nextToken()
  2063→	}
  2064→
  2065→	return fn
  2066→}
  2067→
  2068→// parseByteLiteralValue processes the raw content of a byte literal (between single quotes),
  2069→// handling occam escape sequences (* prefix), and returns the resulting byte value.
  2070→func (p *Parser) parseByteLiteralValue(raw string) (byte, error) {
  2071→	if len(raw) == 0 {
  2072→		return 0, fmt.Errorf(&quot;empty byte literal&quot;)
  2073→	}
  2074→	if raw[0] == &#x27;*&#x27; {
  2075→		if len(raw) != 2 {
  2076→			return 0, fmt.Errorf(&quot;invalid escape sequence in byte literal: &#x27;*%s&#x27;&quot;, raw[1:])
  2077→		}
  2078→		switch raw[1] {
  2079→		case &#x27;n&#x27;:
  2080→			return &#x27;\n&#x27;, nil
  2081→		case &#x27;c&#x27;:
  2082→			return &#x27;\r&#x27;, nil
  2083→		case &#x27;t&#x27;:
  2084→			return &#x27;\t&#x27;, nil
  2085→		case &#x27;s&#x27;:
  2086→			return &#x27; &#x27;, nil
  2087→		case &#x27;*&#x27;:
  2088→			return &#x27;*&#x27;, nil
  2089→		case &#x27;\&#x27;&#x27;:
  2090→			return &#x27;\&#x27;&#x27;, nil
  2091→		case &#x27;&quot;&#x27;:
  2092→			return &#x27;&quot;&#x27;, nil
  2093→		default:
  2094→			return 0, fmt.Errorf(&quot;unknown escape sequence in byte literal: &#x27;*%c&#x27;&quot;, raw[1])
  2095→		}
  2096→	}
  2097→	if len(raw) != 1 {
  2098→		return 0, fmt.Errorf(&quot;byte literal must be a single character, got %q&quot;, raw)
  2099→	}
  2100→	return raw[0], nil
  2101→}
  2102→
  2103→func (p *Parser) parseFuncCallExpr() *ast.FuncCall {
  2104→	call := &amp;ast.FuncCall{
  2105→		Token: p.curToken,
  2106→		Name:  p.curToken.Literal,
  2107→	}
  2108→
  2109→	p.nextToken() // consume (
  2110→
  2111→	if p.peekTokenIs(lexer.RPAREN) {
  2112→		p.nextToken() // consume )
  2113→		return call
  2114→	}
  2115→
  2116→	p.nextToken() // move to first arg
  2117→	call.Args = append(call.Args, p.parseExpression(LOWEST))
  2118→
  2119→	for p.peekTokenIs(lexer.COMMA) {
  2120→		p.nextToken() // consume comma
  2121→		p.nextToken() // move to next arg
  2122→		call.Args = append(call.Args, p.parseExpression(LOWEST))
  2123→	}
  2124→
  2125→	if !p.expectPeek(lexer.RPAREN) {
  2126→		return nil
  2127→	}
  2128→
  2129→	return call
  2130→}
  2131→
  2132→func (p *Parser) parseWhileLoop() *ast.WhileLoop {
  2133→	loop := &amp;ast.WhileLoop{Token: p.curToken}
  2134→
  2135→	p.nextToken()
  2136→	loop.Condition = p.parseExpression(LOWEST)
  2137→
  2138→	// Skip to next line
  2139→	for p.peekTokenIs(lexer.NEWLINE) {
  2140→		p.nextToken()
  2141→	}
  2142→
  2143→	// Expect INDENT
  2144→	if !p.peekTokenIs(lexer.INDENT) {
  2145→		p.addError(&quot;expected indented block after WHILE condition&quot;)
  2146→		return loop
  2147→	}
  2148→	p.nextToken() // consume INDENT
  2149→	p.nextToken() // move to first statement
  2150→
  2151→	loop.Body = p.parseStatement()
  2152→
  2153→	// Consume until DEDENT
  2154→	for !p.curTokenIs(lexer.DEDENT) &amp;&amp; !p.curTokenIs(lexer.EOF) {
  2155→		p.nextToken()
  2156→	}
  2157→
  2158→	return loop
  2159→}
  2160→
  2161→func (p *Parser) parseIfStatement() *ast.IfStatement {
  2162→	stmt := &amp;ast.IfStatement{Token: p.curToken}
  2163→
  2164→	// Check for replicator: IF i = start FOR count
  2165→	if p.peekTokenIs(lexer.IDENT) {
  2166→		p.nextToken() // move to identifier
  2167→		if p.peekTokenIs(lexer.EQ) {
  2168→			stmt.Replicator = p.parseReplicator()
  2169→		} else {
  2170→			p.addError(&quot;unexpected identifier after IF&quot;)
  2171→			return stmt
  2172→		}
  2173→	}
  2174→
  2175→	// Skip to next line
  2176→	for p.peekTokenIs(lexer.NEWLINE) {
  2177→		p.nextToken()
  2178→	}
  2179→
  2180→	// Expect INDENT
  2181→	if !p.peekTokenIs(lexer.INDENT) {
  2182→		p.addError(&quot;expected indented block after IF&quot;)
  2183→		return stmt
  2184→	}
  2185→	p.nextToken() // consume INDENT
  2186→	startLevel := p.indentLevel
  2187→	p.nextToken() // move into block
  2188→
  2189→	// Parse if choices (condition -&gt; body pairs)
  2190→	for !p.curTokenIs(lexer.EOF) {
  2191→		// Skip newlines
  2192→		for p.curTokenIs(lexer.NEWLINE) {
  2193→			p.nextToken()
  2194→		}
  2195→
  2196→		// Handle DEDENT tokens
  2197→		for p.curTokenIs(lexer.DEDENT) {
  2198→			if p.indentLevel &lt; startLevel {
  2199→				return stmt
  2200→			}
  2201→			p.nextToken()
  2202→		}
  2203→
  2204→		// Skip any more newlines after DEDENT
  2205→		for p.curTokenIs(lexer.NEWLINE) {
  2206→			p.nextToken()
  2207→		}
  2208→
  2209→		if p.curTokenIs(lexer.EOF) {
  2210→			break
  2211→		}
  2212→
  2213→		if p.indentLevel &lt; startLevel {
  2214→			break
  2215→		}
  2216→
  2217→		choice := ast.IfChoice{}
  2218→		choice.Condition = p.parseExpression(LOWEST)
  2219→
  2220→		// Skip newlines and expect INDENT for body
  2221→		for p.peekTokenIs(lexer.NEWLINE) {
  2222→			p.nextToken()
  2223→		}
  2224→
  2225→		if p.peekTokenIs(lexer.INDENT) {
  2226→			p.nextToken() // consume INDENT
  2227→			p.nextToken() // move to body
  2228→			choice.Body = p.parseStatement()
  2229→
  2230→			// Advance past the last token of the statement if needed
  2231→			if !p.curTokenIs(lexer.NEWLINE) &amp;&amp; !p.curTokenIs(lexer.DEDENT) &amp;&amp; !p.curTokenIs(lexer.EOF) {
  2232→				p.nextToken()
  2233→			}
  2234→		}
  2235→
  2236→		stmt.Choices = append(stmt.Choices, choice)
  2237→	}
  2238→
  2239→	return stmt
  2240→}
  2241→
  2242→func (p *Parser) parseCaseStatement() *ast.CaseStatement {
  2243→	stmt := &amp;ast.CaseStatement{Token: p.curToken}
  2244→
  2245→	// Parse selector expression on the same line
  2246→	p.nextToken()
  2247→	stmt.Selector = p.parseExpression(LOWEST)
  2248→
  2249→	// Skip to next line
  2250→	for p.peekTokenIs(lexer.NEWLINE) {
  2251→		p.nextToken()
  2252→	}
  2253→
  2254→	// Expect INDENT
  2255→	if !p.peekTokenIs(lexer.INDENT) {
  2256→		p.addError(&quot;expected indented block after CASE&quot;)
  2257→		return stmt
  2258→	}
  2259→	p.nextToken() // consume INDENT
  2260→	startLevel := p.indentLevel
  2261→	p.nextToken() // move into block
  2262→
  2263→	// Parse case choices
  2264→	for !p.curTokenIs(lexer.EOF) {
  2265→		// Skip newlines
  2266→		for p.curTokenIs(lexer.NEWLINE) {
  2267→			p.nextToken()
  2268→		}
  2269→
  2270→		// Handle DEDENT tokens
  2271→		for p.curTokenIs(lexer.DEDENT) {
  2272→			if p.indentLevel &lt; startLevel {
  2273→				return stmt
  2274→			}
  2275→			p.nextToken()
  2276→		}
  2277→
  2278→		// Skip any more newlines after DEDENT
  2279→		for p.curTokenIs(lexer.NEWLINE) {
  2280→			p.nextToken()
  2281→		}
  2282→
  2283→		if p.curTokenIs(lexer.EOF) {
  2284→			break
  2285→		}
  2286→
  2287→		if p.indentLevel &lt; startLevel {
  2288→			break
  2289→		}
  2290→
  2291→		choice := ast.CaseChoice{}
  2292→
  2293→		if p.curTokenIs(lexer.ELSE) {
  2294→			choice.IsElse = true
  2295→		} else {
  2296→			// Parse value expression
  2297→			choice.Values = append(choice.Values, p.parseExpression(LOWEST))
  2298→		}
  2299→
  2300→		// Skip newlines and expect INDENT for body
  2301→		for p.peekTokenIs(lexer.NEWLINE) {
  2302→			p.nextToken()
  2303→		}
  2304→
  2305→		if p.peekTokenIs(lexer.INDENT) {
  2306→			p.nextToken() // consume INDENT
  2307→			p.nextToken() // move to body
  2308→			choice.Body = p.parseStatement()
  2309→
  2310→			// Advance past the last token of the statement if needed
  2311→			if !p.curTokenIs(lexer.NEWLINE) &amp;&amp; !p.curTokenIs(lexer.DEDENT) &amp;&amp; !p.curTokenIs(lexer.EOF) {
  2312→				p.nextToken()
  2313→			}
  2314→		}
  2315→
  2316→		stmt.Choices = append(stmt.Choices, choice)
  2317→	}
  2318→
  2319→	return stmt
  2320→}
  2321→
  2322→// Expression parsing using Pratt parsing
  2323→
  2324→func (p *Parser) parseExpression(precedence int) ast.Expression {
  2325→	var left ast.Expression
  2326→
  2327→	switch p.curToken.Type {
  2328→	case lexer.IDENT:
  2329→		if p.peekTokenIs(lexer.LPAREN) {
  2330→			left = p.parseFuncCallExpr()
  2331→		} else {
  2332→			left = &amp;ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}
  2333→		}
  2334→	case lexer.INT:
  2335→		base := 10
  2336→		literal := p.curToken.Literal
  2337→		if strings.HasPrefix(literal, &quot;0x&quot;) || strings.HasPrefix(literal, &quot;0X&quot;) {
  2338→			base = 16
  2339→			literal = literal[2:]
  2340→		}
  2341→		val, err := strconv.ParseInt(literal, base, 64)
  2342→		if err != nil {
  2343→			p.addError(fmt.Sprintf(&quot;could not parse %q as integer&quot;, p.curToken.Literal))
  2344→			return nil
  2345→		}
  2346→		left = &amp;ast.IntegerLiteral{Token: p.curToken, Value: val}
  2347→	case lexer.TRUE:
  2348→		left = &amp;ast.BooleanLiteral{Token: p.curToken, Value: true}
  2349→	case lexer.FALSE:
  2350→		left = &amp;ast.BooleanLiteral{Token: p.curToken, Value: false}
  2351→	case lexer.STRING:
  2352→		left = &amp;ast.StringLiteral{Token: p.curToken, Value: p.curToken.Literal}
  2353→	case lexer.BYTE_LIT:
  2354→		b, err := p.parseByteLiteralValue(p.curToken.Literal)
  2355→		if err != nil {
  2356→			p.addError(err.Error())
  2357→			return nil
  2358→		}
  2359→		left = &amp;ast.ByteLiteral{Token: p.curToken, Value: b}
  2360→	case lexer.LPAREN:
  2361→		p.nextToken()
  2362→		left = p.parseExpression(LOWEST)
  2363→		if !p.expectPeek(lexer.RPAREN) {
  2364→			return nil
  2365→		}
  2366→	case lexer.MINUS:
  2367→		token := p.curToken
  2368→		p.nextToken()
  2369→		left = &amp;ast.UnaryExpr{
  2370→			Token:    token,
  2371→			Operator: &quot;-&quot;,
  2372→			Right:    p.parseExpression(PREFIX),
  2373→		}
  2374→	case lexer.NOT:
  2375→		token := p.curToken
  2376→		p.nextToken()
  2377→		left = &amp;ast.UnaryExpr{
  2378→			Token:    token,
  2379→			Operator: &quot;NOT&quot;,
  2380→			Right:    p.parseExpression(PREFIX),
  2381→		}
  2382→	case lexer.BITNOT:
  2383→		token := p.curToken
  2384→		p.nextToken()
  2385→		left = &amp;ast.UnaryExpr{
  2386→			Token:    token,
  2387→			Operator: &quot;~&quot;,
  2388→			Right:    p.parseExpression(PREFIX),
  2389→		}
  2390→	case lexer.LBRACKET:
  2391→		// Slice expression: [arr FROM start FOR length]
  2392→		lbracket := p.curToken
  2393→		p.nextToken() // move past [
  2394→		arrayExpr := p.parseExpression(LOWEST)
  2395→		if !p.expectPeek(lexer.FROM) {
  2396→			return nil
  2397→		}
  2398→		p.nextToken() // move past FROM
  2399→		startExpr := p.parseExpression(LOWEST)
  2400→		if !p.expectPeek(lexer.FOR) {
  2401→			return nil
  2402→		}
  2403→		p.nextToken() // move past FOR
  2404→		lengthExpr := p.parseExpression(LOWEST)
  2405→		if !p.expectPeek(lexer.RBRACKET) {
  2406→			return nil
  2407→		}
  2408→		left = &amp;ast.SliceExpr{
  2409→			Token:  lbracket,
  2410→			Array:  arrayExpr,
  2411→			Start:  startExpr,
  2412→			Length: lengthExpr,
  2413→		}
  2414→	case lexer.SIZE_KW:
  2415→		token := p.curToken
  2416→		p.nextToken()
  2417→		left = &amp;ast.SizeExpr{
  2418→			Token: token,
  2419→			Expr:  p.parseExpression(PREFIX),
  2420→		}
  2421→	case lexer.MOSTNEG_KW, lexer.MOSTPOS_KW:
  2422→		token := p.curToken
  2423→		isNeg := token.Type == lexer.MOSTNEG_KW
  2424→		// Expect a type name next
  2425→		if !p.peekTokenIs(lexer.INT_TYPE) &amp;&amp; !p.peekTokenIs(lexer.BYTE_TYPE) &amp;&amp;
  2426→			!p.peekTokenIs(lexer.BOOL_TYPE) &amp;&amp; !p.peekTokenIs(lexer.REAL_TYPE) &amp;&amp;
  2427→			!p.peekTokenIs(lexer.REAL32_TYPE) &amp;&amp; !p.peekTokenIs(lexer.REAL64_TYPE) {
  2428→			p.addError(fmt.Sprintf(&quot;expected type after %s, got %s&quot;, token.Literal, p.peekToken.Type))
  2429→			return nil
  2430→		}
  2431→		p.nextToken()
  2432→		left = &amp;ast.MostExpr{
  2433→			Token:    token,
  2434→			ExprType: p.curToken.Literal,
  2435→			IsNeg:    isNeg,
  2436→		}
  2437→	case lexer.INT_TYPE, lexer.BYTE_TYPE, lexer.BOOL_TYPE, lexer.REAL_TYPE, lexer.REAL32_TYPE, lexer.REAL64_TYPE:
  2438→		token := p.curToken
  2439→		p.nextToken()
  2440→		left = &amp;ast.TypeConversion{
  2441→			Token:      token,
  2442→			TargetType: token.Literal,
  2443→			Expr:       p.parseExpression(PREFIX),
  2444→		}
  2445→	default:
  2446→		p.addError(fmt.Sprintf(&quot;unexpected token in expression: %s&quot;, p.curToken.Type))
  2447→		return nil
  2448→	}
  2449→
  2450→	// Parse infix expressions
  2451→	for !p.peekTokenIs(lexer.NEWLINE) &amp;&amp; !p.peekTokenIs(lexer.EOF) &amp;&amp;
  2452→		precedence &lt; p.peekPrecedence() {
  2453→
  2454→		switch p.peekToken.Type {
  2455→		case lexer.PLUS, lexer.MINUS, lexer.MULTIPLY, lexer.DIVIDE, lexer.MODULO,
  2456→			lexer.PLUS_KW, lexer.MINUS_KW, lexer.TIMES,
  2457→			lexer.EQ, lexer.NEQ, lexer.LT, lexer.GT, lexer.LE, lexer.GE,
  2458→			lexer.AND, lexer.OR, lexer.AFTER,
  2459→			lexer.BITAND, lexer.BITOR, lexer.BITXOR, lexer.LSHIFT, lexer.RSHIFT:
  2460→			p.nextToken()
  2461→			left = p.parseBinaryExpr(left)
  2462→		case lexer.LBRACKET:
  2463→			p.nextToken()
  2464→			left = p.parseIndexExpression(left)
  2465→		default:
  2466→			return left
  2467→		}
  2468→	}
  2469→
  2470→	return left
  2471→}
  2472→
  2473→func (p *Parser) parseBinaryExpr(left ast.Expression) ast.Expression {
  2474→	expr := &amp;ast.BinaryExpr{
  2475→		Token:    p.curToken,
  2476→		Left:     left,
  2477→		Operator: p.curToken.Literal,
  2478→	}
  2479→
  2480→	prec := p.curPrecedence()
  2481→	p.nextToken()
  2482→	expr.Right = p.parseExpression(prec)
  2483→
  2484→	return expr
  2485→}
  2486→</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-05-40-235Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-05-40-235Z" class="timestamp-link"><time datetime="2026-02-19T05:05:40.235Z" data-timestamp="2026-02-19T05:05:40.235Z">2026-02-19T05:05:40.235Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_014dsrWR1SRoBmrYfUutVWKG"><div class="tool-header"><span class="tool-icon">⚙</span> Read</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;file_path&#34;: &#34;/home/david/projects/code-associates/occam2go/codegen/codegen.go&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-05-40-591Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-05-40-591Z" class="timestamp-link"><time datetime="2026-02-19T05:05:40.591Z" data-timestamp="2026-02-19T05:05:40.591Z">2026-02-19T05:05:40.591Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>     1→package codegen
     2→
     3→import (
     4→	&quot;fmt&quot;
     5→	&quot;strings&quot;
     6→
     7→	&quot;github.com/codeassociates/occam2go/ast&quot;
     8→)
     9→
    10→// Generator converts an AST to Go code
    11→type Generator struct {
    12→	indent   int
    13→	builder  strings.Builder
    14→	needSync bool // track if we need sync package import
    15→	needFmt  bool // track if we need fmt package import
    16→	needTime bool // track if we need time package import
    17→	needOs   bool // track if we need os package import
    18→	needMath bool // track if we need math package import
    19→
    20→	// Track procedure signatures for proper pointer handling
    21→	procSigs map[string][]ast.ProcParam
    22→	// Track current procedure&#x27;s reference parameters
    23→	refParams map[string]bool
    24→
    25→	// Protocol support
    26→	protocolDefs  map[string]*ast.ProtocolDecl
    27→	chanProtocols map[string]string // channel name → protocol name
    28→	tmpCounter    int               // for unique temp variable names
    29→
    30→	// Record support
    31→	recordDefs map[string]*ast.RecordDecl
    32→	recordVars map[string]string // variable name → record type name
    33→
    34→	// Nesting level: 0 = package level, &gt;0 = inside a function
    35→	nestingLevel int
    36→}
    37→
    38→// Built-in print procedures
    39→var printBuiltins = map[string]bool{
    40→	&quot;print.int&quot;:     true,
    41→	&quot;print.string&quot;:  true,
    42→	&quot;print.bool&quot;:    true,
    43→	&quot;print.newline&quot;: true,
    44→}
    45→
    46→// New creates a new code generator
    47→func New() *Generator {
    48→	return &amp;Generator{}
    49→}
    50→
    51→// Generate produces Go code from the AST
    52→func (g *Generator) Generate(program *ast.Program) string {
    53→	g.builder.Reset()
    54→	g.needSync = false
    55→	g.needFmt = false
    56→	g.needTime = false
    57→	g.needOs = false
    58→	g.needMath = false
    59→	g.procSigs = make(map[string][]ast.ProcParam)
    60→	g.refParams = make(map[string]bool)
    61→	g.protocolDefs = make(map[string]*ast.ProtocolDecl)
    62→	g.chanProtocols = make(map[string]string)
    63→	g.tmpCounter = 0
    64→	g.recordDefs = make(map[string]*ast.RecordDecl)
    65→	g.recordVars = make(map[string]string)
    66→
    67→	// First pass: collect procedure signatures, protocols, and check for PAR/print
    68→	for _, stmt := range program.Statements {
    69→		if g.containsPar(stmt) {
    70→			g.needSync = true
    71→		}
    72→		if g.containsPrint(stmt) {
    73→			g.needFmt = true
    74→		}
    75→		if g.containsTimer(stmt) {
    76→			g.needTime = true
    77→		}
    78→		if g.containsStop(stmt) {
    79→			g.needOs = true
    80→			g.needFmt = true
    81→		}
    82→		if g.containsMostExpr(stmt) {
    83→			g.needMath = true
    84→		}
    85→		if proc, ok := stmt.(*ast.ProcDecl); ok {
    86→			g.procSigs[proc.Name] = proc.Params
    87→			g.collectNestedProcSigs(proc.Body)
    88→		}
    89→		if fn, ok := stmt.(*ast.FuncDecl); ok {
    90→			g.procSigs[fn.Name] = fn.Params
    91→		}
    92→		if proto, ok := stmt.(*ast.ProtocolDecl); ok {
    93→			g.protocolDefs[proto.Name] = proto
    94→		}
    95→		if rec, ok := stmt.(*ast.RecordDecl); ok {
    96→			g.recordDefs[rec.Name] = rec
    97→		}
    98→		g.collectChanProtocols(stmt)
    99→		g.collectRecordVars(stmt)
   100→	}
   101→
   102→	// Write package declaration
   103→	g.writeLine(&quot;package main&quot;)
   104→	g.writeLine(&quot;&quot;)
   105→
   106→	// Write imports
   107→	if g.needSync || g.needFmt || g.needTime || g.needOs || g.needMath {
   108→		g.writeLine(&quot;import (&quot;)
   109→		g.indent++
   110→		if g.needFmt {
   111→			g.writeLine(`&quot;fmt&quot;`)
   112→		}
   113→		if g.needMath {
   114→			g.writeLine(`&quot;math&quot;`)
   115→		}
   116→		if g.needOs {
   117→			g.writeLine(`&quot;os&quot;`)
   118→		}
   119→		if g.needSync {
   120→			g.writeLine(`&quot;sync&quot;`)
   121→		}
   122→		if g.needTime {
   123→			g.writeLine(`&quot;time&quot;`)
   124→		}
   125→		g.indent--
   126→		g.writeLine(&quot;)&quot;)
   127→		g.writeLine(&quot;&quot;)
   128→	}
   129→
   130→	// Separate protocol, record, procedure declarations from other statements
   131→	var typeDecls []ast.Statement
   132→	var procDecls []ast.Statement
   133→	var mainStatements []ast.Statement
   134→
   135→	for _, stmt := range program.Statements {
   136→		switch stmt.(type) {
   137→		case *ast.ProtocolDecl, *ast.RecordDecl:
   138→			typeDecls = append(typeDecls, stmt)
   139→		case *ast.ProcDecl, *ast.FuncDecl:
   140→			procDecls = append(procDecls, stmt)
   141→		default:
   142→			mainStatements = append(mainStatements, stmt)
   143→		}
   144→	}
   145→
   146→	// Generate type definitions first (at package level)
   147→	for _, stmt := range typeDecls {
   148→		g.generateStatement(stmt)
   149→	}
   150→
   151→	// Generate procedure declarations (at package level)
   152→	for _, stmt := range procDecls {
   153→		g.generateStatement(stmt)
   154→	}
   155→
   156→	// Generate main function with other statements
   157→	if len(mainStatements) &gt; 0 {
   158→		g.writeLine(&quot;func main() {&quot;)
   159→		g.indent++
   160→		g.nestingLevel++
   161→		for _, stmt := range mainStatements {
   162→			g.generateStatement(stmt)
   163→		}
   164→		g.nestingLevel--
   165→		g.indent--
   166→		g.writeLine(&quot;}&quot;)
   167→	}
   168→
   169→	return g.builder.String()
   170→}
   171→
   172→// collectNestedProcSigs recursively collects procedure/function signatures
   173→// from nested declarations inside PROC bodies.
   174→func (g *Generator) collectNestedProcSigs(stmts []ast.Statement) {
   175→	for _, stmt := range stmts {
   176→		if proc, ok := stmt.(*ast.ProcDecl); ok {
   177→			g.procSigs[proc.Name] = proc.Params
   178→			g.collectNestedProcSigs(proc.Body)
   179→		}
   180→		if fn, ok := stmt.(*ast.FuncDecl); ok {
   181→			g.procSigs[fn.Name] = fn.Params
   182→		}
   183→	}
   184→}
   185→
   186→func (g *Generator) containsPar(stmt ast.Statement) bool {
   187→	switch s := stmt.(type) {
   188→	case *ast.ParBlock:
   189→		return true
   190→	case *ast.SeqBlock:
   191→		for _, inner := range s.Statements {
   192→			if g.containsPar(inner) {
   193→				return true
   194→			}
   195→		}
   196→	case *ast.AltBlock:
   197→		for _, c := range s.Cases {
   198→			if c.Body != nil &amp;&amp; g.containsPar(c.Body) {
   199→				return true
   200→			}
   201→		}
   202→	case *ast.ProcDecl:
   203→		for _, inner := range s.Body {
   204→			if g.containsPar(inner) {
   205→				return true
   206→			}
   207→		}
   208→	case *ast.FuncDecl:
   209→		for _, inner := range s.Body {
   210→			if g.containsPar(inner) {
   211→				return true
   212→			}
   213→		}
   214→	case *ast.WhileLoop:
   215→		if s.Body != nil &amp;&amp; g.containsPar(s.Body) {
   216→			return true
   217→		}
   218→	case *ast.IfStatement:
   219→		for _, choice := range s.Choices {
   220→			if choice.Body != nil &amp;&amp; g.containsPar(choice.Body) {
   221→				return true
   222→			}
   223→		}
   224→	case *ast.CaseStatement:
   225→		for _, choice := range s.Choices {
   226→			if choice.Body != nil &amp;&amp; g.containsPar(choice.Body) {
   227→				return true
   228→			}
   229→		}
   230→	case *ast.VariantReceive:
   231→		for _, c := range s.Cases {
   232→			if c.Body != nil &amp;&amp; g.containsPar(c.Body) {
   233→				return true
   234→			}
   235→		}
   236→	}
   237→	return false
   238→}
   239→
   240→func (g *Generator) containsPrint(stmt ast.Statement) bool {
   241→	switch s := stmt.(type) {
   242→	case *ast.ProcCall:
   243→		return printBuiltins[s.Name]
   244→	case *ast.SeqBlock:
   245→		for _, inner := range s.Statements {
   246→			if g.containsPrint(inner) {
   247→				return true
   248→			}
   249→		}
   250→	case *ast.ParBlock:
   251→		for _, inner := range s.Statements {
   252→			if g.containsPrint(inner) {
   253→				return true
   254→			}
   255→		}
   256→	case *ast.AltBlock:
   257→		for _, c := range s.Cases {
   258→			if c.Body != nil &amp;&amp; g.containsPrint(c.Body) {
   259→				return true
   260→			}
   261→		}
   262→	case *ast.ProcDecl:
   263→		for _, inner := range s.Body {
   264→			if g.containsPrint(inner) {
   265→				return true
   266→			}
   267→		}
   268→	case *ast.FuncDecl:
   269→		for _, inner := range s.Body {
   270→			if g.containsPrint(inner) {
   271→				return true
   272→			}
   273→		}
   274→	case *ast.WhileLoop:
   275→		if s.Body != nil &amp;&amp; g.containsPrint(s.Body) {
   276→			return true
   277→		}
   278→	case *ast.IfStatement:
   279→		for _, choice := range s.Choices {
   280→			if choice.Body != nil &amp;&amp; g.containsPrint(choice.Body) {
   281→				return true
   282→			}
   283→		}
   284→	case *ast.CaseStatement:
   285→		for _, choice := range s.Choices {
   286→			if choice.Body != nil &amp;&amp; g.containsPrint(choice.Body) {
   287→				return true
   288→			}
   289→		}
   290→	case *ast.VariantReceive:
   291→		for _, c := range s.Cases {
   292→			if c.Body != nil &amp;&amp; g.containsPrint(c.Body) {
   293→				return true
   294→			}
   295→		}
   296→	}
   297→	return false
   298→}
   299→
   300→func (g *Generator) containsTimer(stmt ast.Statement) bool {
   301→	switch s := stmt.(type) {
   302→	case *ast.TimerDecl, *ast.TimerRead:
   303→		return true
   304→	case *ast.AltBlock:
   305→		for _, c := range s.Cases {
   306→			if c.IsTimer {
   307→				return true
   308→			}
   309→			if c.Body != nil &amp;&amp; g.containsTimer(c.Body) {
   310→				return true
   311→			}
   312→		}
   313→	case *ast.SeqBlock:
   314→		for _, inner := range s.Statements {
   315→			if g.containsTimer(inner) {
   316→				return true
   317→			}
   318→		}
   319→	case *ast.ParBlock:
   320→		for _, inner := range s.Statements {
   321→			if g.containsTimer(inner) {
   322→				return true
   323→			}
   324→		}
   325→	case *ast.ProcDecl:
   326→		for _, inner := range s.Body {
   327→			if g.containsTimer(inner) {
   328→				return true
   329→			}
   330→		}
   331→	case *ast.FuncDecl:
   332→		for _, inner := range s.Body {
   333→			if g.containsTimer(inner) {
   334→				return true
   335→			}
   336→		}
   337→	case *ast.WhileLoop:
   338→		if s.Body != nil &amp;&amp; g.containsTimer(s.Body) {
   339→			return true
   340→		}
   341→	case *ast.IfStatement:
   342→		for _, choice := range s.Choices {
   343→			if choice.Body != nil &amp;&amp; g.containsTimer(choice.Body) {
   344→				return true
   345→			}
   346→		}
   347→	case *ast.CaseStatement:
   348→		for _, choice := range s.Choices {
   349→			if choice.Body != nil &amp;&amp; g.containsTimer(choice.Body) {
   350→				return true
   351→			}
   352→		}
   353→	case *ast.VariantReceive:
   354→		for _, c := range s.Cases {
   355→			if c.Body != nil &amp;&amp; g.containsTimer(c.Body) {
   356→				return true
   357→			}
   358→		}
   359→	}
   360→	return false
   361→}
   362→
   363→func (g *Generator) containsStop(stmt ast.Statement) bool {
   364→	switch s := stmt.(type) {
   365→	case *ast.Stop:
   366→		return true
   367→	case *ast.SeqBlock:
   368→		for _, inner := range s.Statements {
   369→			if g.containsStop(inner) {
   370→				return true
   371→			}
   372→		}
   373→	case *ast.ParBlock:
   374→		for _, inner := range s.Statements {
   375→			if g.containsStop(inner) {
   376→				return true
   377→			}
   378→		}
   379→	case *ast.AltBlock:
   380→		for _, c := range s.Cases {
   381→			if c.Body != nil &amp;&amp; g.containsStop(c.Body) {
   382→				return true
   383→			}
   384→		}
   385→	case *ast.ProcDecl:
   386→		for _, inner := range s.Body {
   387→			if g.containsStop(inner) {
   388→				return true
   389→			}
   390→		}
   391→	case *ast.FuncDecl:
   392→		for _, inner := range s.Body {
   393→			if g.containsStop(inner) {
   394→				return true
   395→			}
   396→		}
   397→	case *ast.WhileLoop:
   398→		if s.Body != nil &amp;&amp; g.containsStop(s.Body) {
   399→			return true
   400→		}
   401→	case *ast.IfStatement:
   402→		for _, choice := range s.Choices {
   403→			if choice.Body != nil &amp;&amp; g.containsStop(choice.Body) {
   404→				return true
   405→			}
   406→		}
   407→	case *ast.CaseStatement:
   408→		for _, choice := range s.Choices {
   409→			if choice.Body != nil &amp;&amp; g.containsStop(choice.Body) {
   410→				return true
   411→			}
   412→		}
   413→	case *ast.VariantReceive:
   414→		for _, c := range s.Cases {
   415→			if c.Body != nil &amp;&amp; g.containsStop(c.Body) {
   416→				return true
   417→			}
   418→		}
   419→	}
   420→	return false
   421→}
   422→
   423→func (g *Generator) containsMostExpr(stmt ast.Statement) bool {
   424→	switch s := stmt.(type) {
   425→	case *ast.Assignment:
   426→		return g.exprNeedsMath(s.Value) || g.exprNeedsMath(s.Index)
   427→	case *ast.MultiAssignment:
   428→		for _, t := range s.Targets {
   429→			if g.exprNeedsMath(t.Index) {
   430→				return true
   431→			}
   432→		}
   433→		for _, v := range s.Values {
   434→			if g.exprNeedsMath(v) {
   435→				return true
   436→			}
   437→		}
   438→	case *ast.Abbreviation:
   439→		return g.exprNeedsMath(s.Value)
   440→	case *ast.SeqBlock:
   441→		for _, inner := range s.Statements {
   442→			if g.containsMostExpr(inner) {
   443→				return true
   444→			}
   445→		}
   446→	case *ast.ParBlock:
   447→		for _, inner := range s.Statements {
   448→			if g.containsMostExpr(inner) {
   449→				return true
   450→			}
   451→		}
   452→	case *ast.ProcDecl:
   453→		for _, inner := range s.Body {
   454→			if g.containsMostExpr(inner) {
   455→				return true
   456→			}
   457→		}
   458→	case *ast.FuncDecl:
   459→		for _, inner := range s.Body {
   460→			if g.containsMostExpr(inner) {
   461→				return true
   462→			}
   463→		}
   464→	case *ast.WhileLoop:
   465→		if g.exprNeedsMath(s.Condition) {
   466→			return true
   467→		}
   468→		if s.Body != nil &amp;&amp; g.containsMostExpr(s.Body) {
   469→			return true
   470→		}
   471→	case *ast.IfStatement:
   472→		for _, choice := range s.Choices {
   473→			if g.exprNeedsMath(choice.Condition) {
   474→				return true
   475→			}
   476→			if choice.Body != nil &amp;&amp; g.containsMostExpr(choice.Body) {
   477→				return true
   478→			}
   479→		}
   480→	case *ast.CaseStatement:
   481→		if g.exprNeedsMath(s.Selector) {
   482→			return true
   483→		}
   484→		for _, choice := range s.Choices {
   485→			for _, v := range choice.Values {
   486→				if g.exprNeedsMath(v) {
   487→					return true
   488→				}
   489→			}
   490→			if choice.Body != nil &amp;&amp; g.containsMostExpr(choice.Body) {
   491→				return true
   492→			}
   493→		}
   494→	case *ast.Send:
   495→		if g.exprNeedsMath(s.Value) {
   496→			return true
   497→		}
   498→		for _, v := range s.Values {
   499→			if g.exprNeedsMath(v) {
   500→				return true
   501→			}
   502→		}
   503→	case *ast.ProcCall:
   504→		for _, arg := range s.Args {
   505→			if g.exprNeedsMath(arg) {
   506→				return true
   507→			}
   508→		}
   509→	case *ast.AltBlock:
   510→		for _, c := range s.Cases {
   511→			if c.Body != nil &amp;&amp; g.containsMostExpr(c.Body) {
   512→				return true
   513→			}
   514→		}
   515→	case *ast.VariantReceive:
   516→		for _, c := range s.Cases {
   517→			if c.Body != nil &amp;&amp; g.containsMostExpr(c.Body) {
   518→				return true
   519→			}
   520→		}
   521→	}
   522→	return false
   523→}
   524→
   525→func (g *Generator) exprNeedsMath(expr ast.Expression) bool {
   526→	if expr == nil {
   527→		return false
   528→	}
   529→	switch e := expr.(type) {
   530→	case *ast.MostExpr:
   531→		// BYTE uses literal 0/255, doesn&#x27;t need math
   532→		return e.ExprType != &quot;BYTE&quot;
   533→	case *ast.BinaryExpr:
   534→		return g.exprNeedsMath(e.Left) || g.exprNeedsMath(e.Right)
   535→	case *ast.UnaryExpr:
   536→		return g.exprNeedsMath(e.Right)
   537→	case *ast.ParenExpr:
   538→		return g.exprNeedsMath(e.Expr)
   539→	case *ast.TypeConversion:
   540→		return g.exprNeedsMath(e.Expr)
   541→	case *ast.SizeExpr:
   542→		return g.exprNeedsMath(e.Expr)
   543→	case *ast.IndexExpr:
   544→		return g.exprNeedsMath(e.Left) || g.exprNeedsMath(e.Index)
   545→	case *ast.FuncCall:
   546→		for _, arg := range e.Args {
   547→			if g.exprNeedsMath(arg) {
   548→				return true
   549→			}
   550→		}
   551→	case *ast.SliceExpr:
   552→		return g.exprNeedsMath(e.Array) || g.exprNeedsMath(e.Start) || g.exprNeedsMath(e.Length)
   553→	}
   554→	return false
   555→}
   556→
   557→func (g *Generator) generateMostExpr(e *ast.MostExpr) {
   558→	switch e.ExprType {
   559→	case &quot;INT&quot;:
   560→		if e.IsNeg {
   561→			g.write(&quot;math.MinInt&quot;)
   562→		} else {
   563→			g.write(&quot;math.MaxInt&quot;)
   564→		}
   565→	case &quot;BYTE&quot;:
   566→		if e.IsNeg {
   567→			g.write(&quot;0&quot;)
   568→		} else {
   569→			g.write(&quot;255&quot;)
   570→		}
   571→	case &quot;REAL32&quot;:
   572→		if e.IsNeg {
   573→			g.write(&quot;-math.MaxFloat32&quot;)
   574→		} else {
   575→			g.write(&quot;math.MaxFloat32&quot;)
   576→		}
   577→	case &quot;REAL64&quot;:
   578→		if e.IsNeg {
   579→			g.write(&quot;-math.MaxFloat64&quot;)
   580→		} else {
   581→			g.write(&quot;math.MaxFloat64&quot;)
   582→		}
   583→	}
   584→}
   585→
   586→func (g *Generator) writeLine(s string) {
   587→	if s == &quot;&quot; {
   588→		g.builder.WriteString(&quot;\n&quot;)
   589→		return
   590→	}
   591→	g.builder.WriteString(strings.Repeat(&quot;\t&quot;, g.indent))
   592→	g.builder.WriteString(s)
   593→	g.builder.WriteString(&quot;\n&quot;)
   594→}
   595→
   596→func (g *Generator) write(s string) {
   597→	g.builder.WriteString(s)
   598→}
   599→
   600→func (g *Generator) generateStatement(stmt ast.Statement) {
   601→	switch s := stmt.(type) {
   602→	case *ast.VarDecl:
   603→		g.generateVarDecl(s)
   604→	case *ast.ArrayDecl:
   605→		g.generateArrayDecl(s)
   606→	case *ast.ChanDecl:
   607→		g.generateChanDecl(s)
   608→	case *ast.Assignment:
   609→		g.generateAssignment(s)
   610→	case *ast.Send:
   611→		g.generateSend(s)
   612→	case *ast.Receive:
   613→		g.generateReceive(s)
   614→	case *ast.SeqBlock:
   615→		g.generateSeqBlock(s)
   616→	case *ast.ParBlock:
   617→		g.generateParBlock(s)
   618→	case *ast.AltBlock:
   619→		g.generateAltBlock(s)
   620→	case *ast.Skip:
   621→		g.writeLine(&quot;// SKIP&quot;)
   622→	case *ast.Stop:
   623→		g.writeLine(`fmt.Fprintln(os.Stderr, &quot;STOP encountered&quot;)`)
   624→		g.writeLine(&quot;select {}&quot;)
   625→	case *ast.ProcDecl:
   626→		g.generateProcDecl(s)
   627→	case *ast.FuncDecl:
   628→		g.generateFuncDecl(s)
   629→	case *ast.ProcCall:
   630→		g.generateProcCall(s)
   631→	case *ast.WhileLoop:
   632→		g.generateWhileLoop(s)
   633→	case *ast.IfStatement:
   634→		g.generateIfStatement(s)
   635→	case *ast.CaseStatement:
   636→		g.generateCaseStatement(s)
   637→	case *ast.TimerDecl:
   638→		g.generateTimerDecl(s)
   639→	case *ast.TimerRead:
   640→		g.generateTimerRead(s)
   641→	case *ast.ProtocolDecl:
   642→		g.generateProtocolDecl(s)
   643→	case *ast.VariantReceive:
   644→		g.generateVariantReceive(s)
   645→	case *ast.RecordDecl:
   646→		g.generateRecordDecl(s)
   647→	case *ast.Abbreviation:
   648→		g.generateAbbreviation(s)
   649→	case *ast.MultiAssignment:
   650→		g.generateMultiAssignment(s)
   651→	}
   652→}
   653→
   654→func (g *Generator) generateVarDecl(decl *ast.VarDecl) {
   655→	goType := g.occamTypeToGo(decl.Type)
   656→	g.writeLine(fmt.Sprintf(&quot;var %s %s&quot;, strings.Join(decl.Names, &quot;, &quot;), goType))
   657→}
   658→
   659→func (g *Generator) generateAbbreviation(abbr *ast.Abbreviation) {
   660→	g.builder.WriteString(strings.Repeat(&quot;\t&quot;, g.indent))
   661→	g.write(fmt.Sprintf(&quot;%s := &quot;, abbr.Name))
   662→	g.generateExpression(abbr.Value)
   663→	g.write(&quot;\n&quot;)
   664→}
   665→
   666→func (g *Generator) generateChanDecl(decl *ast.ChanDecl) {
   667→	goType := g.occamTypeToGo(decl.ElemType)
   668→	if decl.IsArray {
   669→		for _, name := range decl.Names {
   670→			g.builder.WriteString(strings.Repeat(&quot;\t&quot;, g.indent))
   671→			g.write(fmt.Sprintf(&quot;%s := make([]chan %s, &quot;, name, goType))
   672→			g.generateExpression(decl.Size)
   673→			g.write(&quot;)\n&quot;)
   674→			g.builder.WriteString(strings.Repeat(&quot;\t&quot;, g.indent))
   675→			g.write(fmt.Sprintf(&quot;for _i := range %s { %s[_i] = make(chan %s) }\n&quot;, name, name, goType))
   676→		}
   677→	} else {
   678→		for _, name := range decl.Names {
   679→			g.writeLine(fmt.Sprintf(&quot;%s := make(chan %s)&quot;, name, goType))
   680→		}
   681→	}
   682→}
   683→
   684→func (g *Generator) generateTimerDecl(decl *ast.TimerDecl) {
   685→	for _, name := range decl.Names {
   686→		g.writeLine(fmt.Sprintf(&quot;// TIMER %s&quot;, name))
   687→	}
   688→}
   689→
   690→func (g *Generator) generateTimerRead(tr *ast.TimerRead) {
   691→	g.writeLine(fmt.Sprintf(&quot;%s = int(time.Now().UnixMicro())&quot;, tr.Variable))
   692→}
   693→
   694→func (g *Generator) generateArrayDecl(decl *ast.ArrayDecl) {
   695→	goType := g.occamTypeToGo(decl.Type)
   696→	for _, name := range decl.Names {
   697→		g.builder.WriteString(strings.Repeat(&quot;\t&quot;, g.indent))
   698→		g.write(fmt.Sprintf(&quot;%s := make([]%s, &quot;, name, goType))
   699→		g.generateExpression(decl.Size)
   700→		g.write(&quot;)\n&quot;)
   701→	}
   702→}
   703→
   704→func (g *Generator) generateSend(send *ast.Send) {
   705→	g.builder.WriteString(strings.Repeat(&quot;\t&quot;, g.indent))
   706→	g.write(send.Channel)
   707→	if send.ChannelIndex != nil {
   708→		g.write(&quot;[&quot;)
   709→		g.generateExpression(send.ChannelIndex)
   710→		g.write(&quot;]&quot;)
   711→	}
   712→	g.write(&quot; &lt;- &quot;)
   713→
   714→	protoName := g.chanProtocols[send.Channel]
   715→	proto := g.protocolDefs[protoName]
   716→
   717→	if send.VariantTag != &quot;&quot; &amp;&amp; proto != nil &amp;&amp; proto.Kind == &quot;variant&quot; {
   718→		// Variant send with explicit tag: c &lt;- _proto_NAME_tag{values...}
   719→		g.write(fmt.Sprintf(&quot;_proto_%s_%s{&quot;, protoName, send.VariantTag))
   720→		for i, val := range send.Values {
   721→			if i &gt; 0 {
   722→				g.write(&quot;, &quot;)
   723→			}
   724→			g.generateExpression(val)
   725→		}
   726→		g.write(&quot;}&quot;)
   727→	} else if proto != nil &amp;&amp; proto.Kind == &quot;variant&quot; &amp;&amp; send.Value != nil &amp;&amp; len(send.Values) == 0 {
   728→		// Check if the send value is a bare identifier matching a variant tag
   729→		if ident, ok := send.Value.(*ast.Identifier); ok &amp;&amp; g.isVariantTag(protoName, ident.Value) {
   730→			g.write(fmt.Sprintf(&quot;_proto_%s_%s{}&quot;, protoName, ident.Value))
   731→		} else {
   732→			g.generateExpression(send.Value)
   733→		}
   734→	} else if len(send.Values) &gt; 0 &amp;&amp; proto != nil &amp;&amp; proto.Kind == &quot;sequential&quot; {
   735→		// Sequential send: c &lt;- _proto_NAME{val1, val2, ...}
   736→		g.write(fmt.Sprintf(&quot;_proto_%s{&quot;, protoName))
   737→		g.generateExpression(send.Value)
   738→		for _, val := range send.Values {
   739→			g.write(&quot;, &quot;)
   740→			g.generateExpression(val)
   741→		}
   742→		g.write(&quot;}&quot;)
   743→	} else {
   744→		// Simple send
   745→		g.generateExpression(send.Value)
   746→	}
   747→	g.write(&quot;\n&quot;)
   748→}
   749→
   750→func (g *Generator) generateReceive(recv *ast.Receive) {
   751→	chanRef := recv.Channel
   752→	if recv.ChannelIndex != nil {
   753→		var buf strings.Builder
   754→		buf.WriteString(recv.Channel)
   755→		buf.WriteString(&quot;[&quot;)
   756→		// Generate the index expression into a temporary buffer
   757→		oldBuilder := g.builder
   758→		g.builder = strings.Builder{}
   759→		g.generateExpression(recv.ChannelIndex)
   760→		buf.WriteString(g.builder.String())
   761→		g.builder = oldBuilder
   762→		buf.WriteString(&quot;]&quot;)
   763→		chanRef = buf.String()
   764→	}
   765→
   766→	if len(recv.Variables) &gt; 0 {
   767→		// Sequential receive: _tmpN := &lt;-c; x = _tmpN._0; y = _tmpN._1
   768→		tmpName := fmt.Sprintf(&quot;_tmp%d&quot;, g.tmpCounter)
   769→		g.tmpCounter++
   770→		g.writeLine(fmt.Sprintf(&quot;%s := &lt;-%s&quot;, tmpName, chanRef))
   771→		g.writeLine(fmt.Sprintf(&quot;%s = %s._0&quot;, recv.Variable, tmpName))
   772→		for i, v := range recv.Variables {
   773→			g.writeLine(fmt.Sprintf(&quot;%s = %s._%d&quot;, v, tmpName, i+1))
   774→		}
   775→	} else {
   776→		g.writeLine(fmt.Sprintf(&quot;%s = &lt;-%s&quot;, recv.Variable, chanRef))
   777→	}
   778→}
   779→
   780→func (g *Generator) generateProtocolDecl(proto *ast.ProtocolDecl) {
   781→	switch proto.Kind {
   782→	case &quot;simple&quot;:
   783→		goType := g.occamTypeToGoBase(proto.Types[0])
   784→		g.writeLine(fmt.Sprintf(&quot;type _proto_%s = %s&quot;, proto.Name, goType))
   785→		g.writeLine(&quot;&quot;)
   786→	case &quot;sequential&quot;:
   787→		g.writeLine(fmt.Sprintf(&quot;type _proto_%s struct {&quot;, proto.Name))
   788→		g.indent++
   789→		for i, t := range proto.Types {
   790→			goType := g.occamTypeToGoBase(t)
   791→			g.writeLine(fmt.Sprintf(&quot;_%d %s&quot;, i, goType))
   792→		}
   793→		g.indent--
   794→		g.writeLine(&quot;}&quot;)
   795→		g.writeLine(&quot;&quot;)
   796→	case &quot;variant&quot;:
   797→		// Interface type
   798→		g.writeLine(fmt.Sprintf(&quot;type _proto_%s interface {&quot;, proto.Name))
   799→		g.indent++
   800→		g.writeLine(fmt.Sprintf(&quot;_is_%s()&quot;, proto.Name))
   801→		g.indent--
   802→		g.writeLine(&quot;}&quot;)
   803→		g.writeLine(&quot;&quot;)
   804→		// Concrete types for each variant
   805→		for _, v := range proto.Variants {
   806→			if len(v.Types) == 0 {
   807→				// No-payload variant: empty struct
   808→				g.writeLine(fmt.Sprintf(&quot;type _proto_%s_%s struct{}&quot;, proto.Name, v.Tag))
   809→			} else {
   810→				g.writeLine(fmt.Sprintf(&quot;type _proto_%s_%s struct {&quot;, proto.Name, v.Tag))
   811→				g.indent++
   812→				for i, t := range v.Types {
   813→					goType := g.occamTypeToGoBase(t)
   814→					g.writeLine(fmt.Sprintf(&quot;_%d %s&quot;, i, goType))
   815→				}
   816→				g.indent--
   817→				g.writeLine(&quot;}&quot;)
   818→			}
   819→			g.writeLine(fmt.Sprintf(&quot;func (_proto_%s_%s) _is_%s() {}&quot;, proto.Name, v.Tag, proto.Name))
   820→			g.writeLine(&quot;&quot;)
   821→		}
   822→	}
   823→}
   824→
   825→func (g *Generator) generateVariantReceive(vr *ast.VariantReceive) {
   826→	protoName := g.chanProtocols[vr.Channel]
   827→	chanRef := vr.Channel
   828→	if vr.ChannelIndex != nil {
   829→		var buf strings.Builder
   830→		buf.WriteString(vr.Channel)
   831→		buf.WriteString(&quot;[&quot;)
   832→		oldBuilder := g.builder
   833→		g.builder = strings.Builder{}
   834→		g.generateExpression(vr.ChannelIndex)
   835→		buf.WriteString(g.builder.String())
   836→		g.builder = oldBuilder
   837→		buf.WriteString(&quot;]&quot;)
   838→		chanRef = buf.String()
   839→	}
   840→	g.writeLine(fmt.Sprintf(&quot;switch _v := (&lt;-%s).(type) {&quot;, chanRef))
   841→	for _, vc := range vr.Cases {
   842→		g.writeLine(fmt.Sprintf(&quot;case _proto_%s_%s:&quot;, protoName, vc.Tag))
   843→		g.indent++
   844→		for i, v := range vc.Variables {
   845→			g.writeLine(fmt.Sprintf(&quot;%s = _v._%d&quot;, v, i))
   846→		}
   847→		if vc.Body != nil {
   848→			g.generateStatement(vc.Body)
   849→		}
   850→		g.indent--
   851→	}
   852→	g.writeLine(&quot;}&quot;)
   853→}
   854→
   855→func (g *Generator) isVariantTag(protoName, tagName string) bool {
   856→	proto := g.protocolDefs[protoName]
   857→	if proto == nil {
   858→		return false
   859→	}
   860→	for _, v := range proto.Variants {
   861→		if v.Tag == tagName {
   862→			return true
   863→		}
   864→	}
   865→	return false
   866→}
   867→
   868→func (g *Generator) collectChanProtocols(stmt ast.Statement) {
   869→	switch s := stmt.(type) {
   870→	case *ast.ChanDecl:
   871→		if _, ok := g.protocolDefs[s.ElemType]; ok {
   872→			for _, name := range s.Names {
   873→				g.chanProtocols[name] = s.ElemType
   874→			}
   875→		}
   876→	case *ast.SeqBlock:
   877→		for _, inner := range s.Statements {
   878→			g.collectChanProtocols(inner)
   879→		}
   880→	case *ast.ParBlock:
   881→		for _, inner := range s.Statements {
   882→			g.collectChanProtocols(inner)
   883→		}
   884→	case *ast.ProcDecl:
   885→		// Register PROC param channels (including channel array params)
   886→		for _, p := range s.Params {
   887→			if p.IsChan || p.IsChanArray {
   888→				if _, ok := g.protocolDefs[p.ChanElemType]; ok {
   889→					g.chanProtocols[p.Name] = p.ChanElemType
   890→				}
   891→			}
   892→		}
   893→		for _, inner := range s.Body {
   894→			g.collectChanProtocols(inner)
   895→		}
   896→	case *ast.FuncDecl:
   897→		for _, inner := range s.Body {
   898→			g.collectChanProtocols(inner)
   899→		}
   900→	case *ast.WhileLoop:
   901→		if s.Body != nil {
   902→			g.collectChanProtocols(s.Body)
   903→		}
   904→	case *ast.IfStatement:
   905→		for _, choice := range s.Choices {
   906→			if choice.Body != nil {
   907→				g.collectChanProtocols(choice.Body)
   908→			}
   909→		}
   910→	case *ast.CaseStatement:
   911→		for _, choice := range s.Choices {
   912→			if choice.Body != nil {
   913→				g.collectChanProtocols(choice.Body)
   914→			}
   915→		}
   916→	case *ast.AltBlock:
   917→		for _, c := range s.Cases {
   918→			if c.Body != nil {
   919→				g.collectChanProtocols(c.Body)
   920→			}
   921→		}
   922→	}
   923→}
   924→
   925→func (g *Generator) collectRecordVars(stmt ast.Statement) {
   926→	switch s := stmt.(type) {
   927→	case *ast.VarDecl:
   928→		if _, ok := g.recordDefs[s.Type]; ok {
   929→			for _, name := range s.Names {
   930→				g.recordVars[name] = s.Type
   931→			}
   932→		}
   933→	case *ast.SeqBlock:
   934→		for _, inner := range s.Statements {
   935→			g.collectRecordVars(inner)
   936→		}
   937→	case *ast.ParBlock:
   938→		for _, inner := range s.Statements {
   939→			g.collectRecordVars(inner)
   940→		}
   941→	case *ast.ProcDecl:
   942→		for _, p := range s.Params {
   943→			if !p.IsChan {
   944→				if _, ok := g.recordDefs[p.Type]; ok {
   945→					g.recordVars[p.Name] = p.Type
   946→				}
   947→			}
   948→		}
   949→		for _, inner := range s.Body {
   950→			g.collectRecordVars(inner)
   951→		}
   952→	case *ast.FuncDecl:
   953→		for _, inner := range s.Body {
   954→			g.collectRecordVars(inner)
   955→		}
   956→	case *ast.WhileLoop:
   957→		if s.Body != nil {
   958→			g.collectRecordVars(s.Body)
   959→		}
   960→	case *ast.IfStatement:
   961→		for _, choice := range s.Choices {
   962→			if choice.Body != nil {
   963→				g.collectRecordVars(choice.Body)
   964→			}
   965→		}
   966→	case *ast.CaseStatement:
   967→		for _, choice := range s.Choices {
   968→			if choice.Body != nil {
   969→				g.collectRecordVars(choice.Body)
   970→			}
   971→		}
   972→	case *ast.AltBlock:
   973→		for _, c := range s.Cases {
   974→			if c.Body != nil {
   975→				g.collectRecordVars(c.Body)
   976→			}
   977→		}
   978→	}
   979→}
   980→
   981→func (g *Generator) generateRecordDecl(rec *ast.RecordDecl) {
   982→	g.writeLine(fmt.Sprintf(&quot;type %s struct {&quot;, rec.Name))
   983→	g.indent++
   984→	for _, f := range rec.Fields {
   985→		goType := g.occamTypeToGoBase(f.Type)
   986→		g.writeLine(fmt.Sprintf(&quot;%s %s&quot;, f.Name, goType))
   987→	}
   988→	g.indent--
   989→	g.writeLine(&quot;}&quot;)
   990→	g.writeLine(&quot;&quot;)
   991→}
   992→
   993→// occamTypeToGoBase converts a type name without checking protocol defs
   994→// (used inside protocol generation to avoid infinite recursion)
   995→func (g *Generator) occamTypeToGoBase(occamType string) string {
   996→	switch occamType {
   997→	case &quot;INT&quot;:
   998→		return &quot;int&quot;
   999→	case &quot;BYTE&quot;:
  1000→		return &quot;byte&quot;
  1001→	case &quot;BOOL&quot;:
  1002→		return &quot;bool&quot;
  1003→	case &quot;REAL&quot;:
  1004→		return &quot;float64&quot;
  1005→	case &quot;REAL32&quot;:
  1006→		return &quot;float32&quot;
  1007→	case &quot;REAL64&quot;:
  1008→		return &quot;float64&quot;
  1009→	default:
  1010→		return occamType
  1011→	}
  1012→}
  1013→
  1014→func (g *Generator) occamTypeToGo(occamType string) string {
  1015→	switch occamType {
  1016→	case &quot;INT&quot;:
  1017→		return &quot;int&quot;
  1018→	case &quot;BYTE&quot;:
  1019→		return &quot;byte&quot;
  1020→	case &quot;BOOL&quot;:
  1021→		return &quot;bool&quot;
  1022→	case &quot;REAL&quot;:
  1023→		return &quot;float64&quot;
  1024→	case &quot;REAL32&quot;:
  1025→		return &quot;float32&quot;
  1026→	case &quot;REAL64&quot;:
  1027→		return &quot;float64&quot;
  1028→	default:
  1029→		// Check if it&#x27;s a protocol name
  1030→		if _, ok := g.protocolDefs[occamType]; ok {
  1031→			return &quot;_proto_&quot; + occamType
  1032→		}
  1033→		// Check if it&#x27;s a record type name
  1034→		if _, ok := g.recordDefs[occamType]; ok {
  1035→			return occamType
  1036→		}
  1037→		return occamType // pass through unknown types
  1038→	}
  1039→}
  1040→
  1041→func (g *Generator) generateAssignment(assign *ast.Assignment) {
  1042→	g.builder.WriteString(strings.Repeat(&quot;\t&quot;, g.indent))
  1043→
  1044→	if assign.SliceTarget != nil {
  1045→		// Slice assignment: [arr FROM start FOR length] := value
  1046→		// Maps to: copy(arr[start : start + length], value)
  1047→		g.write(&quot;copy(&quot;)
  1048→		g.generateExpression(assign.SliceTarget.Array)
  1049→		g.write(&quot;[&quot;)
  1050→		g.generateExpression(assign.SliceTarget.Start)
  1051→		g.write(&quot; : &quot;)
  1052→		g.generateExpression(assign.SliceTarget.Start)
  1053→		g.write(&quot; + &quot;)
  1054→		g.generateExpression(assign.SliceTarget.Length)
  1055→		g.write(&quot;], &quot;)
  1056→		g.generateExpression(assign.Value)
  1057→		g.write(&quot;)\n&quot;)
  1058→		return
  1059→	}
  1060→
  1061→	if assign.Index != nil {
  1062→		// Check if this is a record field access
  1063→		if _, ok := g.recordVars[assign.Name]; ok {
  1064→			if ident, ok := assign.Index.(*ast.Identifier); ok {
  1065→				// Record field: p.x = value (Go auto-dereferences pointers)
  1066→				g.write(assign.Name)
  1067→				g.write(&quot;.&quot;)
  1068→				g.write(ident.Value)
  1069→				g.write(&quot; = &quot;)
  1070→				g.generateExpression(assign.Value)
  1071→				g.write(&quot;\n&quot;)
  1072→				return
  1073→			}
  1074→		}
  1075→		// Array index: dereference if ref param
  1076→		if g.refParams[assign.Name] {
  1077→			g.write(&quot;*&quot;)
  1078→		}
  1079→		g.write(assign.Name)
  1080→		g.write(&quot;[&quot;)
  1081→		g.generateExpression(assign.Index)
  1082→		g.write(&quot;]&quot;)
  1083→	} else {
  1084→		// Simple assignment: dereference if ref param
  1085→		if g.refParams[assign.Name] {
  1086→			g.write(&quot;*&quot;)
  1087→		}
  1088→		g.write(assign.Name)
  1089→	}
  1090→	g.write(&quot; = &quot;)
  1091→	g.generateExpression(assign.Value)
  1092→	g.write(&quot;\n&quot;)
  1093→}
  1094→
  1095→func (g *Generator) generateSeqBlock(seq *ast.SeqBlock) {
  1096→	if seq.Replicator != nil {
  1097→		if seq.Replicator.Step != nil {
  1098→			// Replicated SEQ with STEP: counter-based loop
  1099→			v := seq.Replicator.Variable
  1100→			counter := &quot;_repl_&quot; + v
  1101→			g.builder.WriteString(strings.Repeat(&quot;\t&quot;, g.indent))
  1102→			g.write(fmt.Sprintf(&quot;for %s := 0; %s &lt; &quot;, counter, counter))
  1103→			g.generateExpression(seq.Replicator.Count)
  1104→			g.write(fmt.Sprintf(&quot;; %s++ {\n&quot;, counter))
  1105→			g.indent++
  1106→			g.builder.WriteString(strings.Repeat(&quot;\t&quot;, g.indent))
  1107→			g.write(fmt.Sprintf(&quot;%s := &quot;, v))
  1108→			g.generateExpression(seq.Replicator.Start)
  1109→			g.write(fmt.Sprintf(&quot; + %s * &quot;, counter))
  1110→			g.generateExpression(seq.Replicator.Step)
  1111→			g.write(&quot;\n&quot;)
  1112→		} else {
  1113→			// Replicated SEQ: SEQ i = start FOR count becomes a for loop
  1114→			g.builder.WriteString(strings.Repeat(&quot;\t&quot;, g.indent))
  1115→			g.write(fmt.Sprintf(&quot;for %s := &quot;, seq.Replicator.Variable))
  1116→			g.generateExpression(seq.Replicator.Start)
  1117→			g.write(fmt.Sprintf(&quot;; %s &lt; &quot;, seq.Replicator.Variable))
  1118→			g.generateExpression(seq.Replicator.Start)
  1119→			g.write(&quot; + &quot;)
  1120→			g.generateExpression(seq.Replicator.Count)
  1121→			g.write(fmt.Sprintf(&quot;; %s++ {\n&quot;, seq.Replicator.Variable))
  1122→			g.indent++
  1123→		}
  1124→		for _, stmt := range seq.Statements {
  1125→			g.generateStatement(stmt)
  1126→		}
  1127→		g.indent--
  1128→		g.writeLine(&quot;}&quot;)
  1129→	} else {
  1130→		// SEQ just becomes sequential Go code (Go&#x27;s default)
  1131→		for _, stmt := range seq.Statements {
  1132→			g.generateStatement(stmt)
  1133→		}
  1134→	}
  1135→}
  1136→
  1137→func (g *Generator) generateParBlock(par *ast.ParBlock) {
  1138→	if par.Replicator != nil {
  1139→		// Replicated PAR: PAR i = start FOR count becomes goroutines in a loop
  1140→		g.writeLine(&quot;var wg sync.WaitGroup&quot;)
  1141→		g.builder.WriteString(strings.Repeat(&quot;\t&quot;, g.indent))
  1142→		g.write(&quot;wg.Add(int(&quot;)
  1143→		g.generateExpression(par.Replicator.Count)
  1144→		g.write(&quot;))\n&quot;)
  1145→
  1146→		v := par.Replicator.Variable
  1147→		if par.Replicator.Step != nil {
  1148→			counter := &quot;_repl_&quot; + v
  1149→			g.builder.WriteString(strings.Repeat(&quot;\t&quot;, g.indent))
  1150→			g.write(fmt.Sprintf(&quot;for %s := 0; %s &lt; &quot;, counter, counter))
  1151→			g.generateExpression(par.Replicator.Count)
  1152→			g.write(fmt.Sprintf(&quot;; %s++ {\n&quot;, counter))
  1153→			g.indent++
  1154→			// Compute loop variable from counter — also serves as closure capture
  1155→			g.builder.WriteString(strings.Repeat(&quot;\t&quot;, g.indent))
  1156→			g.write(fmt.Sprintf(&quot;%s := &quot;, v))
  1157→			g.generateExpression(par.Replicator.Start)
  1158→			g.write(fmt.Sprintf(&quot; + %s * &quot;, counter))
  1159→			g.generateExpression(par.Replicator.Step)
  1160→			g.write(&quot;\n&quot;)
  1161→		} else {
  1162→			g.builder.WriteString(strings.Repeat(&quot;\t&quot;, g.indent))
  1163→			g.write(fmt.Sprintf(&quot;for %s := &quot;, v))
  1164→			g.generateExpression(par.Replicator.Start)
  1165→			g.write(fmt.Sprintf(&quot;; %s &lt; &quot;, v))
  1166→			g.generateExpression(par.Replicator.Start)
  1167→			g.write(&quot; + &quot;)
  1168→			g.generateExpression(par.Replicator.Count)
  1169→			g.write(fmt.Sprintf(&quot;; %s++ {\n&quot;, v))
  1170→			g.indent++
  1171→			// Capture loop variable to avoid closure issues
  1172→			g.writeLine(fmt.Sprintf(&quot;%s := %s&quot;, v, v))
  1173→		}
  1174→		g.writeLine(&quot;go func() {&quot;)
  1175→		g.indent++
  1176→		g.writeLine(&quot;defer wg.Done()&quot;)
  1177→		for _, stmt := range par.Statements {
  1178→			g.generateStatement(stmt)
  1179→		}
  1180→		g.indent--
  1181→		g.writeLine(&quot;}()&quot;)
  1182→
  1183→		g.indent--
  1184→		g.writeLine(&quot;}&quot;)
  1185→		g.writeLine(&quot;wg.Wait()&quot;)
  1186→	} else {
  1187→		// PAR becomes goroutines with WaitGroup
  1188→		g.writeLine(&quot;var wg sync.WaitGroup&quot;)
  1189→		g.writeLine(fmt.Sprintf(&quot;wg.Add(%d)&quot;, len(par.Statements)))
  1190→
  1191→		for _, stmt := range par.Statements {
  1192→			g.writeLine(&quot;go func() {&quot;)
  1193→			g.indent++
  1194→			g.writeLine(&quot;defer wg.Done()&quot;)
  1195→			g.generateStatement(stmt)
  1196→			g.indent--
  1197→			g.writeLine(&quot;}()&quot;)
  1198→		}
  1199→
  1200→		g.writeLine(&quot;wg.Wait()&quot;)
  1201→	}
  1202→}
  1203→
  1204→func (g *Generator) generateAltBlock(alt *ast.AltBlock) {
  1205→	// ALT becomes Go select statement
  1206→	// For guards, we use a pattern with nil channels
  1207→
  1208→	// Check if any cases have guards
  1209→	hasGuards := false
  1210→	for _, c := range alt.Cases {
  1211→		if c.Guard != nil {
  1212→			hasGuards = true
  1213→			break
  1214→		}
  1215→	}
  1216→
  1217→	if hasGuards {
  1218→		// Generate channel variables for guarded cases
  1219→		for i, c := range alt.Cases {
  1220→			if c.Guard != nil {
  1221→				g.builder.WriteString(strings.Repeat(&quot;\t&quot;, g.indent))
  1222→				g.write(fmt.Sprintf(&quot;var _alt%d chan &quot;, i))
  1223→				// We don&#x27;t know the channel type here, so use interface{}
  1224→				// Actually, we should use the same type as the original channel
  1225→				// For now, let&#x27;s just reference the original channel conditionally
  1226→				g.write(fmt.Sprintf(&quot;int = nil\n&quot;)) // Assuming int for now
  1227→				g.builder.WriteString(strings.Repeat(&quot;\t&quot;, g.indent))
  1228→				g.write(fmt.Sprintf(&quot;if &quot;))
  1229→				g.generateExpression(c.Guard)
  1230→				g.write(fmt.Sprintf(&quot; { _alt%d = %s }\n&quot;, i, c.Channel))
  1231→			}
  1232→		}
  1233→	}
  1234→
  1235→	g.writeLine(&quot;select {&quot;)
  1236→	for i, c := range alt.Cases {
  1237→		g.builder.WriteString(strings.Repeat(&quot;\t&quot;, g.indent))
  1238→		if c.IsTimer {
  1239→			g.write(&quot;case &lt;-time.After(time.Duration(&quot;)
  1240→			g.generateExpression(c.Deadline)
  1241→			g.write(&quot; - int(time.Now().UnixMicro())) * time.Microsecond):\n&quot;)
  1242→		} else if c.Guard != nil {
  1243→			g.write(fmt.Sprintf(&quot;case %s = &lt;-_alt%d:\n&quot;, c.Variable, i))
  1244→		} else if c.ChannelIndex != nil {
  1245→			g.write(fmt.Sprintf(&quot;case %s = &lt;-%s[&quot;, c.Variable, c.Channel))
  1246→			g.generateExpression(c.ChannelIndex)
  1247→			g.write(&quot;]:\n&quot;)
  1248→		} else {
  1249→			g.write(fmt.Sprintf(&quot;case %s = &lt;-%s:\n&quot;, c.Variable, c.Channel))
  1250→		}
  1251→		g.indent++
  1252→		if c.Body != nil {
  1253→			g.generateStatement(c.Body)
  1254→		}
  1255→		g.indent--
  1256→	}
  1257→	g.writeLine(&quot;}&quot;)
  1258→}
  1259→
  1260→func (g *Generator) generateProcDecl(proc *ast.ProcDecl) {
  1261→	// Track reference parameters for this procedure
  1262→	oldRefParams := g.refParams
  1263→	newRefParams := make(map[string]bool)
  1264→	// Inherit parent&#x27;s ref params for closure captures when nested
  1265→	if g.nestingLevel &gt; 0 {
  1266→		for k, v := range oldRefParams {
  1267→			newRefParams[k] = v
  1268→		}
  1269→	}
  1270→	for _, p := range proc.Params {
  1271→		if !p.IsVal &amp;&amp; !p.IsChan &amp;&amp; !p.IsChanArray &amp;&amp; !p.IsOpenArray {
  1272→			newRefParams[p.Name] = true
  1273→		} else {
  1274→			// Own param shadows any inherited ref param with same name
  1275→			delete(newRefParams, p.Name)
  1276→		}
  1277→		// Register chan params with protocol mappings
  1278→		if p.IsChan || p.IsChanArray {
  1279→			if _, ok := g.protocolDefs[p.ChanElemType]; ok {
  1280→				g.chanProtocols[p.Name] = p.ChanElemType
  1281→			}
  1282→		}
  1283→		// Register record-typed params
  1284→		if !p.IsChan {
  1285→			if _, ok := g.recordDefs[p.Type]; ok {
  1286→				g.recordVars[p.Name] = p.Type
  1287→			}
  1288→		}
  1289→	}
  1290→	g.refParams = newRefParams
  1291→
  1292→	// Generate function signature
  1293→	params := g.generateProcParams(proc.Params)
  1294→	if g.nestingLevel &gt; 0 {
  1295→		// Nested PROC: generate as Go closure
  1296→		g.writeLine(fmt.Sprintf(&quot;%s := func(%s) {&quot;, proc.Name, params))
  1297→	} else {
  1298→		g.writeLine(fmt.Sprintf(&quot;func %s(%s) {&quot;, proc.Name, params))
  1299→	}
  1300→	g.indent++
  1301→	g.nestingLevel++
  1302→
  1303→	for _, stmt := range proc.Body {
  1304→		g.generateStatement(stmt)
  1305→	}
  1306→
  1307→	g.nestingLevel--
  1308→	g.indent--
  1309→	g.writeLine(&quot;}&quot;)
  1310→	g.writeLine(&quot;&quot;)
  1311→
  1312→	// Restore previous context
  1313→	g.refParams = oldRefParams
  1314→}
  1315→
  1316→func (g *Generator) generateProcParams(params []ast.ProcParam) string {
  1317→	var parts []string
  1318→	for _, p := range params {
  1319→		var goType string
  1320→		if p.IsChanArray {
  1321→			goType = &quot;[]&quot; + chanDirPrefix(p.ChanDir) + g.occamTypeToGo(p.ChanElemType)
  1322→		} else if p.IsChan {
  1323→			goType = chanDirPrefix(p.ChanDir) + g.occamTypeToGo(p.ChanElemType)
  1324→		} else if p.IsOpenArray {
  1325→			goType = &quot;[]&quot; + g.occamTypeToGo(p.Type)
  1326→		} else {
  1327→			goType = g.occamTypeToGo(p.Type)
  1328→			if !p.IsVal {
  1329→				// Non-VAL parameters are pass by reference in Occam
  1330→				goType = &quot;*&quot; + goType
  1331→			}
  1332→		}
  1333→		parts = append(parts, fmt.Sprintf(&quot;%s %s&quot;, p.Name, goType))
  1334→	}
  1335→	return strings.Join(parts, &quot;, &quot;)
  1336→}
  1337→
  1338→func chanDirPrefix(dir string) string {
  1339→	switch dir {
  1340→	case &quot;?&quot;:
  1341→		return &quot;&lt;-chan &quot; // input/receive-only
  1342→	case &quot;!&quot;:
  1343→		return &quot;chan&lt;- &quot; // output/send-only
  1344→	default:
  1345→		return &quot;chan &quot; // bidirectional
  1346→	}
  1347→}
  1348→
  1349→func (g *Generator) generateProcCall(call *ast.ProcCall) {
  1350→	// Handle built-in print procedures
  1351→	if printBuiltins[call.Name] {
  1352→		g.generatePrintCall(call)
  1353→		return
  1354→	}
  1355→
  1356→	g.builder.WriteString(strings.Repeat(&quot;\t&quot;, g.indent))
  1357→	g.write(call.Name)
  1358→	g.write(&quot;(&quot;)
  1359→
  1360→	// Look up procedure signature to determine which args need address-of
  1361→	params := g.procSigs[call.Name]
  1362→
  1363→	for i, arg := range call.Args {
  1364→		if i &gt; 0 {
  1365→			g.write(&quot;, &quot;)
  1366→		}
  1367→		// If this parameter is not VAL (i.e., pass by reference), take address
  1368→		// Channels and channel arrays are already reference types, so no &amp; needed
  1369→		if i &lt; len(params) &amp;&amp; !params[i].IsVal &amp;&amp; !params[i].IsChan &amp;&amp; !params[i].IsChanArray &amp;&amp; !params[i].IsOpenArray {
  1370→			g.write(&quot;&amp;&quot;)
  1371→		}
  1372→		g.generateExpression(arg)
  1373→	}
  1374→	g.write(&quot;)&quot;)
  1375→	g.write(&quot;\n&quot;)
  1376→}
  1377→
  1378→func (g *Generator) generateFuncDecl(fn *ast.FuncDecl) {
  1379→	params := g.generateProcParams(fn.Params)
  1380→
  1381→	// Build return type string
  1382→	var returnTypeStr string
  1383→	if len(fn.ReturnTypes) == 1 {
  1384→		returnTypeStr = g.occamTypeToGo(fn.ReturnTypes[0])
  1385→	} else {
  1386→		goTypes := make([]string, len(fn.ReturnTypes))
  1387→		for i, rt := range fn.ReturnTypes {
  1388→			goTypes[i] = g.occamTypeToGo(rt)
  1389→		}
  1390→		returnTypeStr = &quot;(&quot; + strings.Join(goTypes, &quot;, &quot;) + &quot;)&quot;
  1391→	}
  1392→
  1393→	if g.nestingLevel &gt; 0 {
  1394→		// Nested FUNCTION: generate as Go closure
  1395→		g.writeLine(fmt.Sprintf(&quot;%s := func(%s) %s {&quot;, fn.Name, params, returnTypeStr))
  1396→	} else {
  1397→		g.writeLine(fmt.Sprintf(&quot;func %s(%s) %s {&quot;, fn.Name, params, returnTypeStr))
  1398→	}
  1399→	g.indent++
  1400→	g.nestingLevel++
  1401→
  1402→	for _, stmt := range fn.Body {
  1403→		g.generateStatement(stmt)
  1404→	}
  1405→
  1406→	if len(fn.ResultExprs) &gt; 0 {
  1407→		g.builder.WriteString(strings.Repeat(&quot;\t&quot;, g.indent))
  1408→		g.write(&quot;return &quot;)
  1409→		for i, expr := range fn.ResultExprs {
  1410→			if i &gt; 0 {
  1411→				g.write(&quot;, &quot;)
  1412→			}
  1413→			g.generateExpression(expr)
  1414→		}
  1415→		g.write(&quot;\n&quot;)
  1416→	}
  1417→
  1418→	g.nestingLevel--
  1419→	g.indent--
  1420→	g.writeLine(&quot;}&quot;)
  1421→	g.writeLine(&quot;&quot;)
  1422→}
  1423→
  1424→func (g *Generator) generateFuncCallExpr(call *ast.FuncCall) {
  1425→	g.write(call.Name)
  1426→	g.write(&quot;(&quot;)
  1427→	for i, arg := range call.Args {
  1428→		if i &gt; 0 {
  1429→			g.write(&quot;, &quot;)
  1430→		}
  1431→		g.generateExpression(arg)
  1432→	}
  1433→	g.write(&quot;)&quot;)
  1434→}
  1435→
  1436→func (g *Generator) generateMultiAssignment(stmt *ast.MultiAssignment) {
  1437→	g.builder.WriteString(strings.Repeat(&quot;\t&quot;, g.indent))
  1438→	for i, target := range stmt.Targets {
  1439→		if i &gt; 0 {
  1440→			g.write(&quot;, &quot;)
  1441→		}
  1442→		if target.Index != nil {
  1443→			// Check if this is a record field access
  1444→			if _, ok := g.recordVars[target.Name]; ok {
  1445→				if ident, ok := target.Index.(*ast.Identifier); ok {
  1446→					g.write(target.Name)
  1447→					g.write(&quot;.&quot;)
  1448→					g.write(ident.Value)
  1449→					continue
  1450→				}
  1451→			}
  1452→			if g.refParams[target.Name] {
  1453→				g.write(&quot;(*&quot;)
  1454→				g.write(target.Name)
  1455→				g.write(&quot;)&quot;)
  1456→			} else {
  1457→				g.write(target.Name)
  1458→			}
  1459→			g.write(&quot;[&quot;)
  1460→			g.generateExpression(target.Index)
  1461→			g.write(&quot;]&quot;)
  1462→		} else {
  1463→			if g.refParams[target.Name] {
  1464→				g.write(&quot;*&quot;)
  1465→			}
  1466→			g.write(target.Name)
  1467→		}
  1468→	}
  1469→	g.write(&quot; = &quot;)
  1470→	for i, val := range stmt.Values {
  1471→		if i &gt; 0 {
  1472→			g.write(&quot;, &quot;)
  1473→		}
  1474→		g.generateExpression(val)
  1475→	}
  1476→	g.write(&quot;\n&quot;)
  1477→}
  1478→
  1479→func (g *Generator) generatePrintCall(call *ast.ProcCall) {
  1480→	g.builder.WriteString(strings.Repeat(&quot;\t&quot;, g.indent))
  1481→
  1482→	switch call.Name {
  1483→	case &quot;print.int&quot;, &quot;print.string&quot;, &quot;print.bool&quot;:
  1484→		g.write(&quot;fmt.Println(&quot;)
  1485→		if len(call.Args) &gt; 0 {
  1486→			g.generateExpression(call.Args[0])
  1487→		}
  1488→		g.write(&quot;)&quot;)
  1489→	case &quot;print.newline&quot;:
  1490→		g.write(&quot;fmt.Println()&quot;)
  1491→	}
  1492→
  1493→	g.write(&quot;\n&quot;)
  1494→}
  1495→
  1496→func (g *Generator) generateWhileLoop(loop *ast.WhileLoop) {
  1497→	g.builder.WriteString(strings.Repeat(&quot;\t&quot;, g.indent))
  1498→	g.write(&quot;for &quot;)
  1499→	g.generateExpression(loop.Condition)
  1500→	g.write(&quot; {\n&quot;)
  1501→	g.indent++
  1502→
  1503→	if loop.Body != nil {
  1504→		g.generateStatement(loop.Body)
  1505→	}
  1506→
  1507→	g.indent--
  1508→	g.writeLine(&quot;}&quot;)
  1509→}
  1510→
  1511→func (g *Generator) generateIfStatement(stmt *ast.IfStatement) {
  1512→	if stmt.Replicator != nil {
  1513→		// Replicated IF: IF i = start FOR count → for loop with break on first match
  1514→		v := stmt.Replicator.Variable
  1515→		if stmt.Replicator.Step != nil {
  1516→			counter := &quot;_repl_&quot; + v
  1517→			g.builder.WriteString(strings.Repeat(&quot;\t&quot;, g.indent))
  1518→			g.write(fmt.Sprintf(&quot;for %s := 0; %s &lt; &quot;, counter, counter))
  1519→			g.generateExpression(stmt.Replicator.Count)
  1520→			g.write(fmt.Sprintf(&quot;; %s++ {\n&quot;, counter))
  1521→			g.indent++
  1522→			g.builder.WriteString(strings.Repeat(&quot;\t&quot;, g.indent))
  1523→			g.write(fmt.Sprintf(&quot;%s := &quot;, v))
  1524→			g.generateExpression(stmt.Replicator.Start)
  1525→			g.write(fmt.Sprintf(&quot; + %s * &quot;, counter))
  1526→			g.generateExpression(stmt.Replicator.Step)
  1527→			g.write(&quot;\n&quot;)
  1528→		} else {
  1529→			g.builder.WriteString(strings.Repeat(&quot;\t&quot;, g.indent))
  1530→			g.write(fmt.Sprintf(&quot;for %s := &quot;, v))
  1531→			g.generateExpression(stmt.Replicator.Start)
  1532→			g.write(fmt.Sprintf(&quot;; %s &lt; &quot;, v))
  1533→			g.generateExpression(stmt.Replicator.Start)
  1534→			g.write(&quot; + &quot;)
  1535→			g.generateExpression(stmt.Replicator.Count)
  1536→			g.write(fmt.Sprintf(&quot;; %s++ {\n&quot;, v))
  1537→			g.indent++
  1538→		}
  1539→
  1540→		for i, choice := range stmt.Choices {
  1541→			g.builder.WriteString(strings.Repeat(&quot;\t&quot;, g.indent))
  1542→			if i == 0 {
  1543→				g.write(&quot;if &quot;)
  1544→			} else {
  1545→				g.write(&quot;} else if &quot;)
  1546→			}
  1547→			g.generateExpression(choice.Condition)
  1548→			g.write(&quot; {\n&quot;)
  1549→			g.indent++
  1550→
  1551→			if choice.Body != nil {
  1552→				g.generateStatement(choice.Body)
  1553→			}
  1554→			g.writeLine(&quot;break&quot;)
  1555→
  1556→			g.indent--
  1557→		}
  1558→		g.writeLine(&quot;}&quot;)
  1559→
  1560→		g.indent--
  1561→		g.writeLine(&quot;}&quot;)
  1562→	} else {
  1563→		for i, choice := range stmt.Choices {
  1564→			g.builder.WriteString(strings.Repeat(&quot;\t&quot;, g.indent))
  1565→			if i == 0 {
  1566→				g.write(&quot;if &quot;)
  1567→			} else {
  1568→				g.write(&quot;} else if &quot;)
  1569→			}
  1570→			g.generateExpression(choice.Condition)
  1571→			g.write(&quot; {\n&quot;)
  1572→			g.indent++
  1573→
  1574→			if choice.Body != nil {
  1575→				g.generateStatement(choice.Body)
  1576→			}
  1577→
  1578→			g.indent--
  1579→		}
  1580→		g.writeLine(&quot;}&quot;)
  1581→	}
  1582→}
  1583→
  1584→func (g *Generator) generateCaseStatement(stmt *ast.CaseStatement) {
  1585→	g.builder.WriteString(strings.Repeat(&quot;\t&quot;, g.indent))
  1586→	g.write(&quot;switch &quot;)
  1587→	g.generateExpression(stmt.Selector)
  1588→	g.write(&quot; {\n&quot;)
  1589→
  1590→	for _, choice := range stmt.Choices {
  1591→		if choice.IsElse {
  1592→			g.writeLine(&quot;default:&quot;)
  1593→		} else {
  1594→			g.builder.WriteString(strings.Repeat(&quot;\t&quot;, g.indent))
  1595→			g.write(&quot;case &quot;)
  1596→			for i, val := range choice.Values {
  1597→				if i &gt; 0 {
  1598→					g.write(&quot;, &quot;)
  1599→				}
  1600→				g.generateExpression(val)
  1601→			}
  1602→			g.write(&quot;:\n&quot;)
  1603→		}
  1604→		g.indent++
  1605→		if choice.Body != nil {
  1606→			g.generateStatement(choice.Body)
  1607→		}
  1608→		g.indent--
  1609→	}
  1610→
  1611→	g.writeLine(&quot;}&quot;)
  1612→}
  1613→
  1614→func (g *Generator) generateExpression(expr ast.Expression) {
  1615→	switch e := expr.(type) {
  1616→	case *ast.Identifier:
  1617→		g.write(e.Value)
  1618→	case *ast.IntegerLiteral:
  1619→		g.write(fmt.Sprintf(&quot;%d&quot;, e.Value))
  1620→	case *ast.StringLiteral:
  1621→		g.write(fmt.Sprintf(&quot;%q&quot;, e.Value))
  1622→	case *ast.ByteLiteral:
  1623→		g.write(fmt.Sprintf(&quot;byte(%d)&quot;, e.Value))
  1624→	case *ast.BooleanLiteral:
  1625→		if e.Value {
  1626→			g.write(&quot;true&quot;)
  1627→		} else {
  1628→			g.write(&quot;false&quot;)
  1629→		}
  1630→	case *ast.BinaryExpr:
  1631→		g.generateBinaryExpr(e)
  1632→	case *ast.UnaryExpr:
  1633→		g.generateUnaryExpr(e)
  1634→	case *ast.SizeExpr:
  1635→		g.write(&quot;len(&quot;)
  1636→		g.generateExpression(e.Expr)
  1637→		g.write(&quot;)&quot;)
  1638→	case *ast.ParenExpr:
  1639→		g.write(&quot;(&quot;)
  1640→		g.generateExpression(e.Expr)
  1641→		g.write(&quot;)&quot;)
  1642→	case *ast.IndexExpr:
  1643→		// Check if this is a record field access
  1644→		if ident, ok := e.Left.(*ast.Identifier); ok {
  1645→			if _, ok := g.recordVars[ident.Value]; ok {
  1646→				if field, ok := e.Index.(*ast.Identifier); ok {
  1647→					g.generateExpression(e.Left)
  1648→					g.write(&quot;.&quot;)
  1649→					g.write(field.Value)
  1650→					break
  1651→				}
  1652→			}
  1653→		}
  1654→		g.generateExpression(e.Left)
  1655→		g.write(&quot;[&quot;)
  1656→		g.generateExpression(e.Index)
  1657→		g.write(&quot;]&quot;)
  1658→	case *ast.SliceExpr:
  1659→		g.generateExpression(e.Array)
  1660→		g.write(&quot;[&quot;)
  1661→		g.generateExpression(e.Start)
  1662→		g.write(&quot; : &quot;)
  1663→		g.generateExpression(e.Start)
  1664→		g.write(&quot; + &quot;)
  1665→		g.generateExpression(e.Length)
  1666→		g.write(&quot;]&quot;)
  1667→	case *ast.FuncCall:
  1668→		g.generateFuncCallExpr(e)
  1669→	case *ast.TypeConversion:
  1670→		g.write(g.occamTypeToGo(e.TargetType))
  1671→		g.write(&quot;(&quot;)
  1672→		g.generateExpression(e.Expr)
  1673→		g.write(&quot;)&quot;)
  1674→	case *ast.MostExpr:
  1675→		g.generateMostExpr(e)
  1676→	}
  1677→}
  1678→
  1679→func (g *Generator) generateBinaryExpr(expr *ast.BinaryExpr) {
  1680→	g.write(&quot;(&quot;)
  1681→	g.generateExpression(expr.Left)
  1682→	g.write(&quot; &quot;)
  1683→	g.write(g.occamOpToGo(expr.Operator))
  1684→	g.write(&quot; &quot;)
  1685→	g.generateExpression(expr.Right)
  1686→	g.write(&quot;)&quot;)
  1687→}
  1688→
  1689→func (g *Generator) generateUnaryExpr(expr *ast.UnaryExpr) {
  1690→	op := g.occamOpToGo(expr.Operator)
  1691→	g.write(op)
  1692→	if op == &quot;!&quot; || op == &quot;^&quot; {
  1693→		// Go&#x27;s logical NOT and bitwise NOT don&#x27;t need space
  1694→	} else {
  1695→		g.write(&quot; &quot;)
  1696→	}
  1697→	g.generateExpression(expr.Right)
  1698→}
  1699→
  1700→func (g *Generator) occamOpToGo(op string) string {
  1701→	switch op {
  1702→	case &quot;=&quot;:
  1703→		return &quot;==&quot;
  1704→	case &quot;&lt;&gt;&quot;:
  1705→		return &quot;!=&quot;
  1706→	case &quot;AND&quot;:
  1707→		return &quot;&amp;&amp;&quot;
  1708→	case &quot;OR&quot;:
  1709→		return &quot;||&quot;
  1710→	case &quot;NOT&quot;:
  1711→		return &quot;!&quot;
  1712→	case &quot;\\&quot;:
  1713→		return &quot;%&quot;
  1714→	case &quot;AFTER&quot;:
  1715→		return &quot;&gt;&quot;
  1716→	case &quot;/\\&quot;:
  1717→		return &quot;&amp;&quot;
  1718→	case &quot;\\/&quot;:
  1719→		return &quot;|&quot;
  1720→	case &quot;&gt;&lt;&quot;:
  1721→		return &quot;^&quot;
  1722→	case &quot;~&quot;:
  1723→		return &quot;^&quot;
  1724→	case &quot;&lt;&lt;&quot;:
  1725→		return &quot;&lt;&lt;&quot;
  1726→	case &quot;&gt;&gt;&quot;:
  1727→		return &quot;&gt;&gt;&quot;
  1728→	case &quot;PLUS&quot;:
  1729→		return &quot;+&quot;
  1730→	case &quot;MINUS&quot;:
  1731→		return &quot;-&quot;
  1732→	case &quot;TIMES&quot;:
  1733→		return &quot;*&quot;
  1734→	default:
  1735→		return op // +, -, *, /, &lt;, &gt;, &lt;=, &gt;= are the same
  1736→	}
  1737→}
  1738→</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-05-46-833Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-05-46-833Z" class="timestamp-link"><time datetime="2026-02-19T05:05:46.833Z" data-timestamp="2026-02-19T05:05:46.833Z">2026-02-19T05:05:46.833Z</time></a></div><div class="message-content">
<div class="thinking"><div class="thinking-label">Thinking</div><p>Now I have a clear picture of all the files. Let me create task items and implement the changes step by step.</p>
<p>Let me start implementing:</p>
<ol>
<li>AST changes: Change <code>Body</code> from <code>Statement</code> to <code>[]Statement</code> in WhileLoop, IfChoice, CaseChoice, AltCase</li>
<li>Parser changes: Add <code>parseBodyStatements()</code> and update call sites, handle channel direction at call sites</li>
<li>Codegen changes: Update to iterate over body slices</li>
<li>Test updates</li>
</ol>
<p>Let me also check the test files to understand what existing tests look like.</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-05-47-568Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-05-47-568Z" class="timestamp-link"><time datetime="2026-02-19T05:05:47.568Z" data-timestamp="2026-02-19T05:05:47.568Z">2026-02-19T05:05:47.568Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Now let me create the task list and start implementing. Let me also check the test files.</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-05-48-855Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-05-48-855Z" class="timestamp-link"><time datetime="2026-02-19T05:05:48.855Z" data-timestamp="2026-02-19T05:05:48.855Z">2026-02-19T05:05:48.855Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01MGuh8kvSBS9vhZjySXwZRP"><div class="tool-header"><span class="tool-icon">⚙</span> TaskCreate</div><div class="tool-description">Change WhileLoop.Body, IfChoice.Body, CaseChoice.Body, AltCase.Body from Statement to []Statement</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;subject&#34;: &#34;Change Body fields to []Statement in AST&#34;,
  &#34;activeForm&#34;: &#34;Updating AST types&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-05-48-870Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-05-48-870Z" class="timestamp-link"><time datetime="2026-02-19T05:05:48.870Z" data-timestamp="2026-02-19T05:05:48.870Z">2026-02-19T05:05:48.870Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>Task #1 created successfully: Change Body fields to []Statement in AST</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-05-50-405Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-05-50-405Z" class="timestamp-link"><time datetime="2026-02-19T05:05:50.405Z" data-timestamp="2026-02-19T05:05:50.405Z">2026-02-19T05:05:50.405Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01MoqW1mqNJQELEeSDKun6Th"><div class="tool-header"><span class="tool-icon">⚙</span> TaskCreate</div><div class="tool-description">Add parseBodyStatements() helper, update parseWhileLoop, parseIfStatement, parseCaseStatement, parseAltCase. Also handle channel direction at call sites in parseProcCall.</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;subject&#34;: &#34;Add parseBodyStatements() and update parser call sites&#34;,
  &#34;activeForm&#34;: &#34;Updating parser&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-05-50-407Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-05-50-407Z" class="timestamp-link"><time datetime="2026-02-19T05:05:50.407Z" data-timestamp="2026-02-19T05:05:50.407Z">2026-02-19T05:05:50.407Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>Task #2 created successfully: Add parseBodyStatements() and update parser call sites</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-05-51-302Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-05-51-302Z" class="timestamp-link"><time datetime="2026-02-19T05:05:51.302Z" data-timestamp="2026-02-19T05:05:51.302Z">2026-02-19T05:05:51.302Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01TXxGSGkzitoW3rgV5exfTB"><div class="tool-header"><span class="tool-icon">⚙</span> TaskCreate</div><div class="tool-description">Update generators and scanner functions to iterate over []Statement body slices</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;subject&#34;: &#34;Update codegen for body slices&#34;,
  &#34;activeForm&#34;: &#34;Updating codegen&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-05-51-304Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-05-51-304Z" class="timestamp-link"><time datetime="2026-02-19T05:05:51.304Z" data-timestamp="2026-02-19T05:05:51.304Z">2026-02-19T05:05:51.304Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>Task #3 created successfully: Update codegen for body slices</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-05-53-017Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-05-53-017Z" class="timestamp-link"><time datetime="2026-02-19T05:05:53.017Z" data-timestamp="2026-02-19T05:05:53.017Z">2026-02-19T05:05:53.017Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01RYp7gkkrNLVfUS3C1wNfbe"><div class="tool-header"><span class="tool-icon">⚙</span> TaskCreate</div><div class="tool-description">Update existing tests that access .Body, add parser test for multi-statement IF body, channel direction at call site, and e2e tests</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;subject&#34;: &#34;Update tests and add new tests&#34;,
  &#34;activeForm&#34;: &#34;Updating tests&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-05-53-019Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-05-53-019Z" class="timestamp-link"><time datetime="2026-02-19T05:05:53.019Z" data-timestamp="2026-02-19T05:05:53.019Z">2026-02-19T05:05:53.019Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>Task #4 created successfully: Update tests and add new tests</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-05-53-931Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-05-53-931Z" class="timestamp-link"><time datetime="2026-02-19T05:05:53.931Z" data-timestamp="2026-02-19T05:05:53.931Z">2026-02-19T05:05:53.931Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01XTxn1UoCRsekPfudNPRrjc"><div class="tool-header"><span class="tool-icon">⚙</span> TaskCreate</div><div class="tool-description">Run go test ./... to verify everything passes</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;subject&#34;: &#34;Run tests and verify&#34;,
  &#34;activeForm&#34;: &#34;Running tests&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-05-53-942Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-05-53-942Z" class="timestamp-link"><time datetime="2026-02-19T05:05:53.942Z" data-timestamp="2026-02-19T05:05:53.942Z">2026-02-19T05:05:53.942Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>Task #5 created successfully: Run tests and verify</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-05-56-743Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-05-56-743Z" class="timestamp-link"><time datetime="2026-02-19T05:05:56.743Z" data-timestamp="2026-02-19T05:05:56.743Z">2026-02-19T05:05:56.743Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01UufSoLwzzDVkRbR8DuroKD"><div class="tool-header"><span class="tool-icon">⚙</span> TaskUpdate</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;taskId&#34;: &#34;1&#34;,
  &#34;status&#34;: &#34;in_progress&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-05-56-746Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-05-56-746Z" class="timestamp-link"><time datetime="2026-02-19T05:05:56.746Z" data-timestamp="2026-02-19T05:05:56.746Z">2026-02-19T05:05:56.746Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>Updated task #1 status</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-05-59-069Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-05-59-069Z" class="timestamp-link"><time datetime="2026-02-19T05:05:59.069Z" data-timestamp="2026-02-19T05:05:59.069Z">2026-02-19T05:05:59.069Z</time></a></div><div class="message-content">
<div class="assistant-text"><h3>Step 1: AST changes</h3></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-06-01-179Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-06-01-179Z" class="timestamp-link"><time datetime="2026-02-19T05:06:01.179Z" data-timestamp="2026-02-19T05:06:01.179Z">2026-02-19T05:06:01.179Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_01PqcMB2RdcmQZyPSUHynZeq">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">ast.go</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/ast/ast.go</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">// WhileLoop represents a WHILE loop
type WhileLoop struct {
	Token     lexer.Token // the WHILE token
	Condition Expression
	Body      Statement
}</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">// WhileLoop represents a WHILE loop
type WhileLoop struct {
	Token     lexer.Token // the WHILE token
	Condition Expression
	Body      []Statement
}</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-06-01-197Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-06-01-197Z" class="timestamp-link"><time datetime="2026-02-19T05:06:01.197Z" data-timestamp="2026-02-19T05:06:01.197Z">2026-02-19T05:06:01.197Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/ast/ast.go has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-06-02-179Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-06-02-179Z" class="timestamp-link"><time datetime="2026-02-19T05:06:02.179Z" data-timestamp="2026-02-19T05:06:02.179Z">2026-02-19T05:06:02.179Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_01StL7QWv2SwSfjUBDRRwwHk">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">ast.go</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/ast/ast.go</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">type IfChoice struct {
	Condition Expression
	Body      Statement
}</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">type IfChoice struct {
	Condition Expression
	Body      []Statement
}</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-06-02-195Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-06-02-195Z" class="timestamp-link"><time datetime="2026-02-19T05:06:02.195Z" data-timestamp="2026-02-19T05:06:02.195Z">2026-02-19T05:06:02.195Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/ast/ast.go has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-06-03-507Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-06-03-507Z" class="timestamp-link"><time datetime="2026-02-19T05:06:03.507Z" data-timestamp="2026-02-19T05:06:03.507Z">2026-02-19T05:06:03.507Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_01ANPCJu9MZeEaqpfFU4bXWn">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">ast.go</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/ast/ast.go</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">type CaseChoice struct {
	Values []Expression // nil/empty for ELSE
	IsElse bool
	Body   Statement
}</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">type CaseChoice struct {
	Values []Expression // nil/empty for ELSE
	IsElse bool
	Body   []Statement
}</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-06-03-522Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-06-03-522Z" class="timestamp-link"><time datetime="2026-02-19T05:06:03.522Z" data-timestamp="2026-02-19T05:06:03.522Z">2026-02-19T05:06:03.522Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/ast/ast.go has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-06-09-766Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-06-09-766Z" class="timestamp-link"><time datetime="2026-02-19T05:06:09.766Z" data-timestamp="2026-02-19T05:06:09.766Z">2026-02-19T05:06:09.766Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_01Naq8ScLeEcRym9E4bfhyEW">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">ast.go</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/ast/ast.go</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">// AltCase represents a single case in an ALT block
type AltCase struct {
	Guard        Expression // optional guard condition (nil if no guard)
	Channel      string     // channel name
	ChannelIndex Expression // non-nil for cs[i] ? x in ALT
	Variable     string     // variable to receive into
	Body         Statement  // the body to execute
	IsTimer      bool       // true if this is a timer AFTER case
	Timer        string     // timer name (when IsTimer)
	Deadline     Expression // AFTER deadline expression (when IsTimer)
}</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">// AltCase represents a single case in an ALT block
type AltCase struct {
	Guard        Expression  // optional guard condition (nil if no guard)
	Channel      string      // channel name
	ChannelIndex Expression  // non-nil for cs[i] ? x in ALT
	Variable     string      // variable to receive into
	Body         []Statement // the body to execute
	IsTimer      bool        // true if this is a timer AFTER case
	Timer        string      // timer name (when IsTimer)
	Deadline     Expression  // AFTER deadline expression (when IsTimer)
}</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-06-09-781Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-06-09-781Z" class="timestamp-link"><time datetime="2026-02-19T05:06:09.781Z" data-timestamp="2026-02-19T05:06:09.781Z">2026-02-19T05:06:09.781Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/ast/ast.go has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-06-13-363Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-06-13-363Z" class="timestamp-link"><time datetime="2026-02-19T05:06:13.363Z" data-timestamp="2026-02-19T05:06:13.363Z">2026-02-19T05:06:13.363Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01RjVnWfB6eWfYBjQ4jP27sS"><div class="tool-header"><span class="tool-icon">⚙</span> TaskUpdate</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;taskId&#34;: &#34;1&#34;,
  &#34;status&#34;: &#34;completed&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-06-13-367Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-06-13-367Z" class="timestamp-link"><time datetime="2026-02-19T05:06:13.367Z" data-timestamp="2026-02-19T05:06:13.367Z">2026-02-19T05:06:13.367Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>Updated task #1 status</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-06-13-682Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-06-13-682Z" class="timestamp-link"><time datetime="2026-02-19T05:06:13.682Z" data-timestamp="2026-02-19T05:06:13.682Z">2026-02-19T05:06:13.682Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01EeP7wXzSLHWqveHfpinYVf"><div class="tool-header"><span class="tool-icon">⚙</span> TaskUpdate</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;taskId&#34;: &#34;2&#34;,
  &#34;status&#34;: &#34;in_progress&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-06-13-683Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-06-13-683Z" class="timestamp-link"><time datetime="2026-02-19T05:06:13.683Z" data-timestamp="2026-02-19T05:06:13.683Z">2026-02-19T05:06:13.683Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>Updated task #2 status</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-06-16-721Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-06-16-721Z" class="timestamp-link"><time datetime="2026-02-19T05:06:16.721Z" data-timestamp="2026-02-19T05:06:16.721Z">2026-02-19T05:06:16.721Z</time></a></div><div class="message-content">
<div class="assistant-text"><h3>Step 2: Parser changes</h3>
<p>First, add the <code>parseBodyStatements()</code> helper after <code>parseBlockStatements()</code>:</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-06-24-876Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-06-24-876Z" class="timestamp-link"><time datetime="2026-02-19T05:06:24.876Z" data-timestamp="2026-02-19T05:06:24.876Z">2026-02-19T05:06:24.876Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_012hdsYGbAnHKhnEf3xDTzNr">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">parser.go</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/parser/parser.go</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">func (p *Parser) parseProcDecl() *ast.ProcDecl {</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">// parseBodyStatements parses multiple statements inside a branch body
// (IF choice, CASE choice, ALT case, WHILE). Called after the caller has
// consumed the INDENT token and advanced into the body.
// Returns all statements found at this indentation level.
func (p *Parser) parseBodyStatements() []ast.Statement {
	var statements []ast.Statement
	startLevel := p.indentLevel

	for !p.curTokenIs(lexer.EOF) {
		// Skip newlines
		for p.curTokenIs(lexer.NEWLINE) {
			p.nextToken()
		}

		// Handle DEDENT tokens
		for p.curTokenIs(lexer.DEDENT) {
			if p.indentLevel &lt; startLevel {
				return statements
			}
			p.nextToken()
		}

		// Skip any more newlines after DEDENT
		for p.curTokenIs(lexer.NEWLINE) {
			p.nextToken()
		}

		if p.curTokenIs(lexer.EOF) {
			break
		}

		if p.indentLevel &lt; startLevel {
			break
		}

		// Safety guard: record position before parsing to detect no-progress
		prevToken := p.curToken
		prevPeek := p.peekToken

		stmt := p.parseStatement()
		if stmt != nil {
			statements = append(statements, stmt)
		}

		// Advance past the last token of the statement if needed
		if !p.curTokenIs(lexer.NEWLINE) &amp;&amp; !p.curTokenIs(lexer.DEDENT) &amp;&amp; !p.curTokenIs(lexer.EOF) {
			p.nextToken()
		}

		// No-progress guard: if we haven&#39;t moved, break to prevent infinite loop
		if p.curToken == prevToken &amp;&amp; p.peekToken == prevPeek {
			break
		}
	}

	return statements
}

func (p *Parser) parseProcDecl() *ast.ProcDecl {</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-06-24-887Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-06-24-887Z" class="timestamp-link"><time datetime="2026-02-19T05:06:24.887Z" data-timestamp="2026-02-19T05:06:24.887Z">2026-02-19T05:06:24.887Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/parser/parser.go has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-06-28-116Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-06-28-116Z" class="timestamp-link"><time datetime="2026-02-19T05:06:28.116Z" data-timestamp="2026-02-19T05:06:28.116Z">2026-02-19T05:06:28.116Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Now update <code>parseWhileLoop()</code>:</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-06-32-769Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-06-32-769Z" class="timestamp-link"><time datetime="2026-02-19T05:06:32.769Z" data-timestamp="2026-02-19T05:06:32.769Z">2026-02-19T05:06:32.769Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_01WsLuwDLqUn9K5V6cZ3kP4D">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">parser.go</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/parser/parser.go</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">func (p *Parser) parseWhileLoop() *ast.WhileLoop {
	loop := &amp;ast.WhileLoop{Token: p.curToken}

	p.nextToken()
	loop.Condition = p.parseExpression(LOWEST)

	// Skip to next line
	for p.peekTokenIs(lexer.NEWLINE) {
		p.nextToken()
	}

	// Expect INDENT
	if !p.peekTokenIs(lexer.INDENT) {
		p.addError(&#34;expected indented block after WHILE condition&#34;)
		return loop
	}
	p.nextToken() // consume INDENT
	p.nextToken() // move to first statement

	loop.Body = p.parseStatement()

	// Consume until DEDENT
	for !p.curTokenIs(lexer.DEDENT) &amp;&amp; !p.curTokenIs(lexer.EOF) {
		p.nextToken()
	}

	return loop
}</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">func (p *Parser) parseWhileLoop() *ast.WhileLoop {
	loop := &amp;ast.WhileLoop{Token: p.curToken}

	p.nextToken()
	loop.Condition = p.parseExpression(LOWEST)

	// Skip to next line
	for p.peekTokenIs(lexer.NEWLINE) {
		p.nextToken()
	}

	// Expect INDENT
	if !p.peekTokenIs(lexer.INDENT) {
		p.addError(&#34;expected indented block after WHILE condition&#34;)
		return loop
	}
	p.nextToken() // consume INDENT
	p.nextToken() // move to first statement

	loop.Body = p.parseBodyStatements()

	return loop
}</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-06-32-785Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-06-32-785Z" class="timestamp-link"><time datetime="2026-02-19T05:06:32.785Z" data-timestamp="2026-02-19T05:06:32.785Z">2026-02-19T05:06:32.785Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/parser/parser.go has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-06-35-199Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-06-35-199Z" class="timestamp-link"><time datetime="2026-02-19T05:06:35.199Z" data-timestamp="2026-02-19T05:06:35.199Z">2026-02-19T05:06:35.199Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Now update <code>parseIfStatement()</code> — change the body parsing inside the choices loop:</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-06-39-370Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-06-39-370Z" class="timestamp-link"><time datetime="2026-02-19T05:06:39.370Z" data-timestamp="2026-02-19T05:06:39.370Z">2026-02-19T05:06:39.370Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_01ExUkaKrcQiFywcSLQ8uhuC">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">parser.go</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/parser/parser.go</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">		choice := ast.IfChoice{}
		choice.Condition = p.parseExpression(LOWEST)

		// Skip newlines and expect INDENT for body
		for p.peekTokenIs(lexer.NEWLINE) {
			p.nextToken()
		}

		if p.peekTokenIs(lexer.INDENT) {
			p.nextToken() // consume INDENT
			p.nextToken() // move to body
			choice.Body = p.parseStatement()

			// Advance past the last token of the statement if needed
			if !p.curTokenIs(lexer.NEWLINE) &amp;&amp; !p.curTokenIs(lexer.DEDENT) &amp;&amp; !p.curTokenIs(lexer.EOF) {
				p.nextToken()
			}
		}

		stmt.Choices = append(stmt.Choices, choice)
	}

	return stmt
}</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">		choice := ast.IfChoice{}
		choice.Condition = p.parseExpression(LOWEST)

		// Skip newlines and expect INDENT for body
		for p.peekTokenIs(lexer.NEWLINE) {
			p.nextToken()
		}

		if p.peekTokenIs(lexer.INDENT) {
			p.nextToken() // consume INDENT
			p.nextToken() // move to body
			choice.Body = p.parseBodyStatements()
		}

		stmt.Choices = append(stmt.Choices, choice)
	}

	return stmt
}</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-06-39-387Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-06-39-387Z" class="timestamp-link"><time datetime="2026-02-19T05:06:39.387Z" data-timestamp="2026-02-19T05:06:39.387Z">2026-02-19T05:06:39.387Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/parser/parser.go has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-06-44-333Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-06-44-333Z" class="timestamp-link"><time datetime="2026-02-19T05:06:44.333Z" data-timestamp="2026-02-19T05:06:44.333Z">2026-02-19T05:06:44.333Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Now update <code>parseCaseStatement()</code>:</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-06-48-001Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-06-48-001Z" class="timestamp-link"><time datetime="2026-02-19T05:06:48.001Z" data-timestamp="2026-02-19T05:06:48.001Z">2026-02-19T05:06:48.001Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_01BE5GTQLX9NeuDbChiAPnAM">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">parser.go</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/parser/parser.go</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">		// Skip newlines and expect INDENT for body
		for p.peekTokenIs(lexer.NEWLINE) {
			p.nextToken()
		}

		if p.peekTokenIs(lexer.INDENT) {
			p.nextToken() // consume INDENT
			p.nextToken() // move to body
			choice.Body = p.parseStatement()

			// Advance past the last token of the statement if needed
			if !p.curTokenIs(lexer.NEWLINE) &amp;&amp; !p.curTokenIs(lexer.DEDENT) &amp;&amp; !p.curTokenIs(lexer.EOF) {
				p.nextToken()
			}
		}

		stmt.Choices = append(stmt.Choices, choice)
	}

	return stmt
}

// Expression parsing using Pratt parsing</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">		// Skip newlines and expect INDENT for body
		for p.peekTokenIs(lexer.NEWLINE) {
			p.nextToken()
		}

		if p.peekTokenIs(lexer.INDENT) {
			p.nextToken() // consume INDENT
			p.nextToken() // move to body
			choice.Body = p.parseBodyStatements()
		}

		stmt.Choices = append(stmt.Choices, choice)
	}

	return stmt
}

// Expression parsing using Pratt parsing</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-06-48-010Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-06-48-010Z" class="timestamp-link"><time datetime="2026-02-19T05:06:48.010Z" data-timestamp="2026-02-19T05:06:48.010Z">2026-02-19T05:06:48.010Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/parser/parser.go has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-06-50-683Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-06-50-683Z" class="timestamp-link"><time datetime="2026-02-19T05:06:50.683Z" data-timestamp="2026-02-19T05:06:50.683Z">2026-02-19T05:06:50.683Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Now update <code>parseAltCase()</code>:</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-06-53-799Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-06-53-799Z" class="timestamp-link"><time datetime="2026-02-19T05:06:53.799Z" data-timestamp="2026-02-19T05:06:53.799Z">2026-02-19T05:06:53.799Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_015w3mjao5tcgW9R46AWV5h2">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">parser.go</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/parser/parser.go</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">	// Expect INDENT for body
	if !p.peekTokenIs(lexer.INDENT) {
		p.addError(&#34;expected indented body after ALT case&#34;)
		return altCase
	}
	p.nextToken() // consume INDENT
	p.nextToken() // move into body

	// Parse the body (first statement)
	altCase.Body = p.parseStatement()

	// Skip to end of body block
	for !p.curTokenIs(lexer.DEDENT) &amp;&amp; !p.curTokenIs(lexer.EOF) {
		p.nextToken()
	}

	return altCase
}</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">	// Expect INDENT for body
	if !p.peekTokenIs(lexer.INDENT) {
		p.addError(&#34;expected indented body after ALT case&#34;)
		return altCase
	}
	p.nextToken() // consume INDENT
	p.nextToken() // move into body

	altCase.Body = p.parseBodyStatements()

	return altCase
}</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-06-53-805Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-06-53-805Z" class="timestamp-link"><time datetime="2026-02-19T05:06:53.805Z" data-timestamp="2026-02-19T05:06:53.805Z">2026-02-19T05:06:53.805Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/parser/parser.go has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-06-56-989Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-06-56-989Z" class="timestamp-link"><time datetime="2026-02-19T05:06:56.989Z" data-timestamp="2026-02-19T05:06:56.989Z">2026-02-19T05:06:56.989Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Now handle channel direction annotations at call sites in <code>parseProcCall()</code>:</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-07-01-777Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-07-01-777Z" class="timestamp-link"><time datetime="2026-02-19T05:07:01.777Z" data-timestamp="2026-02-19T05:07:01.777Z">2026-02-19T05:07:01.777Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_01CTFa8iSUdcnDoE9EfVs1kn">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">parser.go</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/parser/parser.go</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">	p.nextToken() // move to first arg
	call.Args = append(call.Args, p.parseExpression(LOWEST))

	for p.peekTokenIs(lexer.COMMA) {
		p.nextToken() // consume comma
		p.nextToken() // move to next arg
		call.Args = append(call.Args, p.parseExpression(LOWEST))
	}

	if !p.expectPeek(lexer.RPAREN) {
		return nil
	}

	return call
}

func (p *Parser) parseFuncDecl() *ast.FuncDecl {</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">	p.nextToken() // move to first arg
	call.Args = append(call.Args, p.parseExpression(LOWEST))
	// Consume optional channel direction annotation at call site (e.g., out!)
	if p.peekTokenIs(lexer.SEND) || p.peekTokenIs(lexer.RECEIVE) {
		p.nextToken()
	}

	for p.peekTokenIs(lexer.COMMA) {
		p.nextToken() // consume comma
		p.nextToken() // move to next arg
		call.Args = append(call.Args, p.parseExpression(LOWEST))
		// Consume optional channel direction annotation at call site
		if p.peekTokenIs(lexer.SEND) || p.peekTokenIs(lexer.RECEIVE) {
			p.nextToken()
		}
	}

	if !p.expectPeek(lexer.RPAREN) {
		return nil
	}

	return call
}

func (p *Parser) parseFuncDecl() *ast.FuncDecl {</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-07-01-782Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-07-01-782Z" class="timestamp-link"><time datetime="2026-02-19T05:07:01.782Z" data-timestamp="2026-02-19T05:07:01.782Z">2026-02-19T05:07:01.782Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/parser/parser.go has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-07-04-395Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-07-04-395Z" class="timestamp-link"><time datetime="2026-02-19T05:07:04.395Z" data-timestamp="2026-02-19T05:07:04.395Z">2026-02-19T05:07:04.395Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_013jnNRLz4bk8FBeT12Drw99"><div class="tool-header"><span class="tool-icon">⚙</span> TaskUpdate</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;taskId&#34;: &#34;2&#34;,
  &#34;status&#34;: &#34;completed&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-07-04-398Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-07-04-398Z" class="timestamp-link"><time datetime="2026-02-19T05:07:04.398Z" data-timestamp="2026-02-19T05:07:04.398Z">2026-02-19T05:07:04.398Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>Updated task #2 status</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-07-04-738Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-07-04-738Z" class="timestamp-link"><time datetime="2026-02-19T05:07:04.738Z" data-timestamp="2026-02-19T05:07:04.738Z">2026-02-19T05:07:04.738Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01Ckxpk9fREPwuSiqh8TG8y3"><div class="tool-header"><span class="tool-icon">⚙</span> TaskUpdate</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;taskId&#34;: &#34;3&#34;,
  &#34;status&#34;: &#34;in_progress&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-07-04-740Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-07-04-740Z" class="timestamp-link"><time datetime="2026-02-19T05:07:04.740Z" data-timestamp="2026-02-19T05:07:04.740Z">2026-02-19T05:07:04.740Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>Updated task #3 status</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-07-10-430Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-07-10-430Z" class="timestamp-link"><time datetime="2026-02-19T05:07:10.430Z" data-timestamp="2026-02-19T05:07:10.430Z">2026-02-19T05:07:10.430Z</time></a></div><div class="message-content">
<div class="assistant-text"><h3>Step 3: Codegen changes</h3>
<p>Now I need to update all the places in codegen that access <code>.Body</code> as a single statement to iterate over the slice. Let me create a helper function pattern and update each location.</p>
<p>First, the generators — <code>generateWhileLoop</code>, <code>generateIfStatement</code>, <code>generateCaseStatement</code>, <code>generateAltBlock</code>:</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-07-11-929Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-07-11-929Z" class="timestamp-link"><time datetime="2026-02-19T05:07:11.929Z" data-timestamp="2026-02-19T05:07:11.929Z">2026-02-19T05:07:11.929Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_01JR5QRx16uqHZEycgEA4p2H">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">codegen.go</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/codegen/codegen.go</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">	if loop.Body != nil {
		g.generateStatement(loop.Body)
	}

	g.indent--
	g.writeLine(&#34;}&#34;)
}</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">	for _, s := range loop.Body {
		g.generateStatement(s)
	}

	g.indent--
	g.writeLine(&#34;}&#34;)
}</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-07-11-948Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-07-11-948Z" class="timestamp-link"><time datetime="2026-02-19T05:07:11.948Z" data-timestamp="2026-02-19T05:07:11.948Z">2026-02-19T05:07:11.948Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/codegen/codegen.go has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-07-15-075Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-07-15-075Z" class="timestamp-link"><time datetime="2026-02-19T05:07:15.075Z" data-timestamp="2026-02-19T05:07:15.075Z">2026-02-19T05:07:15.075Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Now update <code>generateIfStatement()</code> — there are two places (replicated and non-replicated):</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-07-23-243Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-07-23-243Z" class="timestamp-link"><time datetime="2026-02-19T05:07:23.243Z" data-timestamp="2026-02-19T05:07:23.243Z">2026-02-19T05:07:23.243Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_01Qb3mjB1wdCjKuXH7bjQiMg">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">codegen.go</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/codegen/codegen.go</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">		for i, choice := range stmt.Choices {
			g.builder.WriteString(strings.Repeat(&#34;\t&#34;, g.indent))
			if i == 0 {
				g.write(&#34;if &#34;)
			} else {
				g.write(&#34;} else if &#34;)
			}
			g.generateExpression(choice.Condition)
			g.write(&#34; {\n&#34;)
			g.indent++

			if choice.Body != nil {
				g.generateStatement(choice.Body)
			}
			g.writeLine(&#34;break&#34;)

			g.indent--
		}
		g.writeLine(&#34;}&#34;)

		g.indent--
		g.writeLine(&#34;}&#34;)
	} else {
		for i, choice := range stmt.Choices {
			g.builder.WriteString(strings.Repeat(&#34;\t&#34;, g.indent))
			if i == 0 {
				g.write(&#34;if &#34;)
			} else {
				g.write(&#34;} else if &#34;)
			}
			g.generateExpression(choice.Condition)
			g.write(&#34; {\n&#34;)
			g.indent++

			if choice.Body != nil {
				g.generateStatement(choice.Body)
			}

			g.indent--
		}
		g.writeLine(&#34;}&#34;)
	}
}</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">		for i, choice := range stmt.Choices {
			g.builder.WriteString(strings.Repeat(&#34;\t&#34;, g.indent))
			if i == 0 {
				g.write(&#34;if &#34;)
			} else {
				g.write(&#34;} else if &#34;)
			}
			g.generateExpression(choice.Condition)
			g.write(&#34; {\n&#34;)
			g.indent++

			for _, s := range choice.Body {
				g.generateStatement(s)
			}
			g.writeLine(&#34;break&#34;)

			g.indent--
		}
		g.writeLine(&#34;}&#34;)

		g.indent--
		g.writeLine(&#34;}&#34;)
	} else {
		for i, choice := range stmt.Choices {
			g.builder.WriteString(strings.Repeat(&#34;\t&#34;, g.indent))
			if i == 0 {
				g.write(&#34;if &#34;)
			} else {
				g.write(&#34;} else if &#34;)
			}
			g.generateExpression(choice.Condition)
			g.write(&#34; {\n&#34;)
			g.indent++

			for _, s := range choice.Body {
				g.generateStatement(s)
			}

			g.indent--
		}
		g.writeLine(&#34;}&#34;)
	}
}</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-07-23-260Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-07-23-260Z" class="timestamp-link"><time datetime="2026-02-19T05:07:23.260Z" data-timestamp="2026-02-19T05:07:23.260Z">2026-02-19T05:07:23.260Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/codegen/codegen.go has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-07-26-043Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-07-26-043Z" class="timestamp-link"><time datetime="2026-02-19T05:07:26.043Z" data-timestamp="2026-02-19T05:07:26.043Z">2026-02-19T05:07:26.043Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Now update <code>generateCaseStatement()</code>:</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-07-27-941Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-07-27-941Z" class="timestamp-link"><time datetime="2026-02-19T05:07:27.941Z" data-timestamp="2026-02-19T05:07:27.941Z">2026-02-19T05:07:27.941Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_012yBSqwkDUZ3fDeRD4gZdnk">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">codegen.go</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/codegen/codegen.go</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">		g.indent++
		if choice.Body != nil {
			g.generateStatement(choice.Body)
		}
		g.indent--
	}

	g.writeLine(&#34;}&#34;)
}</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">		g.indent++
		for _, s := range choice.Body {
			g.generateStatement(s)
		}
		g.indent--
	}

	g.writeLine(&#34;}&#34;)
}</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-07-27-958Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-07-27-958Z" class="timestamp-link"><time datetime="2026-02-19T05:07:27.958Z" data-timestamp="2026-02-19T05:07:27.958Z">2026-02-19T05:07:27.958Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/codegen/codegen.go has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-07-30-671Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-07-30-671Z" class="timestamp-link"><time datetime="2026-02-19T05:07:30.671Z" data-timestamp="2026-02-19T05:07:30.671Z">2026-02-19T05:07:30.671Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Now update <code>generateAltBlock()</code>:</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-07-32-603Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-07-32-603Z" class="timestamp-link"><time datetime="2026-02-19T05:07:32.603Z" data-timestamp="2026-02-19T05:07:32.603Z">2026-02-19T05:07:32.603Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_01U4LJwNHwxnw7gswuViif2F">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">codegen.go</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/codegen/codegen.go</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">		g.indent++
		if c.Body != nil {
			g.generateStatement(c.Body)
		}
		g.indent--
	}
	g.writeLine(&#34;}&#34;)
}

func (g *Generator) generateProcDecl(proc *ast.ProcDecl) {</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">		g.indent++
		for _, s := range c.Body {
			g.generateStatement(s)
		}
		g.indent--
	}
	g.writeLine(&#34;}&#34;)
}

func (g *Generator) generateProcDecl(proc *ast.ProcDecl) {</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-07-32-618Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-07-32-618Z" class="timestamp-link"><time datetime="2026-02-19T05:07:32.618Z" data-timestamp="2026-02-19T05:07:32.618Z">2026-02-19T05:07:32.618Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/codegen/codegen.go has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-07-35-385Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-07-35-385Z" class="timestamp-link"><time datetime="2026-02-19T05:07:35.385Z" data-timestamp="2026-02-19T05:07:35.385Z">2026-02-19T05:07:35.385Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Now update all the scanner functions. Let me update <code>containsPar</code>:</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-07-41-307Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-07-41-307Z" class="timestamp-link"><time datetime="2026-02-19T05:07:41.307Z" data-timestamp="2026-02-19T05:07:41.307Z">2026-02-19T05:07:41.307Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_01EDNn4zxqkHkgtCHrKx6bg5">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">codegen.go</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/codegen/codegen.go</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">	case *ast.AltBlock:
		for _, c := range s.Cases {
			if c.Body != nil &amp;&amp; g.containsPar(c.Body) {
				return true
			}
		}
	case *ast.ProcDecl:
		for _, inner := range s.Body {
			if g.containsPar(inner) {
				return true
			}
		}
	case *ast.FuncDecl:
		for _, inner := range s.Body {
			if g.containsPar(inner) {
				return true
			}
		}
	case *ast.WhileLoop:
		if s.Body != nil &amp;&amp; g.containsPar(s.Body) {
			return true
		}
	case *ast.IfStatement:
		for _, choice := range s.Choices {
			if choice.Body != nil &amp;&amp; g.containsPar(choice.Body) {
				return true
			}
		}
	case *ast.CaseStatement:
		for _, choice := range s.Choices {
			if choice.Body != nil &amp;&amp; g.containsPar(choice.Body) {
				return true
			}
		}
	case *ast.VariantReceive:</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">	case *ast.AltBlock:
		for _, c := range s.Cases {
			for _, inner := range c.Body {
				if g.containsPar(inner) {
					return true
				}
			}
		}
	case *ast.ProcDecl:
		for _, inner := range s.Body {
			if g.containsPar(inner) {
				return true
			}
		}
	case *ast.FuncDecl:
		for _, inner := range s.Body {
			if g.containsPar(inner) {
				return true
			}
		}
	case *ast.WhileLoop:
		for _, inner := range s.Body {
			if g.containsPar(inner) {
				return true
			}
		}
	case *ast.IfStatement:
		for _, choice := range s.Choices {
			for _, inner := range choice.Body {
				if g.containsPar(inner) {
					return true
				}
			}
		}
	case *ast.CaseStatement:
		for _, choice := range s.Choices {
			for _, inner := range choice.Body {
				if g.containsPar(inner) {
					return true
				}
			}
		}
	case *ast.VariantReceive:</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-07-41-324Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-07-41-324Z" class="timestamp-link"><time datetime="2026-02-19T05:07:41.324Z" data-timestamp="2026-02-19T05:07:41.324Z">2026-02-19T05:07:41.324Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/codegen/codegen.go has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-07-43-546Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-07-43-546Z" class="timestamp-link"><time datetime="2026-02-19T05:07:43.546Z" data-timestamp="2026-02-19T05:07:43.546Z">2026-02-19T05:07:43.546Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Now update <code>containsPrint</code>:</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-07-51-782Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-07-51-782Z" class="timestamp-link"><time datetime="2026-02-19T05:07:51.782Z" data-timestamp="2026-02-19T05:07:51.782Z">2026-02-19T05:07:51.782Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_01WPTUtt1Q9JYhzUWyRrP5rA">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">codegen.go</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/codegen/codegen.go</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">	case *ast.AltBlock:
		for _, c := range s.Cases {
			if c.Body != nil &amp;&amp; g.containsPrint(c.Body) {
				return true
			}
		}
	case *ast.ProcDecl:
		for _, inner := range s.Body {
			if g.containsPrint(inner) {
				return true
			}
		}
	case *ast.FuncDecl:
		for _, inner := range s.Body {
			if g.containsPrint(inner) {
				return true
			}
		}
	case *ast.WhileLoop:
		if s.Body != nil &amp;&amp; g.containsPrint(s.Body) {
			return true
		}
	case *ast.IfStatement:
		for _, choice := range s.Choices {
			if choice.Body != nil &amp;&amp; g.containsPrint(choice.Body) {
				return true
			}
		}
	case *ast.CaseStatement:
		for _, choice := range s.Choices {
			if choice.Body != nil &amp;&amp; g.containsPrint(choice.Body) {
				return true
			}
		}
	case *ast.VariantReceive:
		for _, c := range s.Cases {
			if c.Body != nil &amp;&amp; g.containsPrint(c.Body) {
				return true
			}
		}
	}
	return false
}

func (g *Generator) containsTimer</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">	case *ast.AltBlock:
		for _, c := range s.Cases {
			for _, inner := range c.Body {
				if g.containsPrint(inner) {
					return true
				}
			}
		}
	case *ast.ProcDecl:
		for _, inner := range s.Body {
			if g.containsPrint(inner) {
				return true
			}
		}
	case *ast.FuncDecl:
		for _, inner := range s.Body {
			if g.containsPrint(inner) {
				return true
			}
		}
	case *ast.WhileLoop:
		for _, inner := range s.Body {
			if g.containsPrint(inner) {
				return true
			}
		}
	case *ast.IfStatement:
		for _, choice := range s.Choices {
			for _, inner := range choice.Body {
				if g.containsPrint(inner) {
					return true
				}
			}
		}
	case *ast.CaseStatement:
		for _, choice := range s.Choices {
			for _, inner := range choice.Body {
				if g.containsPrint(inner) {
					return true
				}
			}
		}
	case *ast.VariantReceive:
		for _, c := range s.Cases {
			if c.Body != nil &amp;&amp; g.containsPrint(c.Body) {
				return true
			}
		}
	}
	return false
}

func (g *Generator) containsTimer</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-07-51-812Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-07-51-812Z" class="timestamp-link"><time datetime="2026-02-19T05:07:51.812Z" data-timestamp="2026-02-19T05:07:51.812Z">2026-02-19T05:07:51.812Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/codegen/codegen.go has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-07-54-087Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-07-54-087Z" class="timestamp-link"><time datetime="2026-02-19T05:07:54.087Z" data-timestamp="2026-02-19T05:07:54.087Z">2026-02-19T05:07:54.087Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Now update <code>containsTimer</code>:</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-08-01-500Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-08-01-500Z" class="timestamp-link"><time datetime="2026-02-19T05:08:01.500Z" data-timestamp="2026-02-19T05:08:01.500Z">2026-02-19T05:08:01.500Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_01LNvMA3LPXE56yNNc5bEtho">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">codegen.go</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/codegen/codegen.go</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">	case *ast.AltBlock:
		for _, c := range s.Cases {
			if c.IsTimer {
				return true
			}
			if c.Body != nil &amp;&amp; g.containsTimer(c.Body) {
				return true
			}
		}
	case *ast.SeqBlock:
		for _, inner := range s.Statements {
			if g.containsTimer(inner) {
				return true
			}
		}
	case *ast.ParBlock:
		for _, inner := range s.Statements {
			if g.containsTimer(inner) {
				return true
			}
		}
	case *ast.ProcDecl:
		for _, inner := range s.Body {
			if g.containsTimer(inner) {
				return true
			}
		}
	case *ast.FuncDecl:
		for _, inner := range s.Body {
			if g.containsTimer(inner) {
				return true
			}
		}
	case *ast.WhileLoop:
		if s.Body != nil &amp;&amp; g.containsTimer(s.Body) {
			return true
		}
	case *ast.IfStatement:
		for _, choice := range s.Choices {
			if choice.Body != nil &amp;&amp; g.containsTimer(choice.Body) {
				return true
			}
		}
	case *ast.CaseStatement:
		for _, choice := range s.Choices {
			if choice.Body != nil &amp;&amp; g.containsTimer(choice.Body) {
				return true
			}
		}
	case *ast.VariantReceive:
		for _, c := range s.Cases {
			if c.Body != nil &amp;&amp; g.containsTimer(c.Body) {
				return true
			}
		}
	}
	return false
}

func (g *Generator) containsStop</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">	case *ast.AltBlock:
		for _, c := range s.Cases {
			if c.IsTimer {
				return true
			}
			for _, inner := range c.Body {
				if g.containsTimer(inner) {
					return true
				}
			}
		}
	case *ast.SeqBlock:
		for _, inner := range s.Statements {
			if g.containsTimer(inner) {
				return true
			}
		}
	case *ast.ParBlock:
		for _, inner := range s.Statements {
			if g.containsTimer(inner) {
				return true
			}
		}
	case *ast.ProcDecl:
		for _, inner := range s.Body {
			if g.containsTimer(inner) {
				return true
			}
		}
	case *ast.FuncDecl:
		for _, inner := range s.Body {
			if g.containsTimer(inner) {
				return true
			}
		}
	case *ast.WhileLoop:
		for _, inner := range s.Body {
			if g.containsTimer(inner) {
				return true
			}
		}
	case *ast.IfStatement:
		for _, choice := range s.Choices {
			for _, inner := range choice.Body {
				if g.containsTimer(inner) {
					return true
				}
			}
		}
	case *ast.CaseStatement:
		for _, choice := range s.Choices {
			for _, inner := range choice.Body {
				if g.containsTimer(inner) {
					return true
				}
			}
		}
	case *ast.VariantReceive:
		for _, c := range s.Cases {
			if c.Body != nil &amp;&amp; g.containsTimer(c.Body) {
				return true
			}
		}
	}
	return false
}

func (g *Generator) containsStop</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-08-01-516Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-08-01-516Z" class="timestamp-link"><time datetime="2026-02-19T05:08:01.516Z" data-timestamp="2026-02-19T05:08:01.516Z">2026-02-19T05:08:01.516Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/codegen/codegen.go has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-08-03-685Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-08-03-685Z" class="timestamp-link"><time datetime="2026-02-19T05:08:03.685Z" data-timestamp="2026-02-19T05:08:03.685Z">2026-02-19T05:08:03.685Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Now update <code>containsStop</code>:</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-08-09-574Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-08-09-574Z" class="timestamp-link"><time datetime="2026-02-19T05:08:09.574Z" data-timestamp="2026-02-19T05:08:09.574Z">2026-02-19T05:08:09.574Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_01WFnRQ7SWzA2KBJwM8TxHWk">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">codegen.go</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/codegen/codegen.go</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">	case *ast.AltBlock:
		for _, c := range s.Cases {
			if c.Body != nil &amp;&amp; g.containsStop(c.Body) {
				return true
			}
		}
	case *ast.ProcDecl:
		for _, inner := range s.Body {
			if g.containsStop(inner) {
				return true
			}
		}
	case *ast.FuncDecl:
		for _, inner := range s.Body {
			if g.containsStop(inner) {
				return true
			}
		}
	case *ast.WhileLoop:
		if s.Body != nil &amp;&amp; g.containsStop(s.Body) {
			return true
		}
	case *ast.IfStatement:
		for _, choice := range s.Choices {
			if choice.Body != nil &amp;&amp; g.containsStop(choice.Body) {
				return true
			}
		}
	case *ast.CaseStatement:
		for _, choice := range s.Choices {
			if choice.Body != nil &amp;&amp; g.containsStop(choice.Body) {
				return true
			}
		}
	case *ast.VariantReceive:
		for _, c := range s.Cases {
			if c.Body != nil &amp;&amp; g.containsStop(c.Body) {
				return true
			}
		}
	}
	return false
}

func (g *Generator) containsMostExpr</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">	case *ast.AltBlock:
		for _, c := range s.Cases {
			for _, inner := range c.Body {
				if g.containsStop(inner) {
					return true
				}
			}
		}
	case *ast.ProcDecl:
		for _, inner := range s.Body {
			if g.containsStop(inner) {
				return true
			}
		}
	case *ast.FuncDecl:
		for _, inner := range s.Body {
			if g.containsStop(inner) {
				return true
			}
		}
	case *ast.WhileLoop:
		for _, inner := range s.Body {
			if g.containsStop(inner) {
				return true
			}
		}
	case *ast.IfStatement:
		for _, choice := range s.Choices {
			for _, inner := range choice.Body {
				if g.containsStop(inner) {
					return true
				}
			}
		}
	case *ast.CaseStatement:
		for _, choice := range s.Choices {
			for _, inner := range choice.Body {
				if g.containsStop(inner) {
					return true
				}
			}
		}
	case *ast.VariantReceive:
		for _, c := range s.Cases {
			if c.Body != nil &amp;&amp; g.containsStop(c.Body) {
				return true
			}
		}
	}
	return false
}

func (g *Generator) containsMostExpr</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-08-09-581Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-08-09-581Z" class="timestamp-link"><time datetime="2026-02-19T05:08:09.581Z" data-timestamp="2026-02-19T05:08:09.581Z">2026-02-19T05:08:09.581Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/codegen/codegen.go has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-08-12-261Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-08-12-261Z" class="timestamp-link"><time datetime="2026-02-19T05:08:12.261Z" data-timestamp="2026-02-19T05:08:12.261Z">2026-02-19T05:08:12.261Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Now update <code>containsMostExpr</code>:</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-08-17-153Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-08-17-153Z" class="timestamp-link"><time datetime="2026-02-19T05:08:17.153Z" data-timestamp="2026-02-19T05:08:17.153Z">2026-02-19T05:08:17.153Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_01XwZVTpgrCAci5csnuPXEFn">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">codegen.go</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/codegen/codegen.go</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">	case *ast.WhileLoop:
		if g.exprNeedsMath(s.Condition) {
			return true
		}
		if s.Body != nil &amp;&amp; g.containsMostExpr(s.Body) {
			return true
		}
	case *ast.IfStatement:
		for _, choice := range s.Choices {
			if g.exprNeedsMath(choice.Condition) {
				return true
			}
			if choice.Body != nil &amp;&amp; g.containsMostExpr(choice.Body) {
				return true
			}
		}
	case *ast.CaseStatement:
		if g.exprNeedsMath(s.Selector) {
			return true
		}
		for _, choice := range s.Choices {
			for _, v := range choice.Values {
				if g.exprNeedsMath(v) {
					return true
				}
			}
			if choice.Body != nil &amp;&amp; g.containsMostExpr(choice.Body) {
				return true
			}
		}
	case *ast.Send:</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">	case *ast.WhileLoop:
		if g.exprNeedsMath(s.Condition) {
			return true
		}
		for _, inner := range s.Body {
			if g.containsMostExpr(inner) {
				return true
			}
		}
	case *ast.IfStatement:
		for _, choice := range s.Choices {
			if g.exprNeedsMath(choice.Condition) {
				return true
			}
			for _, inner := range choice.Body {
				if g.containsMostExpr(inner) {
					return true
				}
			}
		}
	case *ast.CaseStatement:
		if g.exprNeedsMath(s.Selector) {
			return true
		}
		for _, choice := range s.Choices {
			for _, v := range choice.Values {
				if g.exprNeedsMath(v) {
					return true
				}
			}
			for _, inner := range choice.Body {
				if g.containsMostExpr(inner) {
					return true
				}
			}
		}
	case *ast.Send:</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-08-17-170Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-08-17-170Z" class="timestamp-link"><time datetime="2026-02-19T05:08:17.170Z" data-timestamp="2026-02-19T05:08:17.170Z">2026-02-19T05:08:17.170Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/codegen/codegen.go has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-08-20-068Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-08-20-068Z" class="timestamp-link"><time datetime="2026-02-19T05:08:20.068Z" data-timestamp="2026-02-19T05:08:20.068Z">2026-02-19T05:08:20.068Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Now update <code>containsMostExpr</code> for AltBlock:</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-08-22-980Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-08-22-980Z" class="timestamp-link"><time datetime="2026-02-19T05:08:22.980Z" data-timestamp="2026-02-19T05:08:22.980Z">2026-02-19T05:08:22.980Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_018fPUq6zJTdRttjrijFGirU">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">codegen.go</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/codegen/codegen.go</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">	case *ast.AltBlock:
		for _, c := range s.Cases {
			if c.Body != nil &amp;&amp; g.containsMostExpr(c.Body) {
				return true
			}
		}
	case *ast.VariantReceive:
		for _, c := range s.Cases {
			if c.Body != nil &amp;&amp; g.containsMostExpr(c.Body) {
				return true
			}
		}
	}
	return false
}

func (g *Generator) exprNeedsMath</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">	case *ast.AltBlock:
		for _, c := range s.Cases {
			for _, inner := range c.Body {
				if g.containsMostExpr(inner) {
					return true
				}
			}
		}
	case *ast.VariantReceive:
		for _, c := range s.Cases {
			if c.Body != nil &amp;&amp; g.containsMostExpr(c.Body) {
				return true
			}
		}
	}
	return false
}

func (g *Generator) exprNeedsMath</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-08-22-998Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-08-22-998Z" class="timestamp-link"><time datetime="2026-02-19T05:08:22.998Z" data-timestamp="2026-02-19T05:08:22.998Z">2026-02-19T05:08:22.998Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/codegen/codegen.go has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-08-27-880Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-08-27-880Z" class="timestamp-link"><time datetime="2026-02-19T05:08:27.880Z" data-timestamp="2026-02-19T05:08:27.880Z">2026-02-19T05:08:27.880Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Now update <code>collectChanProtocols</code>:</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-08-32-231Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-08-32-231Z" class="timestamp-link"><time datetime="2026-02-19T05:08:32.231Z" data-timestamp="2026-02-19T05:08:32.231Z">2026-02-19T05:08:32.231Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_01KKdGHbhFKmAwEG29kAai8L">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">codegen.go</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/codegen/codegen.go</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">	case *ast.WhileLoop:
		if s.Body != nil {
			g.collectChanProtocols(s.Body)
		}
	case *ast.IfStatement:
		for _, choice := range s.Choices {
			if choice.Body != nil {
				g.collectChanProtocols(choice.Body)
			}
		}
	case *ast.CaseStatement:
		for _, choice := range s.Choices {
			if choice.Body != nil {
				g.collectChanProtocols(choice.Body)
			}
		}
	case *ast.AltBlock:
		for _, c := range s.Cases {
			if c.Body != nil {
				g.collectChanProtocols(c.Body)
			}
		}
	}
}

func (g *Generator) collectRecordVars</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">	case *ast.WhileLoop:
		for _, inner := range s.Body {
			g.collectChanProtocols(inner)
		}
	case *ast.IfStatement:
		for _, choice := range s.Choices {
			for _, inner := range choice.Body {
				g.collectChanProtocols(inner)
			}
		}
	case *ast.CaseStatement:
		for _, choice := range s.Choices {
			for _, inner := range choice.Body {
				g.collectChanProtocols(inner)
			}
		}
	case *ast.AltBlock:
		for _, c := range s.Cases {
			for _, inner := range c.Body {
				g.collectChanProtocols(inner)
			}
		}
	}
}

func (g *Generator) collectRecordVars</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-08-32-247Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-08-32-247Z" class="timestamp-link"><time datetime="2026-02-19T05:08:32.247Z" data-timestamp="2026-02-19T05:08:32.247Z">2026-02-19T05:08:32.247Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/codegen/codegen.go has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-08-34-564Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-08-34-564Z" class="timestamp-link"><time datetime="2026-02-19T05:08:34.564Z" data-timestamp="2026-02-19T05:08:34.564Z">2026-02-19T05:08:34.564Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Now update <code>collectRecordVars</code>:</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-08-38-576Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-08-38-576Z" class="timestamp-link"><time datetime="2026-02-19T05:08:38.576Z" data-timestamp="2026-02-19T05:08:38.576Z">2026-02-19T05:08:38.576Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_015W2S37BwZ5we3cCvkFAHLb">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">codegen.go</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/codegen/codegen.go</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">	case *ast.WhileLoop:
		if s.Body != nil {
			g.collectRecordVars(s.Body)
		}
	case *ast.IfStatement:
		for _, choice := range s.Choices {
			if choice.Body != nil {
				g.collectRecordVars(choice.Body)
			}
		}
	case *ast.CaseStatement:
		for _, choice := range s.Choices {
			if choice.Body != nil {
				g.collectRecordVars(choice.Body)
			}
		}
	case *ast.AltBlock:
		for _, c := range s.Cases {
			if c.Body != nil {
				g.collectRecordVars(c.Body)
			}
		}
	}
}

func (g *Generator) generateRecordDecl</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">	case *ast.WhileLoop:
		for _, inner := range s.Body {
			g.collectRecordVars(inner)
		}
	case *ast.IfStatement:
		for _, choice := range s.Choices {
			for _, inner := range choice.Body {
				g.collectRecordVars(inner)
			}
		}
	case *ast.CaseStatement:
		for _, choice := range s.Choices {
			for _, inner := range choice.Body {
				g.collectRecordVars(inner)
			}
		}
	case *ast.AltBlock:
		for _, c := range s.Cases {
			for _, inner := range c.Body {
				g.collectRecordVars(inner)
			}
		}
	}
}

func (g *Generator) generateRecordDecl</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-08-38-593Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-08-38-593Z" class="timestamp-link"><time datetime="2026-02-19T05:08:38.593Z" data-timestamp="2026-02-19T05:08:38.593Z">2026-02-19T05:08:38.593Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/codegen/codegen.go has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-08-41-500Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-08-41-500Z" class="timestamp-link"><time datetime="2026-02-19T05:08:41.500Z" data-timestamp="2026-02-19T05:08:41.500Z">2026-02-19T05:08:41.500Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Let me try to build now to see if there are any remaining compile errors:</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-08-42-160Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-08-42-160Z" class="timestamp-link"><time datetime="2026-02-19T05:08:42.160Z" data-timestamp="2026-02-19T05:08:42.160Z">2026-02-19T05:08:42.160Z</time></a></div><div class="message-content">
<div class="tool-use bash-tool" data-tool-id="toolu_018fDzNcdAfVHPa6RZ8oJ2AX">
<div class="tool-header"><span class="tool-icon">$</span> Bash</div>
<div class="tool-description">Check for compile errors</div><div class="truncatable"><div class="truncatable-content"><pre class="bash-command">go build ./... 2&gt;&amp;1</pre></div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-08-42-438Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-08-42-438Z" class="timestamp-link"><time datetime="2026-02-19T05:08:42.438Z" data-timestamp="2026-02-19T05:08:42.438Z">2026-02-19T05:08:42.438Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre></pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-08-45-355Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-08-45-355Z" class="timestamp-link"><time datetime="2026-02-19T05:08:45.355Z" data-timestamp="2026-02-19T05:08:45.355Z">2026-02-19T05:08:45.355Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Clean compile. Now let me update the tests.</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-08-45-844Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-08-45-844Z" class="timestamp-link"><time datetime="2026-02-19T05:08:45.844Z" data-timestamp="2026-02-19T05:08:45.844Z">2026-02-19T05:08:45.844Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_014FQo7iJ5cYU3ndGDvhJDVb"><div class="tool-header"><span class="tool-icon">⚙</span> TaskUpdate</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;taskId&#34;: &#34;3&#34;,
  &#34;status&#34;: &#34;completed&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-08-45-847Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-08-45-847Z" class="timestamp-link"><time datetime="2026-02-19T05:08:45.847Z" data-timestamp="2026-02-19T05:08:45.847Z">2026-02-19T05:08:45.847Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>Updated task #3 status</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-08-46-203Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-08-46-203Z" class="timestamp-link"><time datetime="2026-02-19T05:08:46.203Z" data-timestamp="2026-02-19T05:08:46.203Z">2026-02-19T05:08:46.203Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01Qr1orwcNZyQnem3BPwHVyE"><div class="tool-header"><span class="tool-icon">⚙</span> TaskUpdate</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;taskId&#34;: &#34;4&#34;,
  &#34;status&#34;: &#34;in_progress&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-08-46-204Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-08-46-204Z" class="timestamp-link"><time datetime="2026-02-19T05:08:46.204Z" data-timestamp="2026-02-19T05:08:46.204Z">2026-02-19T05:08:46.204Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>Updated task #4 status</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-08-49-216Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-08-49-216Z" class="timestamp-link"><time datetime="2026-02-19T05:08:49.216Z" data-timestamp="2026-02-19T05:08:49.216Z">2026-02-19T05:08:49.216Z</time></a></div><div class="message-content">
<div class="assistant-text"><h3>Step 4: Update tests</h3>
<p>Let me find all test references to <code>.Body</code> in the test files:</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-08-49-992Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-08-49-992Z" class="timestamp-link"><time datetime="2026-02-19T05:08:49.992Z" data-timestamp="2026-02-19T05:08:49.992Z">2026-02-19T05:08:49.992Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01JWNSfSjhzrtT6SCLEVFKNi"><div class="tool-header"><span class="tool-icon">⚙</span> Grep</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;pattern&#34;: &#34;\\.Body&#34;,
  &#34;glob&#34;: &#34;*_test.go&#34;,
  &#34;output_mode&#34;: &#34;content&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-08-50-118Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-08-50-118Z" class="timestamp-link"><time datetime="2026-02-19T05:08:50.118Z" data-timestamp="2026-02-19T05:08:50.118Z">2026-02-19T05:08:50.118Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>parser/parser_test.go:374:	if loop.Body == nil {
parser/parser_test.go:408:	if ifStmt.Choices[0].Body == nil {
parser/parser_test.go:416:	if ifStmt.Choices[1].Body == nil {
parser/parser_test.go:580:	if ifStmt.Choices[0].Body == nil {
parser/parser_test.go:780:	if len(fn.Body) != 0 {
parser/parser_test.go:781:		t.Errorf(&quot;expected empty body for IS form, got %d statements&quot;, len(fn.Body))
parser/parser_test.go:827:	if len(fn.Body) &lt; 1 {
parser/parser_test.go:871:	if len(fn.Body) &lt; 1 {
parser/parser_test.go:1020:	if caseStmt.Choices[0].Body == nil {
parser/parser_test.go:1028:	if caseStmt.Choices[1].Body == nil {
parser/parser_test.go:1036:	if caseStmt.Choices[2].Body == nil {
parser/parser_test.go:2608:	if len(proc.Body) != 3 {
parser/parser_test.go:2609:		t.Fatalf(&quot;expected 3 body statements, got %d&quot;, len(proc.Body))
parser/parser_test.go:2613:	if _, ok := proc.Body[0].(*ast.VarDecl); !ok {
parser/parser_test.go:2614:		t.Errorf(&quot;expected VarDecl as first body statement, got %T&quot;, proc.Body[0])
parser/parser_test.go:2618:	nestedProc, ok := proc.Body[1].(*ast.ProcDecl)
parser/parser_test.go:2620:		t.Fatalf(&quot;expected nested ProcDecl, got %T&quot;, proc.Body[1])
parser/parser_test.go:2627:	if _, ok := proc.Body[2].(*ast.SeqBlock); !ok {
parser/parser_test.go:2628:		t.Errorf(&quot;expected SeqBlock as third body statement, got %T&quot;, proc.Body[2])
parser/parser_test.go:2654:	if len(proc.Body) != 2 {
parser/parser_test.go:2655:		t.Fatalf(&quot;expected 2 body statements, got %d&quot;, len(proc.Body))
parser/parser_test.go:2658:	fn, ok := proc.Body[0].(*ast.FuncDecl)
parser/parser_test.go:2660:		t.Fatalf(&quot;expected nested FuncDecl, got %T&quot;, proc.Body[0])
parser/parser_test.go:2666:	if _, ok := proc.Body[1].(*ast.SeqBlock); !ok {
parser/parser_test.go:2667:		t.Errorf(&quot;expected SeqBlock as second body statement, got %T&quot;, proc.Body[1])
parser/parser_test.go:2694:	if len(proc.Body) != 3 {
parser/parser_test.go:2695:		t.Fatalf(&quot;expected 3 body statements, got %d&quot;, len(proc.Body))
parser/parser_test.go:2699:		if _, ok := proc.Body[i].(*ast.VarDecl); !ok {
parser/parser_test.go:2700:			t.Errorf(&quot;expected VarDecl at index %d, got %T&quot;, i, proc.Body[i])
parser/parser_test.go:2704:	if _, ok := proc.Body[2].(*ast.SeqBlock); !ok {
parser/parser_test.go:2705:		t.Errorf(&quot;expected SeqBlock at index 2, got %T&quot;, proc.Body[2])</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-08-54-191Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-08-54-191Z" class="timestamp-link"><time datetime="2026-02-19T05:08:54.191Z" data-timestamp="2026-02-19T05:08:54.191Z">2026-02-19T05:08:54.191Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_012bDpg2ByKzxBUcqDNUtE2V"><div class="tool-header"><span class="tool-icon">⚙</span> Read</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;file_path&#34;: &#34;/home/david/projects/code-associates/occam2go/parser/parser_test.go&#34;,
  &#34;offset&#34;: 370,
  &#34;limit&#34;: 60
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-08-54-241Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-08-54-241Z" class="timestamp-link"><time datetime="2026-02-19T05:08:54.241Z" data-timestamp="2026-02-19T05:08:54.241Z">2026-02-19T05:08:54.241Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>   370→	if loop.Condition == nil {
   371→		t.Error(&quot;expected condition&quot;)
   372→	}
   373→
   374→	if loop.Body == nil {
   375→		t.Error(&quot;expected body&quot;)
   376→	}
   377→}
   378→
   379→func TestIfStatement(t *testing.T) {
   380→	input := `IF
   381→  x &gt; 0
   382→    y := 1
   383→  x = 0
   384→    y := 0
   385→`
   386→	l := lexer.New(input)
   387→	p := New(l)
   388→	program := p.ParseProgram()
   389→	checkParserErrors(t, p)
   390→
   391→	if len(program.Statements) != 1 {
   392→		t.Fatalf(&quot;expected 1 statement, got %d&quot;, len(program.Statements))
   393→	}
   394→
   395→	ifStmt, ok := program.Statements[0].(*ast.IfStatement)
   396→	if !ok {
   397→		t.Fatalf(&quot;expected IfStatement, got %T&quot;, program.Statements[0])
   398→	}
   399→
   400→	if len(ifStmt.Choices) != 2 {
   401→		t.Fatalf(&quot;expected 2 choices, got %d&quot;, len(ifStmt.Choices))
   402→	}
   403→
   404→	if ifStmt.Choices[0].Condition == nil {
   405→		t.Error(&quot;expected condition on first choice&quot;)
   406→	}
   407→
   408→	if ifStmt.Choices[0].Body == nil {
   409→		t.Error(&quot;expected body on first choice&quot;)
   410→	}
   411→
   412→	if ifStmt.Choices[1].Condition == nil {
   413→		t.Error(&quot;expected condition on second choice&quot;)
   414→	}
   415→
   416→	if ifStmt.Choices[1].Body == nil {
   417→		t.Error(&quot;expected body on second choice&quot;)
   418→	}
   419→}
   420→
   421→func TestReplicatedSeq(t *testing.T) {
   422→	input := `SEQ i = 0 FOR 5
   423→  print.int(i)
   424→`
   425→	l := lexer.New(input)
   426→	p := New(l)
   427→	program := p.ParseProgram()
   428→	checkParserErrors(t, p)
   429→</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-09-02-801Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-09-02-801Z" class="timestamp-link"><time datetime="2026-02-19T05:09:02.801Z" data-timestamp="2026-02-19T05:09:02.801Z">2026-02-19T05:09:02.801Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01GtPGNi8Nje3uU4fLxKCpNu"><div class="tool-header"><span class="tool-icon">⚙</span> Read</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;file_path&#34;: &#34;/home/david/projects/code-associates/occam2go/parser/parser_test.go&#34;,
  &#34;offset&#34;: 570,
  &#34;limit&#34;: 25
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-09-02-811Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-09-02-811Z" class="timestamp-link"><time datetime="2026-02-19T05:09:02.811Z" data-timestamp="2026-02-19T05:09:02.811Z">2026-02-19T05:09:02.811Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>   570→	}
   571→
   572→	if len(ifStmt.Choices) != 1 {
   573→		t.Fatalf(&quot;expected 1 choice, got %d&quot;, len(ifStmt.Choices))
   574→	}
   575→
   576→	if ifStmt.Choices[0].Condition == nil {
   577→		t.Error(&quot;expected condition on choice&quot;)
   578→	}
   579→
   580→	if ifStmt.Choices[0].Body == nil {
   581→		t.Error(&quot;expected body on choice&quot;)
   582→	}
   583→}
   584→
   585→func TestArrayDecl(t *testing.T) {
   586→	input := `[5]INT arr:
   587→`
   588→	l := lexer.New(input)
   589→	p := New(l)
   590→	program := p.ParseProgram()
   591→	checkParserErrors(t, p)
   592→
   593→	if len(program.Statements) != 1 {
   594→		t.Fatalf(&quot;expected 1 statement, got %d&quot;, len(program.Statements))</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-09-07-437Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-09-07-437Z" class="timestamp-link"><time datetime="2026-02-19T05:09:07.437Z" data-timestamp="2026-02-19T05:09:07.437Z">2026-02-19T05:09:07.437Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01PFfDsXkd8BXfmezaGHq8Mj"><div class="tool-header"><span class="tool-icon">⚙</span> Read</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;file_path&#34;: &#34;/home/david/projects/code-associates/occam2go/parser/parser_test.go&#34;,
  &#34;offset&#34;: 1010,
  &#34;limit&#34;: 40
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-09-07-449Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-09-07-449Z" class="timestamp-link"><time datetime="2026-02-19T05:09:07.449Z" data-timestamp="2026-02-19T05:09:07.449Z">2026-02-19T05:09:07.449Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>  1010→		t.Fatalf(&quot;expected 3 choices, got %d&quot;, len(caseStmt.Choices))
  1011→	}
  1012→
  1013→	// First choice: value 1
  1014→	if caseStmt.Choices[0].IsElse {
  1015→		t.Error(&quot;first choice should not be ELSE&quot;)
  1016→	}
  1017→	if len(caseStmt.Choices[0].Values) != 1 {
  1018→		t.Fatalf(&quot;expected 1 value in first choice, got %d&quot;, len(caseStmt.Choices[0].Values))
  1019→	}
  1020→	if caseStmt.Choices[0].Body == nil {
  1021→		t.Error(&quot;expected body on first choice&quot;)
  1022→	}
  1023→
  1024→	// Second choice: value 2
  1025→	if caseStmt.Choices[1].IsElse {
  1026→		t.Error(&quot;second choice should not be ELSE&quot;)
  1027→	}
  1028→	if caseStmt.Choices[1].Body == nil {
  1029→		t.Error(&quot;expected body on second choice&quot;)
  1030→	}
  1031→
  1032→	// Third choice: ELSE
  1033→	if !caseStmt.Choices[2].IsElse {
  1034→		t.Error(&quot;third choice should be ELSE&quot;)
  1035→	}
  1036→	if caseStmt.Choices[2].Body == nil {
  1037→		t.Error(&quot;expected body on ELSE choice&quot;)
  1038→	}
  1039→}
  1040→
  1041→func TestTimerDecl(t *testing.T) {
  1042→	input := `TIMER tim:
  1043→`
  1044→	l := lexer.New(input)
  1045→	p := New(l)
  1046→	program := p.ParseProgram()
  1047→	checkParserErrors(t, p)
  1048→
  1049→	if len(program.Statements) != 1 {</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-09-10-756Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-09-10-756Z" class="timestamp-link"><time datetime="2026-02-19T05:09:10.756Z" data-timestamp="2026-02-19T05:09:10.756Z">2026-02-19T05:09:10.756Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Now I need to update all <code>Body == nil</code> checks to <code>len(Body) == 0</code> checks. Let me do them all:</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-09-11-962Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-09-11-962Z" class="timestamp-link"><time datetime="2026-02-19T05:09:11.962Z" data-timestamp="2026-02-19T05:09:11.962Z">2026-02-19T05:09:11.962Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_01JNEqnVAuDsFgRrwunXbCh6">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">parser_test.go</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/parser/parser_test.go</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">	if loop.Body == nil {
		t.Error(&#34;expected body&#34;)
	}</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">	if len(loop.Body) == 0 {
		t.Error(&#34;expected body&#34;)
	}</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-09-11-980Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-09-11-980Z" class="timestamp-link"><time datetime="2026-02-19T05:09:11.980Z" data-timestamp="2026-02-19T05:09:11.980Z">2026-02-19T05:09:11.980Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/parser/parser_test.go has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-09-16-143Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-09-16-143Z" class="timestamp-link"><time datetime="2026-02-19T05:09:16.143Z" data-timestamp="2026-02-19T05:09:16.143Z">2026-02-19T05:09:16.143Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_019RCA5gEmG1EVgK84bMwYV6">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">parser_test.go</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/parser/parser_test.go</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">	if ifStmt.Choices[0].Body == nil {
		t.Error(&#34;expected body on first choice&#34;)
	}

	if ifStmt.Choices[1].Condition == nil {
		t.Error(&#34;expected condition on second choice&#34;)
	}

	if ifStmt.Choices[1].Body == nil {
		t.Error(&#34;expected body on second choice&#34;)
	}</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">	if len(ifStmt.Choices[0].Body) == 0 {
		t.Error(&#34;expected body on first choice&#34;)
	}

	if ifStmt.Choices[1].Condition == nil {
		t.Error(&#34;expected condition on second choice&#34;)
	}

	if len(ifStmt.Choices[1].Body) == 0 {
		t.Error(&#34;expected body on second choice&#34;)
	}</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-09-16-158Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-09-16-158Z" class="timestamp-link"><time datetime="2026-02-19T05:09:16.158Z" data-timestamp="2026-02-19T05:09:16.158Z">2026-02-19T05:09:16.158Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/parser/parser_test.go has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-09-20-437Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-09-20-437Z" class="timestamp-link"><time datetime="2026-02-19T05:09:20.437Z" data-timestamp="2026-02-19T05:09:20.437Z">2026-02-19T05:09:20.437Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_01CEw2b6iEbTHZC2D6fYKUFK">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">parser_test.go</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/parser/parser_test.go</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">	if ifStmt.Choices[0].Body == nil {
		t.Error(&#34;expected body on choice&#34;)
	}
}</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">	if len(ifStmt.Choices[0].Body) == 0 {
		t.Error(&#34;expected body on choice&#34;)
	}
}</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-09-20-443Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-09-20-443Z" class="timestamp-link"><time datetime="2026-02-19T05:09:20.443Z" data-timestamp="2026-02-19T05:09:20.443Z">2026-02-19T05:09:20.443Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/parser/parser_test.go has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-09-27-555Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-09-27-555Z" class="timestamp-link"><time datetime="2026-02-19T05:09:27.555Z" data-timestamp="2026-02-19T05:09:27.555Z">2026-02-19T05:09:27.555Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_01T8vC2yDitWpUm3RmBQ3z78">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">parser_test.go</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/parser/parser_test.go</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">	if caseStmt.Choices[0].Body == nil {
		t.Error(&#34;expected body on first choice&#34;)
	}

	// Second choice: value 2
	if caseStmt.Choices[1].IsElse {
		t.Error(&#34;second choice should not be ELSE&#34;)
	}
	if caseStmt.Choices[1].Body == nil {
		t.Error(&#34;expected body on second choice&#34;)
	}

	// Third choice: ELSE
	if !caseStmt.Choices[2].IsElse {
		t.Error(&#34;third choice should be ELSE&#34;)
	}
	if caseStmt.Choices[2].Body == nil {
		t.Error(&#34;expected body on ELSE choice&#34;)
	}</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">	if len(caseStmt.Choices[0].Body) == 0 {
		t.Error(&#34;expected body on first choice&#34;)
	}

	// Second choice: value 2
	if caseStmt.Choices[1].IsElse {
		t.Error(&#34;second choice should not be ELSE&#34;)
	}
	if len(caseStmt.Choices[1].Body) == 0 {
		t.Error(&#34;expected body on second choice&#34;)
	}

	// Third choice: ELSE
	if !caseStmt.Choices[2].IsElse {
		t.Error(&#34;third choice should be ELSE&#34;)
	}
	if len(caseStmt.Choices[2].Body) == 0 {
		t.Error(&#34;expected body on ELSE choice&#34;)
	}</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-09-27-560Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-09-27-560Z" class="timestamp-link"><time datetime="2026-02-19T05:09:27.560Z" data-timestamp="2026-02-19T05:09:27.560Z">2026-02-19T05:09:27.560Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/parser/parser_test.go has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-09-31-197Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-09-31-197Z" class="timestamp-link"><time datetime="2026-02-19T05:09:31.197Z" data-timestamp="2026-02-19T05:09:31.197Z">2026-02-19T05:09:31.197Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Now let me add the new tests. Let me find the end of the parser test file:</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-09-31-786Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-09-31-786Z" class="timestamp-link"><time datetime="2026-02-19T05:09:31.786Z" data-timestamp="2026-02-19T05:09:31.786Z">2026-02-19T05:09:31.786Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_012W5ghtjc21kQYcdUDen4No"><div class="tool-header"><span class="tool-icon">⚙</span> Read</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;file_path&#34;: &#34;/home/david/projects/code-associates/occam2go/parser/parser_test.go&#34;,
  &#34;offset&#34;: 2690
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-09-31-837Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-09-31-837Z" class="timestamp-link"><time datetime="2026-02-19T05:09:31.837Z" data-timestamp="2026-02-19T05:09:31.837Z">2026-02-19T05:09:31.837Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>  2690→		t.Fatalf(&quot;expected ProcDecl, got %T&quot;, program.Statements[0])
  2691→	}
  2692→
  2693→	// Body should have 3 statements: 2 VarDecls + SeqBlock
  2694→	if len(proc.Body) != 3 {
  2695→		t.Fatalf(&quot;expected 3 body statements, got %d&quot;, len(proc.Body))
  2696→	}
  2697→
  2698→	for i := 0; i &lt; 2; i++ {
  2699→		if _, ok := proc.Body[i].(*ast.VarDecl); !ok {
  2700→			t.Errorf(&quot;expected VarDecl at index %d, got %T&quot;, i, proc.Body[i])
  2701→		}
  2702→	}
  2703→
  2704→	if _, ok := proc.Body[2].(*ast.SeqBlock); !ok {
  2705→		t.Errorf(&quot;expected SeqBlock at index 2, got %T&quot;, proc.Body[2])
  2706→	}
  2707→}
  2708→
  2709→func TestCheckedArithmeticOperators(t *testing.T) {
  2710→	tests := []struct {
  2711→		input    string
  2712→		operator string
  2713→	}{
  2714→		{&quot;x := a PLUS b\n&quot;, &quot;PLUS&quot;},
  2715→		{&quot;x := a MINUS b\n&quot;, &quot;MINUS&quot;},
  2716→		{&quot;x := a TIMES b\n&quot;, &quot;TIMES&quot;},
  2717→	}
  2718→
  2719→	for _, tt := range tests {
  2720→		l := lexer.New(tt.input)
  2721→		p := New(l)
  2722→		program := p.ParseProgram()
  2723→		checkParserErrors(t, p)
  2724→
  2725→		if len(program.Statements) != 1 {
  2726→			t.Fatalf(&quot;[%s] expected 1 statement, got %d&quot;, tt.operator, len(program.Statements))
  2727→		}
  2728→
  2729→		assign, ok := program.Statements[0].(*ast.Assignment)
  2730→		if !ok {
  2731→			t.Fatalf(&quot;[%s] expected Assignment, got %T&quot;, tt.operator, program.Statements[0])
  2732→		}
  2733→
  2734→		binExpr, ok := assign.Value.(*ast.BinaryExpr)
  2735→		if !ok {
  2736→			t.Fatalf(&quot;[%s] expected BinaryExpr, got %T&quot;, tt.operator, assign.Value)
  2737→		}
  2738→
  2739→		if binExpr.Operator != tt.operator {
  2740→			t.Errorf(&quot;[%s] expected operator %q, got %q&quot;, tt.operator, tt.operator, binExpr.Operator)
  2741→		}
  2742→	}
  2743→}
  2744→
  2745→func TestCheckedArithmeticPrecedence(t *testing.T) {
  2746→	// a PLUS b TIMES c should parse as a PLUS (b TIMES c)
  2747→	input := &quot;x := a PLUS b TIMES c\n&quot;
  2748→	l := lexer.New(input)
  2749→	p := New(l)
  2750→	program := p.ParseProgram()
  2751→	checkParserErrors(t, p)
  2752→
  2753→	assign := program.Statements[0].(*ast.Assignment)
  2754→	binExpr := assign.Value.(*ast.BinaryExpr)
  2755→
  2756→	if binExpr.Operator != &quot;PLUS&quot; {
  2757→		t.Errorf(&quot;expected top-level operator PLUS, got %s&quot;, binExpr.Operator)
  2758→	}
  2759→
  2760→	rightBin, ok := binExpr.Right.(*ast.BinaryExpr)
  2761→	if !ok {
  2762→		t.Fatalf(&quot;expected right side to be BinaryExpr, got %T&quot;, binExpr.Right)
  2763→	}
  2764→	if rightBin.Operator != &quot;TIMES&quot; {
  2765→		t.Errorf(&quot;expected right operator TIMES, got %s&quot;, rightBin.Operator)
  2766→	}
  2767→}
  2768→
  2769→func TestCheckedAndSymbolMixed(t *testing.T) {
  2770→	// a + (b TIMES c) should work with mixed operators
  2771→	input := &quot;x := a + (b TIMES c)\n&quot;
  2772→	l := lexer.New(input)
  2773→	p := New(l)
  2774→	program := p.ParseProgram()
  2775→	checkParserErrors(t, p)
  2776→
  2777→	assign := program.Statements[0].(*ast.Assignment)
  2778→	binExpr := assign.Value.(*ast.BinaryExpr)
  2779→
  2780→	if binExpr.Operator != &quot;+&quot; {
  2781→		t.Errorf(&quot;expected top-level operator +, got %s&quot;, binExpr.Operator)
  2782→	}
  2783→}
  2784→</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-09-37-018Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-09-37-018Z" class="timestamp-link"><time datetime="2026-02-19T05:09:37.018Z" data-timestamp="2026-02-19T05:09:37.018Z">2026-02-19T05:09:37.018Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Now let me add the new tests at the end of the file:</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-09-51-125Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-09-51-125Z" class="timestamp-link"><time datetime="2026-02-19T05:09:51.125Z" data-timestamp="2026-02-19T05:09:51.125Z">2026-02-19T05:09:51.125Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_013wWMpC4mZZQy6jjPvVHe8J">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">parser_test.go</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/parser/parser_test.go</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">func TestCheckedAndSymbolMixed(t *testing.T) {
	// a + (b TIMES c) should work with mixed operators
	input := &#34;x := a + (b TIMES c)\n&#34;
	l := lexer.New(input)
	p := New(l)
	program := p.ParseProgram()
	checkParserErrors(t, p)

	assign := program.Statements[0].(*ast.Assignment)
	binExpr := assign.Value.(*ast.BinaryExpr)

	if binExpr.Operator != &#34;+&#34; {
		t.Errorf(&#34;expected top-level operator +, got %s&#34;, binExpr.Operator)
	}
}</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">func TestCheckedAndSymbolMixed(t *testing.T) {
	// a + (b TIMES c) should work with mixed operators
	input := &#34;x := a + (b TIMES c)\n&#34;
	l := lexer.New(input)
	p := New(l)
	program := p.ParseProgram()
	checkParserErrors(t, p)

	assign := program.Statements[0].(*ast.Assignment)
	binExpr := assign.Value.(*ast.BinaryExpr)

	if binExpr.Operator != &#34;+&#34; {
		t.Errorf(&#34;expected top-level operator +, got %s&#34;, binExpr.Operator)
	}
}

func TestMultiStatementIfBody(t *testing.T) {
	input := `IF
  x &gt; 0
    INT y:
    y := 42
    print.int(y)
  TRUE
    SKIP
`
	l := lexer.New(input)
	p := New(l)
	program := p.ParseProgram()
	checkParserErrors(t, p)

	if len(program.Statements) != 1 {
		t.Fatalf(&#34;expected 1 statement, got %d&#34;, len(program.Statements))
	}

	ifStmt, ok := program.Statements[0].(*ast.IfStatement)
	if !ok {
		t.Fatalf(&#34;expected IfStatement, got %T&#34;, program.Statements[0])
	}

	if len(ifStmt.Choices) != 2 {
		t.Fatalf(&#34;expected 2 choices, got %d&#34;, len(ifStmt.Choices))
	}

	// First choice should have 3 body statements: VarDecl, Assignment, ProcCall
	if len(ifStmt.Choices[0].Body) != 3 {
		t.Fatalf(&#34;expected 3 body statements in first choice, got %d&#34;, len(ifStmt.Choices[0].Body))
	}
	if _, ok := ifStmt.Choices[0].Body[0].(*ast.VarDecl); !ok {
		t.Errorf(&#34;expected VarDecl as first body stmt, got %T&#34;, ifStmt.Choices[0].Body[0])
	}
	if _, ok := ifStmt.Choices[0].Body[1].(*ast.Assignment); !ok {
		t.Errorf(&#34;expected Assignment as second body stmt, got %T&#34;, ifStmt.Choices[0].Body[1])
	}
	if _, ok := ifStmt.Choices[0].Body[2].(*ast.ProcCall); !ok {
		t.Errorf(&#34;expected ProcCall as third body stmt, got %T&#34;, ifStmt.Choices[0].Body[2])
	}

	// Second choice should have 1 body statement: Skip
	if len(ifStmt.Choices[1].Body) != 1 {
		t.Fatalf(&#34;expected 1 body statement in second choice, got %d&#34;, len(ifStmt.Choices[1].Body))
	}
	if _, ok := ifStmt.Choices[1].Body[0].(*ast.Skip); !ok {
		t.Errorf(&#34;expected Skip, got %T&#34;, ifStmt.Choices[1].Body[0])
	}
}

func TestChannelDirAtCallSite(t *testing.T) {
	input := `foo(out!, in?)
`
	l := lexer.New(input)
	p := New(l)
	program := p.ParseProgram()
	checkParserErrors(t, p)

	if len(program.Statements) != 1 {
		t.Fatalf(&#34;expected 1 statement, got %d&#34;, len(program.Statements))
	}

	call, ok := program.Statements[0].(*ast.ProcCall)
	if !ok {
		t.Fatalf(&#34;expected ProcCall, got %T&#34;, program.Statements[0])
	}

	if call.Name != &#34;foo&#34; {
		t.Errorf(&#34;expected proc name &#39;foo&#39;, got %q&#34;, call.Name)
	}

	if len(call.Args) != 2 {
		t.Fatalf(&#34;expected 2 args, got %d&#34;, len(call.Args))
	}

	arg0, ok := call.Args[0].(*ast.Identifier)
	if !ok {
		t.Fatalf(&#34;expected Identifier for arg 0, got %T&#34;, call.Args[0])
	}
	if arg0.Value != &#34;out&#34; {
		t.Errorf(&#34;expected arg 0 = &#39;out&#39;, got %q&#34;, arg0.Value)
	}

	arg1, ok := call.Args[1].(*ast.Identifier)
	if !ok {
		t.Fatalf(&#34;expected Identifier for arg 1, got %T&#34;, call.Args[1])
	}
	if arg1.Value != &#34;in&#34; {
		t.Errorf(&#34;expected arg 1 = &#39;in&#39;, got %q&#34;, arg1.Value)
	}
}</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-09-51-133Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-09-51-133Z" class="timestamp-link"><time datetime="2026-02-19T05:09:51.133Z" data-timestamp="2026-02-19T05:09:51.133Z">2026-02-19T05:09:51.133Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/parser/parser_test.go has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-09-54-314Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-09-54-314Z" class="timestamp-link"><time datetime="2026-02-19T05:09:54.314Z" data-timestamp="2026-02-19T05:09:54.314Z">2026-02-19T05:09:54.314Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Now let me add e2e tests. Let me check the existing e2e test file:</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-09-55-115Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-09-55-115Z" class="timestamp-link"><time datetime="2026-02-19T05:09:55.115Z" data-timestamp="2026-02-19T05:09:55.115Z">2026-02-19T05:09:55.115Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01Ts2MW4AE4VToFM5TmKu3aN"><div class="tool-header"><span class="tool-icon">⚙</span> Read</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;file_path&#34;: &#34;/home/david/projects/code-associates/occam2go/codegen/e2e_test.go&#34;,
  &#34;offset&#34;: 1,
  &#34;limit&#34;: 30
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-09-55-117Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-09-55-117Z" class="timestamp-link"><time datetime="2026-02-19T05:09:55.117Z" data-timestamp="2026-02-19T05:09:55.117Z">2026-02-19T05:09:55.117Z</time></a></div><div class="message-content"><div class="tool-result tool-error"><div class="truncatable"><div class="truncatable-content"><pre>File does not exist.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-09-58-037Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-09-58-037Z" class="timestamp-link"><time datetime="2026-02-19T05:09:58.037Z" data-timestamp="2026-02-19T05:09:58.037Z">2026-02-19T05:09:58.037Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_015ahdn5xoDx1MeNLJif7ozf"><div class="tool-header"><span class="tool-icon">⚙</span> Glob</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;pattern&#34;: &#34;codegen/*_test.go&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-09-58-156Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-09-58-156Z" class="timestamp-link"><time datetime="2026-02-19T05:09:58.156Z" data-timestamp="2026-02-19T05:09:58.156Z">2026-02-19T05:09:58.156Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>/home/david/projects/code-associates/occam2go/codegen/e2e_concurrency_test.go
/home/david/projects/code-associates/occam2go/codegen/e2e_control_test.go
/home/david/projects/code-associates/occam2go/codegen/e2e_preproc_test.go
/home/david/projects/code-associates/occam2go/codegen/e2e_helpers_test.go
/home/david/projects/code-associates/occam2go/codegen/e2e_protocol_test.go
/home/david/projects/code-associates/occam2go/codegen/e2e_record_test.go
/home/david/projects/code-associates/occam2go/codegen/e2e_proc_func_test.go
/home/david/projects/code-associates/occam2go/codegen/e2e_replicator_test.go
/home/david/projects/code-associates/occam2go/codegen/e2e_array_test.go
/home/david/projects/code-associates/occam2go/codegen/e2e_basic_test.go
/home/david/projects/code-associates/occam2go/codegen/e2e_types_test.go
/home/david/projects/code-associates/occam2go/codegen/codegen_test.go</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-10-02-209Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-10-02-209Z" class="timestamp-link"><time datetime="2026-02-19T05:10:02.209Z" data-timestamp="2026-02-19T05:10:02.209Z">2026-02-19T05:10:02.209Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_019hXNyHQJjVYU8UWLyvnPz9"><div class="tool-header"><span class="tool-icon">⚙</span> Read</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;file_path&#34;: &#34;/home/david/projects/code-associates/occam2go/codegen/e2e_helpers_test.go&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-10-02-219Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-10-02-219Z" class="timestamp-link"><time datetime="2026-02-19T05:10:02.219Z" data-timestamp="2026-02-19T05:10:02.219Z">2026-02-19T05:10:02.219Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>     1→package codegen
     2→
     3→import (
     4→	&quot;os&quot;
     5→	&quot;os/exec&quot;
     6→	&quot;path/filepath&quot;
     7→	&quot;testing&quot;
     8→
     9→	&quot;github.com/codeassociates/occam2go/lexer&quot;
    10→	&quot;github.com/codeassociates/occam2go/parser&quot;
    11→	&quot;github.com/codeassociates/occam2go/preproc&quot;
    12→)
    13→
    14→// transpileCompileRun takes Occam source, transpiles to Go, compiles, runs,
    15→// and returns the stdout output
    16→func transpileCompileRun(t *testing.T, occamSource string) string {
    17→	t.Helper()
    18→
    19→	// Transpile
    20→	l := lexer.New(occamSource)
    21→	p := parser.New(l)
    22→	program := p.ParseProgram()
    23→
    24→	if len(p.Errors()) &gt; 0 {
    25→		for _, err := range p.Errors() {
    26→			t.Errorf(&quot;parser error: %s&quot;, err)
    27→		}
    28→		t.FailNow()
    29→	}
    30→
    31→	gen := New()
    32→	goCode := gen.Generate(program)
    33→
    34→	// Create temp directory for this test
    35→	tmpDir, err := os.MkdirTemp(&quot;&quot;, &quot;occam2go-test-*&quot;)
    36→	if err != nil {
    37→		t.Fatalf(&quot;failed to create temp dir: %v&quot;, err)
    38→	}
    39→	defer os.RemoveAll(tmpDir)
    40→
    41→	// Write Go source
    42→	goFile := filepath.Join(tmpDir, &quot;main.go&quot;)
    43→	if err := os.WriteFile(goFile, []byte(goCode), 0644); err != nil {
    44→		t.Fatalf(&quot;failed to write Go file: %v&quot;, err)
    45→	}
    46→
    47→	// Compile
    48→	binFile := filepath.Join(tmpDir, &quot;main&quot;)
    49→	compileCmd := exec.Command(&quot;go&quot;, &quot;build&quot;, &quot;-o&quot;, binFile, goFile)
    50→	compileOutput, err := compileCmd.CombinedOutput()
    51→	if err != nil {
    52→		t.Fatalf(&quot;compilation failed: %v\nOutput: %s\nGo code:\n%s&quot;, err, compileOutput, goCode)
    53→	}
    54→
    55→	// Run
    56→	runCmd := exec.Command(binFile)
    57→	output, err := runCmd.CombinedOutput()
    58→	if err != nil {
    59→		t.Fatalf(&quot;execution failed: %v\nOutput: %s&quot;, err, output)
    60→	}
    61→
    62→	return string(output)
    63→}
    64→
    65→// transpileCompileRunFromFile takes an occam file path, preprocesses it,
    66→// then transpiles, compiles, and runs.
    67→func transpileCompileRunFromFile(t *testing.T, mainFile string, includePaths []string) string {
    68→	t.Helper()
    69→
    70→	pp := preproc.New(preproc.WithIncludePaths(includePaths))
    71→	expanded, err := pp.ProcessFile(mainFile)
    72→	if err != nil {
    73→		t.Fatalf(&quot;preprocessor error: %v&quot;, err)
    74→	}
    75→	if len(pp.Errors()) &gt; 0 {
    76→		for _, e := range pp.Errors() {
    77→			t.Errorf(&quot;preprocessor warning: %s&quot;, e)
    78→		}
    79→	}
    80→
    81→	return transpileCompileRun(t, expanded)
    82→}
    83→</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-10-06-003Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-10-06-003Z" class="timestamp-link"><time datetime="2026-02-19T05:10:06.003Z" data-timestamp="2026-02-19T05:10:06.003Z">2026-02-19T05:10:06.003Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_019WuqzfyzWvm3KWm7aBkrbX"><div class="tool-header"><span class="tool-icon">⚙</span> Read</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;file_path&#34;: &#34;/home/david/projects/code-associates/occam2go/codegen/e2e_control_test.go&#34;,
  &#34;offset&#34;: 1,
  &#34;limit&#34;: 50
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-10-06-070Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-10-06-070Z" class="timestamp-link"><time datetime="2026-02-19T05:10:06.070Z" data-timestamp="2026-02-19T05:10:06.070Z">2026-02-19T05:10:06.070Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>     1→package codegen
     2→
     3→import &quot;testing&quot;
     4→
     5→func TestE2E_IfBasic(t *testing.T) {
     6→	// Test basic IF: first branch is true
     7→	occam := `SEQ
     8→  INT x, y:
     9→  x := 5
    10→  y := 0
    11→  IF
    12→    x &gt; 0
    13→      y := 1
    14→    x = 0
    15→      y := 2
    16→  print.int(y)
    17→`
    18→	output := transpileCompileRun(t, occam)
    19→	expected := &quot;1\n&quot;
    20→	if output != expected {
    21→		t.Errorf(&quot;expected %q, got %q&quot;, expected, output)
    22→	}
    23→}
    24→
    25→func TestE2E_IfSecondBranch(t *testing.T) {
    26→	// Test IF where second branch matches
    27→	occam := `SEQ
    28→  INT x, y:
    29→  x := 0
    30→  y := 0
    31→  IF
    32→    x &gt; 0
    33→      y := 1
    34→    x = 0
    35→      y := 2
    36→  print.int(y)
    37→`
    38→	output := transpileCompileRun(t, occam)
    39→	expected := &quot;2\n&quot;
    40→	if output != expected {
    41→		t.Errorf(&quot;expected %q, got %q&quot;, expected, output)
    42→	}
    43→}
    44→
    45→func TestE2E_IfThreeBranches(t *testing.T) {
    46→	// Test IF with three choices where the last matches
    47→	occam := `SEQ
    48→  INT x, y:
    49→  x := 0
    50→  y := 0</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-10-11-154Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-10-11-154Z" class="timestamp-link"><time datetime="2026-02-19T05:10:11.154Z" data-timestamp="2026-02-19T05:10:11.154Z">2026-02-19T05:10:11.154Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Good. Now let me add the e2e tests at the end of <code>e2e_control_test.go</code>:</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-10-11-519Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-10-11-519Z" class="timestamp-link"><time datetime="2026-02-19T05:10:11.519Z" data-timestamp="2026-02-19T05:10:11.519Z">2026-02-19T05:10:11.519Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01ANFBksP9uoL3xLuouLqpJD"><div class="tool-header"><span class="tool-icon">⚙</span> Read</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;file_path&#34;: &#34;/home/david/projects/code-associates/occam2go/codegen/e2e_control_test.go&#34;,
  &#34;offset&#34;: 200
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-10-11-531Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-10-11-531Z" class="timestamp-link"><time datetime="2026-02-19T05:10:11.531Z" data-timestamp="2026-02-19T05:10:11.531Z">2026-02-19T05:10:11.531Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>   200→	if output != expected {
   201→		t.Errorf(&quot;expected %q, got %q&quot;, expected, output)
   202→	}
   203→}
   204→</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-10-14-839Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-10-14-839Z" class="timestamp-link"><time datetime="2026-02-19T05:10:14.839Z" data-timestamp="2026-02-19T05:10:14.839Z">2026-02-19T05:10:14.839Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01PSR1qjb6jhQySN8Sw4XkMB"><div class="tool-header"><span class="tool-icon">⚙</span> Read</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;file_path&#34;: &#34;/home/david/projects/code-associates/occam2go/codegen/e2e_control_test.go&#34;,
  &#34;offset&#34;: 180
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-10-14-900Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-10-14-900Z" class="timestamp-link"><time datetime="2026-02-19T05:10:14.900Z" data-timestamp="2026-02-19T05:10:14.900Z">2026-02-19T05:10:14.900Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>   180→	expected := &quot;0\n&quot;
   181→	if output != expected {
   182→		t.Errorf(&quot;expected %q, got %q&quot;, expected, output)
   183→	}
   184→}
   185→
   186→func TestE2E_CaseExpression(t *testing.T) {
   187→	occam := `SEQ
   188→  INT x:
   189→  x := 3
   190→  CASE x + 1
   191→    3
   192→      print.int(30)
   193→    4
   194→      print.int(40)
   195→    ELSE
   196→      print.int(0)
   197→`
   198→	output := transpileCompileRun(t, occam)
   199→	expected := &quot;40\n&quot;
   200→	if output != expected {
   201→		t.Errorf(&quot;expected %q, got %q&quot;, expected, output)
   202→	}
   203→}
   204→</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-10-28-511Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-10-28-511Z" class="timestamp-link"><time datetime="2026-02-19T05:10:28.511Z" data-timestamp="2026-02-19T05:10:28.511Z">2026-02-19T05:10:28.511Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_01R7VSCSNd1vyak62aByBdKf">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">e2e_control_test.go</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/codegen/e2e_control_test.go</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">func TestE2E_CaseExpression(t *testing.T) {
	occam := `SEQ
  INT x:
  x := 3
  CASE x + 1
    3
      print.int(30)
    4
      print.int(40)
    ELSE
      print.int(0)
`
	output := transpileCompileRun(t, occam)
	expected := &#34;40\n&#34;
	if output != expected {
		t.Errorf(&#34;expected %q, got %q&#34;, expected, output)
	}
}</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">func TestE2E_CaseExpression(t *testing.T) {
	occam := `SEQ
  INT x:
  x := 3
  CASE x + 1
    3
      print.int(30)
    4
      print.int(40)
    ELSE
      print.int(0)
`
	output := transpileCompileRun(t, occam)
	expected := &#34;40\n&#34;
	if output != expected {
		t.Errorf(&#34;expected %q, got %q&#34;, expected, output)
	}
}

func TestE2E_MultiStatementIfBody(t *testing.T) {
	occam := `SEQ
  INT x:
  x := 5
  IF
    x &gt; 0
      INT y:
      y := x + 10
      print.int(y)
    TRUE
      SKIP
`
	output := transpileCompileRun(t, occam)
	expected := &#34;15\n&#34;
	if output != expected {
		t.Errorf(&#34;expected %q, got %q&#34;, expected, output)
	}
}

func TestE2E_MultiStatementCaseBody(t *testing.T) {
	occam := `SEQ
  INT x:
  x := 2
  CASE x
    1
      print.int(10)
    2
      INT y:
      y := x * 100
      print.int(y)
    ELSE
      print.int(0)
`
	output := transpileCompileRun(t, occam)
	expected := &#34;200\n&#34;
	if output != expected {
		t.Errorf(&#34;expected %q, got %q&#34;, expected, output)
	}
}

func TestE2E_MultiStatementWhileBody(t *testing.T) {
	occam := `SEQ
  INT x:
  x := 0
  WHILE x &lt; 3
    INT step:
    step := 1
    x := x + step
  print.int(x)
`
	output := transpileCompileRun(t, occam)
	expected := &#34;3\n&#34;
	if output != expected {
		t.Errorf(&#34;expected %q, got %q&#34;, expected, output)
	}
}

func TestE2E_ChannelDirAtCallSite(t *testing.T) {
	occam := `PROC worker(CHAN OF INT in?, CHAN OF INT out!)
  INT x:
  in ? x
  out ! x + 1
:
SEQ
  CHAN OF INT a:
  CHAN OF INT b:
  PAR
    worker(a?, b!)
    SEQ
      a ! 10
      INT result:
      b ? result
      print.int(result)
`
	output := transpileCompileRun(t, occam)
	expected := &#34;11\n&#34;
	if output != expected {
		t.Errorf(&#34;expected %q, got %q&#34;, expected, output)
	}
}</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-10-28-520Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-10-28-520Z" class="timestamp-link"><time datetime="2026-02-19T05:10:28.520Z" data-timestamp="2026-02-19T05:10:28.520Z">2026-02-19T05:10:28.520Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/codegen/e2e_control_test.go has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-10-31-475Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-10-31-475Z" class="timestamp-link"><time datetime="2026-02-19T05:10:31.475Z" data-timestamp="2026-02-19T05:10:31.475Z">2026-02-19T05:10:31.475Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01C1eUhBQrbEim7CcvqXRwRJ"><div class="tool-header"><span class="tool-icon">⚙</span> TaskUpdate</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;taskId&#34;: &#34;4&#34;,
  &#34;status&#34;: &#34;completed&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-10-31-478Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-10-31-478Z" class="timestamp-link"><time datetime="2026-02-19T05:10:31.478Z" data-timestamp="2026-02-19T05:10:31.478Z">2026-02-19T05:10:31.478Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>Updated task #4 status</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-10-31-746Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-10-31-746Z" class="timestamp-link"><time datetime="2026-02-19T05:10:31.746Z" data-timestamp="2026-02-19T05:10:31.746Z">2026-02-19T05:10:31.746Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01R1Yh14V3e5uLWcxbMQ9g3j"><div class="tool-header"><span class="tool-icon">⚙</span> TaskUpdate</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;taskId&#34;: &#34;5&#34;,
  &#34;status&#34;: &#34;in_progress&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-10-31-748Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-10-31-748Z" class="timestamp-link"><time datetime="2026-02-19T05:10:31.748Z" data-timestamp="2026-02-19T05:10:31.748Z">2026-02-19T05:10:31.748Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>Updated task #5 status</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-10-34-358Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-10-34-358Z" class="timestamp-link"><time datetime="2026-02-19T05:10:34.358Z" data-timestamp="2026-02-19T05:10:34.358Z">2026-02-19T05:10:34.358Z</time></a></div><div class="message-content">
<div class="assistant-text"><h3>Step 5: Run tests</h3></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-10-35-102Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-10-35-102Z" class="timestamp-link"><time datetime="2026-02-19T05:10:35.102Z" data-timestamp="2026-02-19T05:10:35.102Z">2026-02-19T05:10:35.102Z</time></a></div><div class="message-content">
<div class="tool-use bash-tool" data-tool-id="toolu_01GiQaPsbKQL8gGKPKmNrQSc">
<div class="tool-header"><span class="tool-icon">$</span> Bash</div>
<div class="tool-description">Run all tests</div><div class="truncatable"><div class="truncatable-content"><pre class="bash-command">go test ./... 2&gt;&amp;1</pre></div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-10-47-281Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-10-47-281Z" class="timestamp-link"><time datetime="2026-02-19T05:10:47.281Z" data-timestamp="2026-02-19T05:10:47.281Z">2026-02-19T05:10:47.281Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>?   	github.com/codeassociates/occam2go	[no test files]
?   	github.com/codeassociates/occam2go/ast	[no test files]
ok  	github.com/codeassociates/occam2go/codegen	9.690s
ok  	github.com/codeassociates/occam2go/lexer	(cached)
ok  	github.com/codeassociates/occam2go/modgen	(cached)
ok  	github.com/codeassociates/occam2go/parser	0.002s
ok  	github.com/codeassociates/occam2go/preproc	(cached)</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-10-50-732Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-10-50-732Z" class="timestamp-link"><time datetime="2026-02-19T05:10:50.732Z" data-timestamp="2026-02-19T05:10:50.732Z">2026-02-19T05:10:50.732Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>All tests pass. Now let me also update the TODO.md as mentioned in the plan:</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-10-51-119Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-10-51-119Z" class="timestamp-link"><time datetime="2026-02-19T05:10:51.119Z" data-timestamp="2026-02-19T05:10:51.119Z">2026-02-19T05:10:51.119Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01QwDPFsEXpVfSj7caRjMZEr"><div class="tool-header"><span class="tool-icon">⚙</span> Read</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;file_path&#34;: &#34;/home/david/projects/code-associates/occam2go/TODO.md&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-10-51-125Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-10-51-125Z" class="timestamp-link"><time datetime="2026-02-19T05:10:51.125Z" data-timestamp="2026-02-19T05:10:51.125Z">2026-02-19T05:10:51.125Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>     1→# occam2go — Implementation Status
     2→
     3→## Fully Implemented
     4→
     5→### Core Constructs
     6→- **SEQ** — Sequential execution, with replicators (`SEQ i = 0 FOR n`) and optional STEP
     7→- **PAR** — Parallel execution via goroutines + sync.WaitGroup, with replicators
     8→- **IF** — Multi-branch conditionals, maps to if/else if chains, with replicators
     9→- **WHILE** — Loops, maps to Go `for` loops
    10→- **CASE** — Pattern matching with multiple cases and ELSE branch
    11→- **ALT** — Channel alternation, maps to Go `select`; supports boolean guards and timer timeouts
    12→- **SKIP** — No-op process
    13→- **STOP** — Error + deadlock
    14→
    15→### Data Types &amp; Declarations
    16→- **INT, BYTE, BOOL, REAL, REAL32, REAL64** — Scalar types (REAL/REAL64 map to float64, REAL32 maps to float32)
    17→- **Variable declarations** — `INT x, y, z:`
    18→- **Arrays** — `[n]TYPE arr:` with index expressions
    19→- **Channels** — `CHAN OF TYPE c:` with send (`!`) and receive (`?`); `CHAN BYTE` shorthand (without `OF`)
    20→- **Channel arrays** — `[n]CHAN OF TYPE cs:` with indexed send/receive and `[]CHAN OF TYPE` proc params
    21→- **Channel direction** — `CHAN OF INT c?` (receive-only) and `CHAN OF INT c!` (send-only)
    22→- **Timers** — `TIMER tim:` with reads and `AFTER` expressions
    23→- **Abbreviations** — `VAL INT x IS 1:`, `INT y IS z:` — named constants and aliases
    24→- **INITIAL declarations** — `INITIAL INT x IS 42:` — mutable variables with initial values
    25→- **Byte literals** — `&#x27;A&#x27;`, `&#x27;0&#x27;` with occam escape sequences (`*n`, `*c`, `*t`)
    26→- **Hex integer literals** — `#FF`, `#80000000`
    27→
    28→### Procedures &amp; Functions
    29→- **PROC** — Declaration with VAL, reference, CHAN OF, and open array (`[]TYPE`) parameters
    30→- **PROC calls** — With automatic `&amp;`/`*` for reference params, pass-through for channels
    31→- **FUNCTION (IS form)** — `INT FUNCTION square(VAL INT x) IS x * x`
    32→- **FUNCTION (VALOF form)** — Local declarations + VALOF body + RESULT
    33→- **Multi-result FUNCTIONs** — `INT, INT FUNCTION f(...)` returning multiple values via `RESULT a, b`
    34→- **Nested PROCs/FUNCTIONs** — Local definitions inside a PROC body, compiled as Go closures
    35→- **KRoC-style colon terminators** — Optional `:` at end of PROC/FUNCTION body
    36→- **Built-in print** — `print.int`, `print.bool`, `print.string`, `print.newline`
    37→
    38→### Expressions &amp; Operators
    39→- **Arithmetic** — `+`, `-`, `*`, `/`, `\` (modulo)
    40→- **Comparison** — `=`, `&lt;&gt;`, `&lt;`, `&gt;`, `&lt;=`, `&gt;=`
    41→- **Logical** — `AND`, `OR`, `NOT`
    42→- **Bitwise** — `/\`, `\/`, `&gt;&lt;`, `~`, `&lt;&lt;`, `&gt;&gt;`
    43→- **AFTER** — As boolean expression (maps to `&gt;`)
    44→- **Parenthesized expressions**
    45→- **Array indexing** — `arr[i]`, `arr[expr]`
    46→- **String literals** — Double-quoted strings
    47→- **Type conversions** — `INT expr`, `BYTE expr`, `REAL32 expr`, `REAL64 expr`
    48→- **Checked arithmetic** — `PLUS`, `MINUS`, `TIMES` — modular (wrapping) operators
    49→- **MOSTNEG/MOSTPOS** — Type min/max constants for INT, BYTE, REAL32, REAL64
    50→- **SIZE operator** — `SIZE arr`, `SIZE &quot;str&quot;` maps to `len()`
    51→- **Array slices** — `[arr FROM n FOR m]` with slice assignment
    52→- **Multi-assignment** — `a, b := f(...)` including indexed targets like `x[0], x[1] := x[1], x[0]`
    53→
    54→### Protocols
    55→- **Simple** — `PROTOCOL SIG IS INT` (type alias)
    56→- **Sequential** — `PROTOCOL PAIR IS INT ; BYTE` (struct)
    57→- **Variant** — `PROTOCOL MSG CASE tag; TYPE ...` (interface + concrete types)
    58→
    59→### Records
    60→- **RECORD** — Struct types with field access via bracket syntax (`p[x]`)
    61→
    62→### Preprocessor
    63→- **`#IF` / `#ELSE` / `#ENDIF`** — Conditional compilation with `TRUE`, `FALSE`, `DEFINED()`, `NOT`, equality
    64→- **`#DEFINE`** — Symbol definition
    65→- **`#INCLUDE`** — File inclusion with search paths and include guards
    66→- **`#COMMENT` / `#PRAGMA` / `#USE`** — Ignored (blank lines)
    67→- **Predefined symbols** — `TARGET.BITS.PER.WORD = 64`
    68→
    69→### Tooling
    70→- **gen-module** — Generate `.module` files from KRoC SConscript build files
    71→
    72→---
    73→
    74→## Not Yet Implemented
    75→
    76→### Required for shared_screen module (extends course module)
    77→
    78→| Feature | Notes | Used in |
    79→|---------|-------|---------|
    80→| **`DATA TYPE X IS TYPE:`** | Simple type alias (e.g. `DATA TYPE COLOUR IS BYTE:`). | shared_screen.inc |
    81→| **`DATA TYPE X RECORD`** | Alternative record syntax (vs current `RECORD X`). | shared_screen.inc |
    82→| **Counted array protocol** | `BYTE::[]BYTE` — length-prefixed array in protocols. | shared_screen.inc, shared_screen.occ |
    83→| **`RESULT` param qualifier** | `RESULT INT len` on PROC params (output-only, like a write-only reference). | float_io.occ |
    84→
    85→### Other language features
    86→
    87→| Feature | Notes |
    88→|---------|-------|
    89→| **PRI ALT / PRI PAR** | Priority variants of ALT and PAR. |
    90→| **PLACED PAR** | Assigning processes to specific hardware. |
    91→| **PORT OF** | Hardware port mapping. |
    92→| **`RETYPES`** | Type punning / reinterpret cast (`VAL INT X RETYPES X :`). Used in float_io.occ. |
    93→| **`CAUSEERROR ()`** | Built-in error-raising primitive. Used in float_io.occ. |
    94→| **Transputer intrinsics** | `LONGPROD`, `LONGDIV`, `LONGSUM`, `LONGDIFF`, `NORMALISE`, `SHIFTLEFT`, `SHIFTRIGHT`. Used in float_io.occ. |
    95→| **`VAL []BYTE` abbreviations** | `VAL []BYTE cmap IS &quot;0123456789ABCDEF&quot;:` — named string constants. |
    96→| **`#PRAGMA DEFINED`** | Compiler hint to suppress definedness warnings. Can be ignored. |
    97→</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-10-57-797Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-10-57-797Z" class="timestamp-link"><time datetime="2026-02-19T05:10:57.797Z" data-timestamp="2026-02-19T05:10:57.797Z">2026-02-19T05:10:57.797Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_01JnvdS4sqzqGtNhLvTDiBfn">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">TODO.md</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/TODO.md</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">- **IF** — Multi-branch conditionals, maps to if/else if chains, with replicators
- **WHILE** — Loops, maps to Go `for` loops
- **CASE** — Pattern matching with multiple cases and ELSE branch
- **ALT** — Channel alternation, maps to Go `select`; supports boolean guards and timer timeouts</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">- **IF** — Multi-branch conditionals, maps to if/else if chains, with replicators; supports multi-statement bodies (declarations scoped before process)
- **WHILE** — Loops, maps to Go `for` loops; supports multi-statement bodies
- **CASE** — Pattern matching with multiple cases and ELSE branch; supports multi-statement bodies
- **ALT** — Channel alternation, maps to Go `select`; supports boolean guards, timer timeouts, and multi-statement bodies</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-10-57-805Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-10-57-805Z" class="timestamp-link"><time datetime="2026-02-19T05:10:57.805Z" data-timestamp="2026-02-19T05:10:57.805Z">2026-02-19T05:10:57.805Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/TODO.md has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-11-02-563Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-11-02-563Z" class="timestamp-link"><time datetime="2026-02-19T05:11:02.563Z" data-timestamp="2026-02-19T05:11:02.563Z">2026-02-19T05:11:02.563Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_019EqepJJTteYMhae3ncTxjG">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">TODO.md</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/TODO.md</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">- **Channel direction** — `CHAN OF INT c?` (receive-only) and `CHAN OF INT c!` (send-only)</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">- **Channel direction** — `CHAN OF INT c?` (receive-only) and `CHAN OF INT c!` (send-only); direction annotations at call sites (`out!`, `in?`) accepted and ignored</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-11-02-569Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-11-02-569Z" class="timestamp-link"><time datetime="2026-02-19T05:11:02.569Z" data-timestamp="2026-02-19T05:11:02.569Z">2026-02-19T05:11:02.569Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/TODO.md has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-11-05-779Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-11-05-779Z" class="timestamp-link"><time datetime="2026-02-19T05:11:05.779Z" data-timestamp="2026-02-19T05:11:05.779Z">2026-02-19T05:11:05.779Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Now update the CLAUDE.md to reflect these changes:</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-11-08-857Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-11-08-857Z" class="timestamp-link"><time datetime="2026-02-19T05:11:08.857Z" data-timestamp="2026-02-19T05:11:08.857Z">2026-02-19T05:11:08.857Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_01MiaJAzcXjdEPiipysjkvXa">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">CLAUDE.md</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/CLAUDE.md</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">| `PROC f(CHAN OF INT c?)` | `func f(c &lt;-chan int)` (input/receive-only) |
| `PROC f(CHAN OF INT c!)` | `func f(c chan&lt;- int)` (output/send-only) |</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">| `PROC f(CHAN OF INT c?)` | `func f(c &lt;-chan int)` (input/receive-only) |
| `PROC f(CHAN OF INT c!)` | `func f(c chan&lt;- int)` (output/send-only) |
| `f(out!, in?)` (call-site dir) | `f(out, in)` (direction annotations ignored) |</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-11-08-857Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-11-08-857Z" class="timestamp-link"><time datetime="2026-02-19T05:11:08.857Z" data-timestamp="2026-02-19T05:11:08.857Z">2026-02-19T05:11:08.857Z</time></a></div><div class="message-content"><div class="tool-result tool-error"><div class="truncatable"><div class="truncatable-content"><pre>&lt;tool_use_error&gt;File has not been read yet. Read it first before writing to it.&lt;/tool_use_error&gt;</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-11-12-696Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-11-12-696Z" class="timestamp-link"><time datetime="2026-02-19T05:11:12.696Z" data-timestamp="2026-02-19T05:11:12.696Z">2026-02-19T05:11:12.696Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01LF4nRtFn6DPMNifyd7mC4E"><div class="tool-header"><span class="tool-icon">⚙</span> Read</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;file_path&#34;: &#34;/home/david/projects/code-associates/occam2go/CLAUDE.md&#34;,
  &#34;offset&#34;: 35,
  &#34;limit&#34;: 30
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-11-12-704Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-11-12-704Z" class="timestamp-link"><time datetime="2026-02-19T05:11:12.704Z" data-timestamp="2026-02-19T05:11:12.704Z">2026-02-19T05:11:12.704Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>    35→
    36→1. **`preproc/`** — Textual preprocessor (pre-lexer pass). Handles `#IF`/`#ELSE`/`#ENDIF`/`#DEFINE` conditional compilation, `#INCLUDE` file inclusion with search paths, and ignores `#COMMENT`/`#PRAGMA`/`#USE`. Produces a single expanded string for the lexer.
    37→   - `preproc.go` — Preprocessor with condition stack and expression evaluator
    38→
    39→2. **`lexer/`** — Tokenizer with indentation tracking. Produces `INDENT`/`DEDENT` tokens from whitespace changes (2-space indent = 1 level). Key files:
    40→   - `token.go` — Token types and keyword lookup
    41→   - `lexer.go` — Lexer with `indentStack` and `pendingTokens` queue
    42→
    43→3. **`parser/`** — Recursive descent parser with Pratt expression parsing. Produces AST.
    44→   - `parser.go` — All parsing logic in one file
    45→
    46→4. **`ast/`** — AST node definitions. Every construct has a struct.
    47→   - `ast.go` — All node types: `Program`, `SeqBlock`, `ParBlock`, `VarDecl`, `Assignment`, `ProcDecl`, `FuncDecl`, etc.
    48→
    49→5. **`codegen/`** — AST → Go source code. Two-pass: first collects metadata (imports, proc signatures), then generates.
    50→   - `codegen.go` — Generator with `strings.Builder` output
    51→   - `codegen_test.go` — Unit tests (transpile, check output strings)
    52→   - `e2e_test.go` — End-to-end tests (transpile → `go build` → execute → check stdout)
    53→
    54→6. **`modgen/`** — Generates `.module` files from KRoC SConscript build files. Parses Python-based SConscript to extract source lists and `OccamLibrary` calls.
    55→   - `modgen.go` — SConscript parser and module file generator
    56→
    57→7. **`main.go`** — CLI entry point wiring the pipeline together
    58→
    59→## Occam → Go Mapping
    60→
    61→| Occam | Go |
    62→|---|---|
    63→| `SEQ` | Sequential statements (Go default) |
    64→| `SEQ i = 0 FOR n` | `for i := 0; i &lt; n; i++` |</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-11-19-669Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-11-19-669Z" class="timestamp-link"><time datetime="2026-02-19T05:11:19.669Z" data-timestamp="2026-02-19T05:11:19.669Z">2026-02-19T05:11:19.669Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_0125pNGEt9LEcq45fEvDe5Vb">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">CLAUDE.md</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/CLAUDE.md</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">| `PROC f(CHAN OF INT c?)` | `func f(c &lt;-chan int)` (input/receive-only) |
| `PROC f(CHAN OF INT c!)` | `func f(c chan&lt;- int)` (output/send-only) |</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">| `PROC f(CHAN OF INT c?)` | `func f(c &lt;-chan int)` (input/receive-only) |
| `PROC f(CHAN OF INT c!)` | `func f(c chan&lt;- int)` (output/send-only) |
| `f(out!, in?)` (call-site dir) | `f(out, in)` (direction annotations ignored) |</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-11-19-687Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-11-19-687Z" class="timestamp-link"><time datetime="2026-02-19T05:11:19.687Z" data-timestamp="2026-02-19T05:11:19.687Z">2026-02-19T05:11:19.687Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/CLAUDE.md has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-11-23-198Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-11-23-198Z" class="timestamp-link"><time datetime="2026-02-19T05:11:23.198Z" data-timestamp="2026-02-19T05:11:23.198Z">2026-02-19T05:11:23.198Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Also update the "What's Implemented" section in CLAUDE.md to mention these features:</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-11-23-925Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-11-23-925Z" class="timestamp-link"><time datetime="2026-02-19T05:11:23.925Z" data-timestamp="2026-02-19T05:11:23.925Z">2026-02-19T05:11:23.925Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01CdtN9Z3HZmvYdML6qLJe2V"><div class="tool-header"><span class="tool-icon">⚙</span> Grep</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;pattern&#34;: &#34;What&#39;s Implemented&#34;,
  &#34;path&#34;: &#34;/home/david/projects/code-associates/occam2go/CLAUDE.md&#34;,
  &#34;output_mode&#34;: &#34;content&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-11-24-057Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-11-24-057Z" class="timestamp-link"><time datetime="2026-02-19T05:11:24.057Z" data-timestamp="2026-02-19T05:11:24.057Z">2026-02-19T05:11:24.057Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>160:## What&#x27;s Implemented</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-11-27-326Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-11-27-326Z" class="timestamp-link"><time datetime="2026-02-19T05:11:27.326Z" data-timestamp="2026-02-19T05:11:27.326Z">2026-02-19T05:11:27.326Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01WQ84uryemqpyFF9DigyLgn"><div class="tool-header"><span class="tool-icon">⚙</span> Read</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;file_path&#34;: &#34;/home/david/projects/code-associates/occam2go/CLAUDE.md&#34;,
  &#34;offset&#34;: 160,
  &#34;limit&#34;: 10
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-11-27-401Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-11-27-401Z" class="timestamp-link"><time datetime="2026-02-19T05:11:27.401Z" data-timestamp="2026-02-19T05:11:27.401Z">2026-02-19T05:11:27.401Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>   160→## What&#x27;s Implemented
   161→
   162→Preprocessor (`#IF`/`#ELSE`/`#ENDIF`/`#DEFINE`/`#INCLUDE` with search paths, include guards, `#COMMENT`/`#PRAGMA`/`#USE` ignored), module file generation from SConscript (`gen-module` subcommand), SEQ, PAR, IF, WHILE, CASE, ALT (with guards and timer timeouts), SKIP, STOP, variable/array/channel/timer declarations, abbreviations (`VAL INT x IS 42:`, `INT y IS z:`), assignments (simple and indexed), channel send/receive, channel arrays (`[n]CHAN OF TYPE` with indexed send/receive and `[]CHAN OF TYPE` proc params), PROC (with VAL, reference, CHAN, []CHAN, and open array `[]TYPE` params), channel direction restrictions (`CHAN OF INT c?` → `&lt;-chan int`, `CHAN OF INT c!` → `chan&lt;- int`), FUNCTION (IS and VALOF forms, including multi-result `INT, INT FUNCTION` with `RESULT a, b`), multi-assignment (`a, b := func(...)` including indexed targets like `x[0], x[1] := x[1], x[0]`), KRoC-style colon terminators on PROC/FUNCTION (optional), replicators on SEQ/PAR/IF (with optional STEP), arithmetic/comparison/logical/AFTER/bitwise operators, type conversions (`INT expr`, `BYTE expr`, `REAL32 expr`, `REAL64 expr`, etc.), REAL32/REAL64 types, hex integer literals (`#FF`, `#80000000`), string literals, byte literals (`&#x27;A&#x27;`, `&#x27;*n&#x27;` with occam escape sequences), built-in print procedures, protocols (simple, sequential, and variant), record types (with field access via bracket syntax), SIZE operator, array slices (`[arr FROM n FOR m]` with slice assignment), nested PROCs/FUNCTIONs (local definitions as Go closures), MOSTNEG/MOSTPOS (type min/max constants for INT, BYTE, REAL32, REAL64), INITIAL declarations (`INITIAL INT x IS 42:` — mutable variable with initial value), checked (modular) arithmetic (`PLUS`, `MINUS`, `TIMES` — wrapping operators).
   163→
   164→## Not Yet Implemented
   165→
   166→PRI ALT/PRI PAR, PLACED PAR, PORT OF. See `TODO.md` for the full list with priorities.
   167→</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-11-32-233Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-11-32-233Z" class="timestamp-link"><time datetime="2026-02-19T05:11:32.233Z" data-timestamp="2026-02-19T05:11:32.233Z">2026-02-19T05:11:32.233Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_01MH865sFCNCGwUFobhdLmb8">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">CLAUDE.md</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/CLAUDE.md</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">channel direction restrictions (`CHAN OF INT c?` → `&lt;-chan int`, `CHAN OF INT c!` → `chan&lt;- int`),</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">channel direction restrictions (`CHAN OF INT c?` → `&lt;-chan int`, `CHAN OF INT c!` → `chan&lt;- int`, call-site annotations `out!`/`in?` accepted),</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-11-32-240Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-11-32-240Z" class="timestamp-link"><time datetime="2026-02-19T05:11:32.240Z" data-timestamp="2026-02-19T05:11:32.240Z">2026-02-19T05:11:32.240Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/CLAUDE.md has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-11-35-801Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-11-35-801Z" class="timestamp-link"><time datetime="2026-02-19T05:11:35.801Z" data-timestamp="2026-02-19T05:11:35.801Z">2026-02-19T05:11:35.801Z</time></a></div><div class="message-content"><div class="file-tool edit-tool" data-tool-id="toolu_01JaV2pfBsW8ZKsAsxyCMTLp">
<div class="file-tool-header edit-header"><span class="file-tool-icon">✏️</span> Edit <span class="file-tool-path">CLAUDE.md</span></div>
<div class="file-tool-fullpath">/home/david/projects/code-associates/occam2go/CLAUDE.md</div>
<div class="truncatable"><div class="truncatable-content">
<div class="edit-section edit-old"><div class="edit-label">−</div><pre class="edit-content">SEQ, PAR, IF, WHILE, CASE, ALT (with guards and timer timeouts),</pre></div>
<div class="edit-section edit-new"><div class="edit-label">+</div><pre class="edit-content">SEQ, PAR, IF, WHILE, CASE, ALT (with guards, timer timeouts, and multi-statement bodies with scoped declarations),</pre></div>
</div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-11-35-815Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-11-35-815Z" class="timestamp-link"><time datetime="2026-02-19T05:11:35.815Z" data-timestamp="2026-02-19T05:11:35.815Z">2026-02-19T05:11:35.815Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>The file /home/david/projects/code-associates/occam2go/CLAUDE.md has been updated successfully.</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-11-39-313Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-11-39-313Z" class="timestamp-link"><time datetime="2026-02-19T05:11:39.313Z" data-timestamp="2026-02-19T05:11:39.313Z">2026-02-19T05:11:39.313Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Let me run the tests one final time to make sure everything is still passing:</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-11-40-147Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-11-40-147Z" class="timestamp-link"><time datetime="2026-02-19T05:11:40.147Z" data-timestamp="2026-02-19T05:11:40.147Z">2026-02-19T05:11:40.147Z</time></a></div><div class="message-content">
<div class="tool-use bash-tool" data-tool-id="toolu_013BLntu1WyVMMPeRWoAJ8hG">
<div class="tool-header"><span class="tool-icon">$</span> Bash</div>
<div class="tool-description">Final test run</div><div class="truncatable"><div class="truncatable-content"><pre class="bash-command">go test ./... 2&gt;&amp;1</pre></div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-11-40-321Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-11-40-321Z" class="timestamp-link"><time datetime="2026-02-19T05:11:40.321Z" data-timestamp="2026-02-19T05:11:40.321Z">2026-02-19T05:11:40.321Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>?   	github.com/codeassociates/occam2go	[no test files]
?   	github.com/codeassociates/occam2go/ast	[no test files]
ok  	github.com/codeassociates/occam2go/codegen	(cached)
ok  	github.com/codeassociates/occam2go/lexer	(cached)
ok  	github.com/codeassociates/occam2go/modgen	(cached)
ok  	github.com/codeassociates/occam2go/parser	(cached)
ok  	github.com/codeassociates/occam2go/preproc	(cached)</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-11-43-278Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-11-43-278Z" class="timestamp-link"><time datetime="2026-02-19T05:11:43.278Z" data-timestamp="2026-02-19T05:11:43.278Z">2026-02-19T05:11:43.278Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>All tests pass. Let me also verify the new tests specifically ran:</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-11-45-644Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-11-45-644Z" class="timestamp-link"><time datetime="2026-02-19T05:11:45.644Z" data-timestamp="2026-02-19T05:11:45.644Z">2026-02-19T05:11:45.644Z</time></a></div><div class="message-content">
<div class="tool-use bash-tool" data-tool-id="toolu_01H8NTWY8G7duUWHU5TgEueX">
<div class="tool-header"><span class="tool-icon">$</span> Bash</div>
<div class="tool-description">Run new tests with verbose output</div><div class="truncatable"><div class="truncatable-content"><pre class="bash-command">go test ./parser -run TestMultiStatementIfBody -v 2&gt;&amp;1 &amp;&amp; go test ./parser -run TestChannelDirAtCallSite -v 2&gt;&amp;1 &amp;&amp; go test ./codegen -run &#34;TestE2E_MultiStatement|TestE2E_ChannelDir&#34; -v 2&gt;&amp;1</pre></div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-11-46-269Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-11-46-269Z" class="timestamp-link"><time datetime="2026-02-19T05:11:46.269Z" data-timestamp="2026-02-19T05:11:46.269Z">2026-02-19T05:11:46.269Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>=== RUN   TestMultiStatementIfBody
--- PASS: TestMultiStatementIfBody (0.00s)
PASS
ok  	github.com/codeassociates/occam2go/parser	0.001s
=== RUN   TestChannelDirAtCallSite
--- PASS: TestChannelDirAtCallSite (0.00s)
PASS
ok  	github.com/codeassociates/occam2go/parser	0.001s
=== RUN   TestE2E_MultiStatementIfBody
--- PASS: TestE2E_MultiStatementIfBody (0.08s)
=== RUN   TestE2E_MultiStatementCaseBody
--- PASS: TestE2E_MultiStatementCaseBody (0.08s)
=== RUN   TestE2E_MultiStatementWhileBody
--- PASS: TestE2E_MultiStatementWhileBody (0.08s)
=== RUN   TestE2E_ChannelDirAtCallSite
--- PASS: TestE2E_ChannelDirAtCallSite (0.08s)
PASS
ok  	github.com/codeassociates/occam2go/codegen	0.316s</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-11-52-364Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-11-52-364Z" class="timestamp-link"><time datetime="2026-02-19T05:11:52.364Z" data-timestamp="2026-02-19T05:11:52.364Z">2026-02-19T05:11:52.364Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>All 6 new tests pass. Let me also quickly verify the binary builds and try the course library scenario from the plan:</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-11-52-913Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-11-52-913Z" class="timestamp-link"><time datetime="2026-02-19T05:11:52.913Z" data-timestamp="2026-02-19T05:11:52.913Z">2026-02-19T05:11:52.913Z</time></a></div><div class="message-content">
<div class="tool-use bash-tool" data-tool-id="toolu_01Q6hKGtHARSh6FUm7CyJEUi">
<div class="tool-header"><span class="tool-icon">$</span> Bash</div>
<div class="tool-description">Build the binary</div><div class="truncatable"><div class="truncatable-content"><pre class="bash-command">go build -o occam2go . 2&gt;&amp;1</pre></div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-11-53-163Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-11-53-163Z" class="timestamp-link"><time datetime="2026-02-19T05:11:53.163Z" data-timestamp="2026-02-19T05:11:53.163Z">2026-02-19T05:11:53.163Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre></pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-11-57-813Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-11-57-813Z" class="timestamp-link"><time datetime="2026-02-19T05:11:57.813Z" data-timestamp="2026-02-19T05:11:57.813Z">2026-02-19T05:11:57.813Z</time></a></div><div class="message-content">
<div class="tool-use bash-tool" data-tool-id="toolu_019YwuyCjv8Ue3MTkbuF6ffg">
<div class="tool-header"><span class="tool-icon">$</span> Bash</div>
<div class="tool-description">Check if course library exists</div><div class="truncatable"><div class="truncatable-content"><pre class="bash-command">ls /home/david/projects/code-associates/occam2go/kroc/modules/course/libsrc/SConscript 2&gt;&amp;1</pre></div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-11-57-988Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-11-57-988Z" class="timestamp-link"><time datetime="2026-02-19T05:11:57.988Z" data-timestamp="2026-02-19T05:11:57.988Z">2026-02-19T05:11:57.988Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>/home/david/projects/code-associates/occam2go/kroc/modules/course/libsrc/SConscript</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-12-01-359Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-12-01-359Z" class="timestamp-link"><time datetime="2026-02-19T05:12:01.359Z" data-timestamp="2026-02-19T05:12:01.359Z">2026-02-19T05:12:01.359Z</time></a></div><div class="message-content">
<div class="tool-use bash-tool" data-tool-id="toolu_017zjThfWUonx65BRjyKYaSc">
<div class="tool-header"><span class="tool-icon">$</span> Bash</div>
<div class="tool-description">Generate course module file</div><div class="truncatable"><div class="truncatable-content"><pre class="bash-command">./occam2go gen-module -o kroc/modules/course/libsrc/course.module kroc/modules/course/libsrc/SConscript 2&gt;&amp;1</pre></div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-12-01-609Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-12-01-609Z" class="timestamp-link"><time datetime="2026-02-19T05:12:01.609Z" data-timestamp="2026-02-19T05:12:01.609Z">2026-02-19T05:12:01.609Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre></pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-12-05-094Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-12-05-094Z" class="timestamp-link"><time datetime="2026-02-19T05:12:05.094Z" data-timestamp="2026-02-19T05:12:05.094Z">2026-02-19T05:12:05.094Z</time></a></div><div class="message-content">
<div class="tool-use bash-tool" data-tool-id="toolu_01FwxghKjhR4xWtPtU2YwgHN">
<div class="tool-header"><span class="tool-icon">$</span> Bash</div>
<div class="tool-description">Check if demo exists</div><div class="truncatable"><div class="truncatable-content"><pre class="bash-command">ls /home/david/projects/code-associates/occam2go/kroc/demos/complexity/concurrent_hello_1.occ 2&gt;&amp;1</pre></div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-12-05-267Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-12-05-267Z" class="timestamp-link"><time datetime="2026-02-19T05:12:05.267Z" data-timestamp="2026-02-19T05:12:05.267Z">2026-02-19T05:12:05.267Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>/home/david/projects/code-associates/occam2go/kroc/demos/complexity/concurrent_hello_1.occ</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-12-10-173Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-12-10-173Z" class="timestamp-link"><time datetime="2026-02-19T05:12:10.173Z" data-timestamp="2026-02-19T05:12:10.173Z">2026-02-19T05:12:10.173Z</time></a></div><div class="message-content">
<div class="tool-use bash-tool" data-tool-id="toolu_015cpgJjySBVjbgEDQqq3H6q">
<div class="tool-header"><span class="tool-icon">$</span> Bash</div>
<div class="tool-description">Try transpiling course library demo</div><div class="truncatable"><div class="truncatable-content"><pre class="bash-command">./occam2go -I kroc/modules/course/libsrc kroc/demos/complexity/concurrent_hello_1.occ 2&gt;&amp;1</pre></div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-15-13-773Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-15-13-773Z" class="timestamp-link"><time datetime="2026-02-19T05:15:13.773Z" data-timestamp="2026-02-19T05:15:13.773Z">2026-02-19T05:15:13.773Z</time></a></div><div class="message-content"><div class="tool-result tool-error"><div class="truncatable"><div class="truncatable-content"><pre>Exit code 137
[Request interrupted by user for tool use]</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message user" id="msg-2026-02-19T05-18-05-947Z"><div class="message-header"><span class="role-label">User</span><a href="#msg-2026-02-19T05-18-05-947Z" class="timestamp-link"><time datetime="2026-02-19T05:18:05.947Z" data-timestamp="2026-02-19T05:18:05.947Z">2026-02-19T05:18:05.947Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Continue from where you left off.</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-18-05-947Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-18-05-947Z" class="timestamp-link"><time datetime="2026-02-19T05:18:05.947Z" data-timestamp="2026-02-19T05:18:05.947Z">2026-02-19T05:18:05.947Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>No response requested.</p></div></div></div>
<div class="message user" id="msg-2026-02-19T05-19-01-628Z"><div class="message-header"><span class="role-label">User</span><a href="#msg-2026-02-19T05-19-01-628Z" class="timestamp-link"><time datetime="2026-02-19T05:19:01.628Z" data-timestamp="2026-02-19T05:19:01.628Z">2026-02-19T05:19:01.628Z</time></a></div><div class="message-content">
<div class="user-content"><p>I think the previous command also leaked memory until the kernel crashed. Would it make sense to commit the current fixes to the repo before moving on to try to diagnose the remaining infinite loop problem?</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-19-06-369Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-19-06-369Z" class="timestamp-link"><time datetime="2026-02-19T05:19:06.369Z" data-timestamp="2026-02-19T05:19:06.369Z">2026-02-19T05:19:06.369Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Yes, that makes sense — let's lock in the working changes first, then investigate the remaining issue separately.</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-19-07-653Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-19-07-653Z" class="timestamp-link"><time datetime="2026-02-19T05:19:07.653Z" data-timestamp="2026-02-19T05:19:07.653Z">2026-02-19T05:19:07.653Z</time></a></div><div class="message-content">
<div class="tool-use bash-tool" data-tool-id="toolu_01C2vVKdQbFda6qCz9USNg6G">
<div class="tool-header"><span class="tool-icon">$</span> Bash</div>
<div class="tool-description">Show working tree status</div><div class="truncatable"><div class="truncatable-content"><pre class="bash-command">git status</pre></div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-19-07-882Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-19-07-882Z" class="timestamp-link"><time datetime="2026-02-19T05:19:07.882Z" data-timestamp="2026-02-19T05:19:07.882Z">2026-02-19T05:19:07.882Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>On branch main
Your branch is up to date with &#x27;origin/main&#x27;.

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)
	modified:   CLAUDE.md
	modified:   TODO.md
	modified:   ast/ast.go
	modified:   codegen/codegen.go
	modified:   codegen/e2e_control_test.go
	modified:   parser/parser.go
	modified:   parser/parser_test.go

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-19-08-152Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-19-08-152Z" class="timestamp-link"><time datetime="2026-02-19T05:19:08.152Z" data-timestamp="2026-02-19T05:19:08.152Z">2026-02-19T05:19:08.152Z</time></a></div><div class="message-content">
<div class="tool-use bash-tool" data-tool-id="toolu_01EYoTWYjCX8NPcXyX6bdoDJ">
<div class="tool-header"><span class="tool-icon">$</span> Bash</div>
<div class="tool-description">Show staged and unstaged changes</div><div class="truncatable"><div class="truncatable-content"><pre class="bash-command">git diff</pre></div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-19-08-296Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-19-08-296Z" class="timestamp-link"><time datetime="2026-02-19T05:19:08.296Z" data-timestamp="2026-02-19T05:19:08.296Z">2026-02-19T05:19:08.296Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>diff --git a/CLAUDE.md b/CLAUDE.md
index e0c5f30..069043a 100644
--- a/CLAUDE.md
+++ b/CLAUDE.md
@@ -107,6 +107,7 @@ Six packages, one pipeline:
 | `PROC f([]CHAN OF INT cs)` | `func f(cs []chan int)` |
 | `PROC f(CHAN OF INT c?)` | `func f(c &lt;-chan int)` (input/receive-only) |
 | `PROC f(CHAN OF INT c!)` | `func f(c chan&lt;- int)` (output/send-only) |
+| `f(out!, in?)` (call-site dir) | `f(out, in)` (direction annotations ignored) |
 | Non-VAL params | `*type` pointer params, callers pass `&amp;arg` |
 | `PROC f([]INT arr)` | `func f(arr []int)` (open array param, slice) |
 | `PROC f(VAL []INT arr)` | `func f(arr []int)` (VAL open array, also slice) |
@@ -158,7 +159,7 @@ Typical workflow for a new language construct:
 
 ## What&#x27;s Implemented
 
-Preprocessor (`#IF`/`#ELSE`/`#ENDIF`/`#DEFINE`/`#INCLUDE` with search paths, include guards, `#COMMENT`/`#PRAGMA`/`#USE` ignored), module file generation from SConscript (`gen-module` subcommand), SEQ, PAR, IF, WHILE, CASE, ALT (with guards and timer timeouts), SKIP, STOP, variable/array/channel/timer declarations, abbreviations (`VAL INT x IS 42:`, `INT y IS z:`), assignments (simple and indexed), channel send/receive, channel arrays (`[n]CHAN OF TYPE` with indexed send/receive and `[]CHAN OF TYPE` proc params), PROC (with VAL, reference, CHAN, []CHAN, and open array `[]TYPE` params), channel direction restrictions (`CHAN OF INT c?` → `&lt;-chan int`, `CHAN OF INT c!` → `chan&lt;- int`), FUNCTION (IS and VALOF forms, including multi-result `INT, INT FUNCTION` with `RESULT a, b`), multi-assignment (`a, b := func(...)` including indexed targets like `x[0], x[1] := x[1], x[0]`), KRoC-style colon terminators on PROC/FUNCTION (optional), replicators on SEQ/PAR/IF (with optional STEP), arithmetic/comparison/logical/AFTER/bitwise operators, type conversions (`INT expr`, `BYTE expr`, `REAL32 expr`, `REAL64 expr`, etc.), REAL32/REAL64 types, hex integer literals (`#FF`, `#80000000`), string literals, byte literals (`&#x27;A&#x27;`, `&#x27;*n&#x27;` with occam escape sequences), built-in print procedures, protocols (simple, sequential, and variant), record types (with field access via bracket syntax), SIZE operator, array slices (`[arr FROM n FOR m]` with slice assignment), nested PROCs/FUNCTIONs (local definitions as Go closures), MOSTNEG/MOSTPOS (type min/max constants for INT, BYTE, REAL32, REAL64), INITIAL declarations (`INITIAL INT x IS 42:` — mutable variable with initial value), checked (modular) arithmetic (`PLUS`, `MINUS`, `TIMES` — wrapping operators).
+Preprocessor (`#IF`/`#ELSE`/`#ENDIF`/`#DEFINE`/`#INCLUDE` with search paths, include guards, `#COMMENT`/`#PRAGMA`/`#USE` ignored), module file generation from SConscript (`gen-module` subcommand), SEQ, PAR, IF, WHILE, CASE, ALT (with guards, timer timeouts, and multi-statement bodies with scoped declarations), SKIP, STOP, variable/array/channel/timer declarations, abbreviations (`VAL INT x IS 42:`, `INT y IS z:`), assignments (simple and indexed), channel send/receive, channel arrays (`[n]CHAN OF TYPE` with indexed send/receive and `[]CHAN OF TYPE` proc params), PROC (with VAL, reference, CHAN, []CHAN, and open array `[]TYPE` params), channel direction restrictions (`CHAN OF INT c?` → `&lt;-chan int`, `CHAN OF INT c!` → `chan&lt;- int`, call-site annotations `out!`/`in?` accepted), FUNCTION (IS and VALOF forms, including multi-result `INT, INT FUNCTION` with `RESULT a, b`), multi-assignment (`a, b := func(...)` including indexed targets like `x[0], x[1] := x[1], x[0]`), KRoC-style colon terminators on PROC/FUNCTION (optional), replicators on SEQ/PAR/IF (with optional STEP), arithmetic/comparison/logical/AFTER/bitwise operators, type conversions (`INT expr`, `BYTE expr`, `REAL32 expr`, `REAL64 expr`, etc.), REAL32/REAL64 types, hex integer literals (`#FF`, `#80000000`), string literals, byte literals (`&#x27;A&#x27;`, `&#x27;*n&#x27;` with occam escape sequences), built-in print procedures, protocols (simple, sequential, and variant), record types (with field access via bracket syntax), SIZE operator, array slices (`[arr FROM n FOR m]` with slice assignment), nested PROCs/FUNCTIONs (local definitions as Go closures), MOSTNEG/MOSTPOS (type min/max constants for INT, BYTE, REAL32, REAL64), INITIAL declarations (`INITIAL INT x IS 42:` — mutable variable with initial value), checked (modular) arithmetic (`PLUS`, `MINUS`, `TIMES` — wrapping operators).
 
 ## Not Yet Implemented
 
diff --git a/TODO.md b/TODO.md
index 3a6cb24..881e129 100644
--- a/TODO.md
+++ b/TODO.md
@@ -5,10 +5,10 @@
 ### Core Constructs
 - **SEQ** — Sequential execution, with replicators (`SEQ i = 0 FOR n`) and optional STEP
 - **PAR** — Parallel execution via goroutines + sync.WaitGroup, with replicators
-- **IF** — Multi-branch conditionals, maps to if/else if chains, with replicators
-- **WHILE** — Loops, maps to Go `for` loops
-- **CASE** — Pattern matching with multiple cases and ELSE branch
-- **ALT** — Channel alternation, maps to Go `select`; supports boolean guards and timer timeouts
+- **IF** — Multi-branch conditionals, maps to if/else if chains, with replicators; supports multi-statement bodies (declarations scoped before process)
+- **WHILE** — Loops, maps to Go `for` loops; supports multi-statement bodies
+- **CASE** — Pattern matching with multiple cases and ELSE branch; supports multi-statement bodies
+- **ALT** — Channel alternation, maps to Go `select`; supports boolean guards, timer timeouts, and multi-statement bodies
 - **SKIP** — No-op process
 - **STOP** — Error + deadlock
 
@@ -18,7 +18,7 @@
 - **Arrays** — `[n]TYPE arr:` with index expressions
 - **Channels** — `CHAN OF TYPE c:` with send (`!`) and receive (`?`); `CHAN BYTE` shorthand (without `OF`)
 - **Channel arrays** — `[n]CHAN OF TYPE cs:` with indexed send/receive and `[]CHAN OF TYPE` proc params
-- **Channel direction** — `CHAN OF INT c?` (receive-only) and `CHAN OF INT c!` (send-only)
+- **Channel direction** — `CHAN OF INT c?` (receive-only) and `CHAN OF INT c!` (send-only); direction annotations at call sites (`out!`, `in?`) accepted and ignored
 - **Timers** — `TIMER tim:` with reads and `AFTER` expressions
 - **Abbreviations** — `VAL INT x IS 1:`, `INT y IS z:` — named constants and aliases
 - **INITIAL declarations** — `INITIAL INT x IS 42:` — mutable variables with initial values
diff --git a/ast/ast.go b/ast/ast.go
index 9a6ed53..370a898 100644
--- a/ast/ast.go
+++ b/ast/ast.go
@@ -189,7 +189,7 @@ func (f *FuncCall) TokenLiteral() string { return f.Token.Literal }
 type WhileLoop struct {
 	Token     lexer.Token // the WHILE token
 	Condition Expression
-	Body      Statement
+	Body      []Statement
 }
 
 func (w *WhileLoop) statementNode()       {}
@@ -204,7 +204,7 @@ type IfStatement struct {
 
 type IfChoice struct {
 	Condition Expression
-	Body      Statement
+	Body      []Statement
 }
 
 func (i *IfStatement) statementNode()       {}
@@ -220,7 +220,7 @@ type CaseStatement struct {
 type CaseChoice struct {
 	Values []Expression // nil/empty for ELSE
 	IsElse bool
-	Body   Statement
+	Body   []Statement
 }
 
 func (c *CaseStatement) statementNode()       {}
@@ -390,14 +390,14 @@ func (a *AltBlock) TokenLiteral() string { return a.Token.Literal }
 
 // AltCase represents a single case in an ALT block
 type AltCase struct {
-	Guard        Expression // optional guard condition (nil if no guard)
-	Channel      string     // channel name
-	ChannelIndex Expression // non-nil for cs[i] ? x in ALT
-	Variable     string     // variable to receive into
-	Body         Statement  // the body to execute
-	IsTimer      bool       // true if this is a timer AFTER case
-	Timer        string     // timer name (when IsTimer)
-	Deadline     Expression // AFTER deadline expression (when IsTimer)
+	Guard        Expression  // optional guard condition (nil if no guard)
+	Channel      string      // channel name
+	ChannelIndex Expression  // non-nil for cs[i] ? x in ALT
+	Variable     string      // variable to receive into
+	Body         []Statement // the body to execute
+	IsTimer      bool        // true if this is a timer AFTER case
+	Timer        string      // timer name (when IsTimer)
+	Deadline     Expression  // AFTER deadline expression (when IsTimer)
 }
 
 // TimerDecl represents a timer declaration: TIMER tim:
diff --git a/codegen/codegen.go b/codegen/codegen.go
index f877518..b56ba9b 100644
--- a/codegen/codegen.go
+++ b/codegen/codegen.go
@@ -195,8 +195,10 @@ func (g *Generator) containsPar(stmt ast.Statement) bool {
 		}
 	case *ast.AltBlock:
 		for _, c := range s.Cases {
-			if c.Body != nil &amp;&amp; g.containsPar(c.Body) {
-				return true
+			for _, inner := range c.Body {
+				if g.containsPar(inner) {
+					return true
+				}
 			}
 		}
 	case *ast.ProcDecl:
@@ -212,19 +214,25 @@ func (g *Generator) containsPar(stmt ast.Statement) bool {
 			}
 		}
 	case *ast.WhileLoop:
-		if s.Body != nil &amp;&amp; g.containsPar(s.Body) {
-			return true
+		for _, inner := range s.Body {
+			if g.containsPar(inner) {
+				return true
+			}
 		}
 	case *ast.IfStatement:
 		for _, choice := range s.Choices {
-			if choice.Body != nil &amp;&amp; g.containsPar(choice.Body) {
-				return true
+			for _, inner := range choice.Body {
+				if g.containsPar(inner) {
+					return true
+				}
 			}
 		}
 	case *ast.CaseStatement:
 		for _, choice := range s.Choices {
-			if choice.Body != nil &amp;&amp; g.containsPar(choice.Body) {
-				return true
+			for _, inner := range choice.Body {
+				if g.containsPar(inner) {
+					return true
+				}
 			}
 		}
 	case *ast.VariantReceive:
@@ -255,8 +263,10 @@ func (g *Generator) containsPrint(stmt ast.Statement) bool {
 		}
 	case *ast.AltBlock:
 		for _, c := range s.Cases {
-			if c.Body != nil &amp;&amp; g.containsPrint(c.Body) {
-				return true
+			for _, inner := range c.Body {
+				if g.containsPrint(inner) {
+					return true
+				}
 			}
 		}
 	case *ast.ProcDecl:
@@ -272,19 +282,25 @@ func (g *Generator) containsPrint(stmt ast.Statement) bool {
 			}
 		}
 	case *ast.WhileLoop:
-		if s.Body != nil &amp;&amp; g.containsPrint(s.Body) {
-			return true
+		for _, inner := range s.Body {
+			if g.containsPrint(inner) {
+				return true
+			}
 		}
 	case *ast.IfStatement:
 		for _, choice := range s.Choices {
-			if choice.Body != nil &amp;&amp; g.containsPrint(choice.Body) {
-				return true
+			for _, inner := range choice.Body {
+				if g.containsPrint(inner) {
+					return true
+				}
 			}
 		}
 	case *ast.CaseStatement:
 		for _, choice := range s.Choices {
-			if choice.Body != nil &amp;&amp; g.containsPrint(choice.Body) {
-				return true
+			for _, inner := range choice.Body {
+				if g.containsPrint(inner) {
+					return true
+				}
 			}
 		}
 	case *ast.VariantReceive:
@@ -306,8 +322,10 @@ func (g *Generator) containsTimer(stmt ast.Statement) bool {
 			if c.IsTimer {
 				return true
 			}
-			if c.Body != nil &amp;&amp; g.containsTimer(c.Body) {
-				return true
+			for _, inner := range c.Body {
+				if g.containsTimer(inner) {
+					return true
+				}
 			}
 		}
 	case *ast.SeqBlock:
@@ -335,19 +353,25 @@ func (g *Generator) containsTimer(stmt ast.Statement) bool {
 			}
 		}
 	case *ast.WhileLoop:
-		if s.Body != nil &amp;&amp; g.containsTimer(s.Body) {
-			return true
+		for _, inner := range s.Body {
+			if g.containsTimer(inner) {
+				return true
+			}
 		}
 	case *ast.IfStatement:
 		for _, choice := range s.Choices {
-			if choice.Body != nil &amp;&amp; g.containsTimer(choice.Body) {
-				return true
+			for _, inner := range choice.Body {
+				if g.containsTimer(inner) {
+					return true
+				}
 			}
 		}
 	case *ast.CaseStatement:
 		for _, choice := range s.Choices {
-			if choice.Body != nil &amp;&amp; g.containsTimer(choice.Body) {
-				return true
+			for _, inner := range choice.Body {
+				if g.containsTimer(inner) {
+					return true
+				}
 			}
 		}
 	case *ast.VariantReceive:
@@ -378,8 +402,10 @@ func (g *Generator) containsStop(stmt ast.Statement) bool {
 		}
 	case *ast.AltBlock:
 		for _, c := range s.Cases {
-			if c.Body != nil &amp;&amp; g.containsStop(c.Body) {
-				return true
+			for _, inner := range c.Body {
+				if g.containsStop(inner) {
+					return true
+				}
 			}
 		}
 	case *ast.ProcDecl:
@@ -395,19 +421,25 @@ func (g *Generator) containsStop(stmt ast.Statement) bool {
 			}
 		}
 	case *ast.WhileLoop:
-		if s.Body != nil &amp;&amp; g.containsStop(s.Body) {
-			return true
+		for _, inner := range s.Body {
+			if g.containsStop(inner) {
+				return true
+			}
 		}
 	case *ast.IfStatement:
 		for _, choice := range s.Choices {
-			if choice.Body != nil &amp;&amp; g.containsStop(choice.Body) {
-				return true
+			for _, inner := range choice.Body {
+				if g.containsStop(inner) {
+					return true
+				}
 			}
 		}
 	case *ast.CaseStatement:
 		for _, choice := range s.Choices {
-			if choice.Body != nil &amp;&amp; g.containsStop(choice.Body) {
-				return true
+			for _, inner := range choice.Body {
+				if g.containsStop(inner) {
+					return true
+				}
 			}
 		}
 	case *ast.VariantReceive:
@@ -465,16 +497,20 @@ func (g *Generator) containsMostExpr(stmt ast.Statement) bool {
 		if g.exprNeedsMath(s.Condition) {
 			return true
 		}
-		if s.Body != nil &amp;&amp; g.containsMostExpr(s.Body) {
-			return true
+		for _, inner := range s.Body {
+			if g.containsMostExpr(inner) {
+				return true
+			}
 		}
 	case *ast.IfStatement:
 		for _, choice := range s.Choices {
 			if g.exprNeedsMath(choice.Condition) {
 				return true
 			}
-			if choice.Body != nil &amp;&amp; g.containsMostExpr(choice.Body) {
-				return true
+			for _, inner := range choice.Body {
+				if g.containsMostExpr(inner) {
+					return true
+				}
 			}
 		}
 	case *ast.CaseStatement:
@@ -487,8 +523,10 @@ func (g *Generator) containsMostExpr(stmt ast.Statement) bool {
 					return true
 				}
 			}
-			if choice.Body != nil &amp;&amp; g.containsMostExpr(choice.Body) {
-				return true
+			for _, inner := range choice.Body {
+				if g.containsMostExpr(inner) {
+					return true
+				}
 			}
 		}
 	case *ast.Send:
@@ -508,8 +546,10 @@ func (g *Generator) containsMostExpr(stmt ast.Statement) bool {
 		}
 	case *ast.AltBlock:
 		for _, c := range s.Cases {
-			if c.Body != nil &amp;&amp; g.containsMostExpr(c.Body) {
-				return true
+			for _, inner := range c.Body {
+				if g.containsMostExpr(inner) {
+					return true
+				}
 			}
 		}
 	case *ast.VariantReceive:
@@ -898,25 +938,25 @@ func (g *Generator) collectChanProtocols(stmt ast.Statement) {
 			g.collectChanProtocols(inner)
 		}
 	case *ast.WhileLoop:
-		if s.Body != nil {
-			g.collectChanProtocols(s.Body)
+		for _, inner := range s.Body {
+			g.collectChanProtocols(inner)
 		}
 	case *ast.IfStatement:
 		for _, choice := range s.Choices {
-			if choice.Body != nil {
-				g.collectChanProtocols(choice.Body)
+			for _, inner := range choice.Body {
+				g.collectChanProtocols(inner)
 			}
 		}
 	case *ast.CaseStatement:
 		for _, choice := range s.Choices {
-			if choice.Body != nil {
-				g.collectChanProtocols(choice.Body)
+			for _, inner := range choice.Body {
+				g.collectChanProtocols(inner)
 			}
 		}
 	case *ast.AltBlock:
 		for _, c := range s.Cases {
-			if c.Body != nil {
-				g.collectChanProtocols(c.Body)
+			for _, inner := range c.Body {
+				g.collectChanProtocols(inner)
 			}
 		}
 	}
@@ -954,25 +994,25 @@ func (g *Generator) collectRecordVars(stmt ast.Statement) {
 			g.collectRecordVars(inner)
 		}
 	case *ast.WhileLoop:
-		if s.Body != nil {
-			g.collectRecordVars(s.Body)
+		for _, inner := range s.Body {
+			g.collectRecordVars(inner)
 		}
 	case *ast.IfStatement:
 		for _, choice := range s.Choices {
-			if choice.Body != nil {
-				g.collectRecordVars(choice.Body)
+			for _, inner := range choice.Body {
+				g.collectRecordVars(inner)
 			}
 		}
 	case *ast.CaseStatement:
 		for _, choice := range s.Choices {
-			if choice.Body != nil {
-				g.collectRecordVars(choice.Body)
+			for _, inner := range choice.Body {
+				g.collectRecordVars(inner)
 			}
 		}
 	case *ast.AltBlock:
 		for _, c := range s.Cases {
-			if c.Body != nil {
-				g.collectRecordVars(c.Body)
+			for _, inner := range c.Body {
+				g.collectRecordVars(inner)
 			}
 		}
 	}
@@ -1249,8 +1289,8 @@ func (g *Generator) generateAltBlock(alt *ast.AltBlock) {
 			g.write(fmt.Sprintf(&quot;case %s = &lt;-%s:\n&quot;, c.Variable, c.Channel))
 		}
 		g.indent++
-		if c.Body != nil {
-			g.generateStatement(c.Body)
+		for _, s := range c.Body {
+			g.generateStatement(s)
 		}
 		g.indent--
 	}
@@ -1500,8 +1540,8 @@ func (g *Generator) generateWhileLoop(loop *ast.WhileLoop) {
 	g.write(&quot; {\n&quot;)
 	g.indent++
 
-	if loop.Body != nil {
-		g.generateStatement(loop.Body)
+	for _, s := range loop.Body {
+		g.generateStatement(s)
 	}
 
 	g.indent--
@@ -1548,8 +1588,8 @@ func (g *Generator) generateIfStatement(stmt *ast.IfStatement) {
 			g.write(&quot; {\n&quot;)
 			g.indent++
 
-			if choice.Body != nil {
-				g.generateStatement(choice.Body)
+			for _, s := range choice.Body {
+				g.generateStatement(s)
 			}
 			g.writeLine(&quot;break&quot;)
 
@@ -1571,8 +1611,8 @@ func (g *Generator) generateIfStatement(stmt *ast.IfStatement) {
 			g.write(&quot; {\n&quot;)
 			g.indent++
 
-			if choice.Body != nil {
-				g.generateStatement(choice.Body)
+			for _, s := range choice.Body {
+				g.generateStatement(s)
 			}
 
 			g.indent--
@@ -1602,8 +1642,8 @@ func (g *Generator) generateCaseStatement(stmt *ast.CaseStatement) {
 			g.write(&quot;:\n&quot;)
 		}
 		g.indent++
-		if choice.Body != nil {
-			g.generateStatement(choice.Body)
+		for _, s := range choice.Body {
+			g.generateStatement(s)
 		}
 		g.indent--
 	}
diff --git a/codegen/e2e_control_test.go b/codegen/e2e_control_test.go
index a380721..ccedf8a 100644
--- a/codegen/e2e_control_test.go
+++ b/codegen/e2e_control_test.go
@@ -201,3 +201,84 @@ func TestE2E_CaseExpression(t *testing.T) {
 		t.Errorf(&quot;expected %q, got %q&quot;, expected, output)
 	}
 }
+
+func TestE2E_MultiStatementIfBody(t *testing.T) {
+	occam := `SEQ
+  INT x:
+  x := 5
+  IF
+    x &gt; 0
+      INT y:
+      y := x + 10
+      print.int(y)
+    TRUE
+      SKIP
+`
+	output := transpileCompileRun(t, occam)
+	expected := &quot;15\n&quot;
+	if output != expected {
+		t.Errorf(&quot;expected %q, got %q&quot;, expected, output)
+	}
+}
+
+func TestE2E_MultiStatementCaseBody(t *testing.T) {
+	occam := `SEQ
+  INT x:
+  x := 2
+  CASE x
+    1
+      print.int(10)
+    2
+      INT y:
+      y := x * 100
+      print.int(y)
+    ELSE
+      print.int(0)
+`
+	output := transpileCompileRun(t, occam)
+	expected := &quot;200\n&quot;
+	if output != expected {
+		t.Errorf(&quot;expected %q, got %q&quot;, expected, output)
+	}
+}
+
+func TestE2E_MultiStatementWhileBody(t *testing.T) {
+	occam := `SEQ
+  INT x:
+  x := 0
+  WHILE x &lt; 3
+    INT step:
+    step := 1
+    x := x + step
+  print.int(x)
+`
+	output := transpileCompileRun(t, occam)
+	expected := &quot;3\n&quot;
+	if output != expected {
+		t.Errorf(&quot;expected %q, got %q&quot;, expected, output)
+	}
+}
+
+func TestE2E_ChannelDirAtCallSite(t *testing.T) {
+	occam := `PROC worker(CHAN OF INT in?, CHAN OF INT out!)
+  INT x:
+  in ? x
+  out ! x + 1
+:
+SEQ
+  CHAN OF INT a:
+  CHAN OF INT b:
+  PAR
+    worker(a?, b!)
+    SEQ
+      a ! 10
+      INT result:
+      b ? result
+      print.int(result)
+`
+	output := transpileCompileRun(t, occam)
+	expected := &quot;11\n&quot;
+	if output != expected {
+		t.Errorf(&quot;expected %q, got %q&quot;, expected, output)
+	}
+}
diff --git a/parser/parser.go b/parser/parser.go
index 47e833b..3340c70 100644
--- a/parser/parser.go
+++ b/parser/parser.go
@@ -1635,13 +1635,7 @@ func (p *Parser) parseAltCase() *ast.AltCase {
 	p.nextToken() // consume INDENT
 	p.nextToken() // move into body
 
-	// Parse the body (first statement)
-	altCase.Body = p.parseStatement()
-
-	// Skip to end of body block
-	for !p.curTokenIs(lexer.DEDENT) &amp;&amp; !p.curTokenIs(lexer.EOF) {
-		p.nextToken()
-	}
+	altCase.Body = p.parseBodyStatements()
 
 	return altCase
 }
@@ -1699,6 +1693,64 @@ func (p *Parser) parseBlockStatements() []ast.Statement {
 	return statements
 }
 
+// parseBodyStatements parses multiple statements inside a branch body
+// (IF choice, CASE choice, ALT case, WHILE). Called after the caller has
+// consumed the INDENT token and advanced into the body.
+// Returns all statements found at this indentation level.
+func (p *Parser) parseBodyStatements() []ast.Statement {
+	var statements []ast.Statement
+	startLevel := p.indentLevel
+
+	for !p.curTokenIs(lexer.EOF) {
+		// Skip newlines
+		for p.curTokenIs(lexer.NEWLINE) {
+			p.nextToken()
+		}
+
+		// Handle DEDENT tokens
+		for p.curTokenIs(lexer.DEDENT) {
+			if p.indentLevel &lt; startLevel {
+				return statements
+			}
+			p.nextToken()
+		}
+
+		// Skip any more newlines after DEDENT
+		for p.curTokenIs(lexer.NEWLINE) {
+			p.nextToken()
+		}
+
+		if p.curTokenIs(lexer.EOF) {
+			break
+		}
+
+		if p.indentLevel &lt; startLevel {
+			break
+		}
+
+		// Safety guard: record position before parsing to detect no-progress
+		prevToken := p.curToken
+		prevPeek := p.peekToken
+
+		stmt := p.parseStatement()
+		if stmt != nil {
+			statements = append(statements, stmt)
+		}
+
+		// Advance past the last token of the statement if needed
+		if !p.curTokenIs(lexer.NEWLINE) &amp;&amp; !p.curTokenIs(lexer.DEDENT) &amp;&amp; !p.curTokenIs(lexer.EOF) {
+			p.nextToken()
+		}
+
+		// No-progress guard: if we haven&#x27;t moved, break to prevent infinite loop
+		if p.curToken == prevToken &amp;&amp; p.peekToken == prevPeek {
+			break
+		}
+	}
+
+	return statements
+}
+
 func (p *Parser) parseProcDecl() *ast.ProcDecl {
 	proc := &amp;ast.ProcDecl{Token: p.curToken}
 
@@ -1910,11 +1962,19 @@ func (p *Parser) parseProcCall() *ast.ProcCall {
 
 	p.nextToken() // move to first arg
 	call.Args = append(call.Args, p.parseExpression(LOWEST))
+	// Consume optional channel direction annotation at call site (e.g., out!)
+	if p.peekTokenIs(lexer.SEND) || p.peekTokenIs(lexer.RECEIVE) {
+		p.nextToken()
+	}
 
 	for p.peekTokenIs(lexer.COMMA) {
 		p.nextToken() // consume comma
 		p.nextToken() // move to next arg
 		call.Args = append(call.Args, p.parseExpression(LOWEST))
+		// Consume optional channel direction annotation at call site
+		if p.peekTokenIs(lexer.SEND) || p.peekTokenIs(lexer.RECEIVE) {
+			p.nextToken()
+		}
 	}
 
 	if !p.expectPeek(lexer.RPAREN) {
@@ -2148,12 +2208,7 @@ func (p *Parser) parseWhileLoop() *ast.WhileLoop {
 	p.nextToken() // consume INDENT
 	p.nextToken() // move to first statement
 
-	loop.Body = p.parseStatement()
-
-	// Consume until DEDENT
-	for !p.curTokenIs(lexer.DEDENT) &amp;&amp; !p.curTokenIs(lexer.EOF) {
-		p.nextToken()
-	}
+	loop.Body = p.parseBodyStatements()
 
 	return loop
 }
@@ -2225,12 +2280,7 @@ func (p *Parser) parseIfStatement() *ast.IfStatement {
 		if p.peekTokenIs(lexer.INDENT) {
 			p.nextToken() // consume INDENT
 			p.nextToken() // move to body
-			choice.Body = p.parseStatement()
-
-			// Advance past the last token of the statement if needed
-			if !p.curTokenIs(lexer.NEWLINE) &amp;&amp; !p.curTokenIs(lexer.DEDENT) &amp;&amp; !p.curTokenIs(lexer.EOF) {
-				p.nextToken()
-			}
+			choice.Body = p.parseBodyStatements()
 		}
 
 		stmt.Choices = append(stmt.Choices, choice)
@@ -2305,12 +2355,7 @@ func (p *Parser) parseCaseStatement() *ast.CaseStatement {
 		if p.peekTokenIs(lexer.INDENT) {
 			p.nextToken() // consume INDENT
 			p.nextToken() // move to body
-			choice.Body = p.parseStatement()
-
-			// Advance past the last token of the statement if needed
-			if !p.curTokenIs(lexer.NEWLINE) &amp;&amp; !p.curTokenIs(lexer.DEDENT) &amp;&amp; !p.curTokenIs(lexer.EOF) {
-				p.nextToken()
-			}
+			choice.Body = p.parseBodyStatements()
 		}
 
 		stmt.Choices = append(stmt.Choices, choice)
diff --git a/parser/parser_test.go b/parser/parser_test.go
index a5cd1b7..87eece9 100644
--- a/parser/parser_test.go
+++ b/parser/parser_test.go
@@ -371,7 +371,7 @@ func TestWhileLoop(t *testing.T) {
 		t.Error(&quot;expected condition&quot;)
 	}
 
-	if loop.Body == nil {
+	if len(loop.Body) == 0 {
 		t.Error(&quot;expected body&quot;)
 	}
 }
@@ -405,7 +405,7 @@ func TestIfStatement(t *testing.T) {
 		t.Error(&quot;expected condition on first choice&quot;)
 	}
 
-	if ifStmt.Choices[0].Body == nil {
+	if len(ifStmt.Choices[0].Body) == 0 {
 		t.Error(&quot;expected body on first choice&quot;)
 	}
 
@@ -413,7 +413,7 @@ func TestIfStatement(t *testing.T) {
 		t.Error(&quot;expected condition on second choice&quot;)
 	}
 
-	if ifStmt.Choices[1].Body == nil {
+	if len(ifStmt.Choices[1].Body) == 0 {
 		t.Error(&quot;expected body on second choice&quot;)
 	}
 }
@@ -577,7 +577,7 @@ func TestReplicatedIf(t *testing.T) {
 		t.Error(&quot;expected condition on choice&quot;)
 	}
 
-	if ifStmt.Choices[0].Body == nil {
+	if len(ifStmt.Choices[0].Body) == 0 {
 		t.Error(&quot;expected body on choice&quot;)
 	}
 }
@@ -1017,7 +1017,7 @@ func TestCaseStatement(t *testing.T) {
 	if len(caseStmt.Choices[0].Values) != 1 {
 		t.Fatalf(&quot;expected 1 value in first choice, got %d&quot;, len(caseStmt.Choices[0].Values))
 	}
-	if caseStmt.Choices[0].Body == nil {
+	if len(caseStmt.Choices[0].Body) == 0 {
 		t.Error(&quot;expected body on first choice&quot;)
 	}
 
@@ -1025,7 +1025,7 @@ func TestCaseStatement(t *testing.T) {
 	if caseStmt.Choices[1].IsElse {
 		t.Error(&quot;second choice should not be ELSE&quot;)
 	}
-	if caseStmt.Choices[1].Body == nil {
+	if len(caseStmt.Choices[1].Body) == 0 {
 		t.Error(&quot;expected body on second choice&quot;)
 	}
 
@@ -1033,7 +1033,7 @@ func TestCaseStatement(t *testing.T) {
 	if !caseStmt.Choices[2].IsElse {
 		t.Error(&quot;third choice should be ELSE&quot;)
 	}
-	if caseStmt.Choices[2].Body == nil {
+	if len(caseStmt.Choices[2].Body) == 0 {
 		t.Error(&quot;expected body on ELSE choice&quot;)
 	}
 }
@@ -2781,3 +2781,95 @@ func TestCheckedAndSymbolMixed(t *testing.T) {
 		t.Errorf(&quot;expected top-level operator +, got %s&quot;, binExpr.Operator)
 	}
 }
+
+func TestMultiStatementIfBody(t *testing.T) {
+	input := `IF
+  x &gt; 0
+    INT y:
+    y := 42
+    print.int(y)
+  TRUE
+    SKIP
+`
+	l := lexer.New(input)
+	p := New(l)
+	program := p.ParseProgram()
+	checkParserErrors(t, p)
+
+	if len(program.Statements) != 1 {
+		t.Fatalf(&quot;expected 1 statement, got %d&quot;, len(program.Statements))
+	}
+
+	ifStmt, ok := program.Statements[0].(*ast.IfStatement)
+	if !ok {
+		t.Fatalf(&quot;expected IfStatement, got %T&quot;, program.Statements[0])
+	}
+
+	if len(ifStmt.Choices) != 2 {
+		t.Fatalf(&quot;expected 2 choices, got %d&quot;, len(ifStmt.Choices))
+	}
+
+	// First choice should have 3 body statements: VarDecl, Assignment, ProcCall
+	if len(ifStmt.Choices[0].Body) != 3 {
+		t.Fatalf(&quot;expected 3 body statements in first choice, got %d&quot;, len(ifStmt.Choices[0].Body))
+	}
+	if _, ok := ifStmt.Choices[0].Body[0].(*ast.VarDecl); !ok {
+		t.Errorf(&quot;expected VarDecl as first body stmt, got %T&quot;, ifStmt.Choices[0].Body[0])
+	}
+	if _, ok := ifStmt.Choices[0].Body[1].(*ast.Assignment); !ok {
+		t.Errorf(&quot;expected Assignment as second body stmt, got %T&quot;, ifStmt.Choices[0].Body[1])
+	}
+	if _, ok := ifStmt.Choices[0].Body[2].(*ast.ProcCall); !ok {
+		t.Errorf(&quot;expected ProcCall as third body stmt, got %T&quot;, ifStmt.Choices[0].Body[2])
+	}
+
+	// Second choice should have 1 body statement: Skip
+	if len(ifStmt.Choices[1].Body) != 1 {
+		t.Fatalf(&quot;expected 1 body statement in second choice, got %d&quot;, len(ifStmt.Choices[1].Body))
+	}
+	if _, ok := ifStmt.Choices[1].Body[0].(*ast.Skip); !ok {
+		t.Errorf(&quot;expected Skip, got %T&quot;, ifStmt.Choices[1].Body[0])
+	}
+}
+
+func TestChannelDirAtCallSite(t *testing.T) {
+	input := `foo(out!, in?)
+`
+	l := lexer.New(input)
+	p := New(l)
+	program := p.ParseProgram()
+	checkParserErrors(t, p)
+
+	if len(program.Statements) != 1 {
+		t.Fatalf(&quot;expected 1 statement, got %d&quot;, len(program.Statements))
+	}
+
+	call, ok := program.Statements[0].(*ast.ProcCall)
+	if !ok {
+		t.Fatalf(&quot;expected ProcCall, got %T&quot;, program.Statements[0])
+	}
+
+	if call.Name != &quot;foo&quot; {
+		t.Errorf(&quot;expected proc name &#x27;foo&#x27;, got %q&quot;, call.Name)
+	}
+
+	if len(call.Args) != 2 {
+		t.Fatalf(&quot;expected 2 args, got %d&quot;, len(call.Args))
+	}
+
+	arg0, ok := call.Args[0].(*ast.Identifier)
+	if !ok {
+		t.Fatalf(&quot;expected Identifier for arg 0, got %T&quot;, call.Args[0])
+	}
+	if arg0.Value != &quot;out&quot; {
+		t.Errorf(&quot;expected arg 0 = &#x27;out&#x27;, got %q&quot;, arg0.Value)
+	}
+
+	arg1, ok := call.Args[1].(*ast.Identifier)
+	if !ok {
+		t.Fatalf(&quot;expected Identifier for arg 1, got %T&quot;, call.Args[1])
+	}
+	if arg1.Value != &quot;in&quot; {
+		t.Errorf(&quot;expected arg 1 = &#x27;in&#x27;, got %q&quot;, arg1.Value)
+	}
+}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T05-19-08-682Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T05-19-08-682Z" class="timestamp-link"><time datetime="2026-02-19T05:19:08.682Z" data-timestamp="2026-02-19T05:19:08.682Z">2026-02-19T05:19:08.682Z</time></a></div><div class="message-content">
<div class="tool-use bash-tool" data-tool-id="toolu_01LLG3zrH1Bi8UvLnWWPsT1L">
<div class="tool-header"><span class="tool-icon">$</span> Bash</div>
<div class="tool-description">Show recent commits</div><div class="truncatable"><div class="truncatable-content"><pre class="bash-command">git log --oneline -5</pre></div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T05-19-08-831Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T05-19-08-831Z" class="timestamp-link"><time datetime="2026-02-19T05:19:08.831Z" data-timestamp="2026-02-19T05:19:08.831Z">2026-02-19T05:19:08.831Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>5cbfc5a Merge pull request #22 from codeassociates/docs/consolidate-todo-implemented
461e4a2 Remove completed course.module section from TODO.md
c058eec Merge pull request #21 from codeassociates/feature/checked-arithmetic
99d0442 Add checked (modular) arithmetic support (PLUS, MINUS, TIMES)
af7e09d Merge pull request #20 from codeassociates/feature/initial-declarations</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message user" id="msg-2026-02-19T16-37-54-445Z"><div class="message-header"><span class="role-label">User</span><a href="#msg-2026-02-19T16-37-54-445Z" class="timestamp-link"><time datetime="2026-02-19T16:37:54.445Z" data-timestamp="2026-02-19T16:37:54.445Z">2026-02-19T16:37:54.445Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Continue from where you left off.</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T16-37-54-445Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T16-37-54-445Z" class="timestamp-link"><time datetime="2026-02-19T16:37:54.445Z" data-timestamp="2026-02-19T16:37:54.445Z">2026-02-19T16:37:54.445Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>No response requested.</p></div></div></div>
<div class="message user" id="msg-2026-02-19T16-38-30-459Z"><div class="message-header"><span class="role-label">User</span><a href="#msg-2026-02-19T16-38-30-459Z" class="timestamp-link"><time datetime="2026-02-19T16:38:30.459Z" data-timestamp="2026-02-19T16:38:30.459Z">2026-02-19T16:38:30.459Z</time></a></div><div class="message-content">
<div class="user-content"><p>The host machine's kernel becams unstable. I've resumed your session. Please continue.</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T16-38-35-735Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T16-38-35-735Z" class="timestamp-link"><time datetime="2026-02-19T16:38:35.735Z" data-timestamp="2026-02-19T16:38:35.735Z">2026-02-19T16:38:35.735Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Right, let's commit the current working changes. All tests were passing before the crash.</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T16-38-36-373Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T16-38-36-373Z" class="timestamp-link"><time datetime="2026-02-19T16:38:36.373Z" data-timestamp="2026-02-19T16:38:36.373Z">2026-02-19T16:38:36.373Z</time></a></div><div class="message-content">
<div class="tool-use bash-tool" data-tool-id="toolu_01Bk8Yszx9LjDKzbXM43FD1Z">
<div class="tool-header"><span class="tool-icon">$</span> Bash</div>
<div class="tool-description">Show working tree status</div><div class="truncatable"><div class="truncatable-content"><pre class="bash-command">git status</pre></div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T16-38-36-612Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T16-38-36-612Z" class="timestamp-link"><time datetime="2026-02-19T16:38:36.612Z" data-timestamp="2026-02-19T16:38:36.612Z">2026-02-19T16:38:36.612Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>On branch main
Your branch is up to date with &#x27;origin/main&#x27;.

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)
	modified:   CLAUDE.md
	modified:   TODO.md
	modified:   ast/ast.go
	modified:   codegen/codegen.go
	modified:   codegen/e2e_control_test.go
	modified:   parser/parser.go
	modified:   parser/parser_test.go

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T16-38-36-880Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T16-38-36-880Z" class="timestamp-link"><time datetime="2026-02-19T16:38:36.880Z" data-timestamp="2026-02-19T16:38:36.880Z">2026-02-19T16:38:36.880Z</time></a></div><div class="message-content">
<div class="tool-use bash-tool" data-tool-id="toolu_0111AVMX7sJszHCACMjatpW8">
<div class="tool-header"><span class="tool-icon">$</span> Bash</div>
<div class="tool-description">Show recent commits</div><div class="truncatable"><div class="truncatable-content"><pre class="bash-command">git log --oneline -3</pre></div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T16-38-37-046Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T16-38-37-046Z" class="timestamp-link"><time datetime="2026-02-19T16:38:37.046Z" data-timestamp="2026-02-19T16:38:37.046Z">2026-02-19T16:38:37.046Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>5cbfc5a Merge pull request #22 from codeassociates/docs/consolidate-todo-implemented
461e4a2 Remove completed course.module section from TODO.md
c058eec Merge pull request #21 from codeassociates/feature/checked-arithmetic</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T16-38-40-690Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T16-38-40-690Z" class="timestamp-link"><time datetime="2026-02-19T16:38:40.690Z" data-timestamp="2026-02-19T16:38:40.690Z">2026-02-19T16:38:40.690Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Let me quickly verify tests still pass after the crash, then commit.</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T16-38-41-419Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T16-38-41-419Z" class="timestamp-link"><time datetime="2026-02-19T16:38:41.419Z" data-timestamp="2026-02-19T16:38:41.419Z">2026-02-19T16:38:41.419Z</time></a></div><div class="message-content">
<div class="tool-use bash-tool" data-tool-id="toolu_0197HTk43DbRrURnrgKTkDW5">
<div class="tool-header"><span class="tool-icon">$</span> Bash</div>
<div class="tool-description">Run all tests</div><div class="truncatable"><div class="truncatable-content"><pre class="bash-command">go test ./... 2&gt;&amp;1</pre></div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T16-38-41-733Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T16-38-41-733Z" class="timestamp-link"><time datetime="2026-02-19T16:38:41.733Z" data-timestamp="2026-02-19T16:38:41.733Z">2026-02-19T16:38:41.733Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>?   	github.com/codeassociates/occam2go	[no test files]
?   	github.com/codeassociates/occam2go/ast	[no test files]
ok  	github.com/codeassociates/occam2go/codegen	(cached)
ok  	github.com/codeassociates/occam2go/lexer	(cached)
ok  	github.com/codeassociates/occam2go/modgen	(cached)
ok  	github.com/codeassociates/occam2go/parser	(cached)
ok  	github.com/codeassociates/occam2go/preproc	(cached)</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T16-38-45-305Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T16-38-45-305Z" class="timestamp-link"><time datetime="2026-02-19T16:38:45.305Z" data-timestamp="2026-02-19T16:38:45.305Z">2026-02-19T16:38:45.305Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>All passing. Let me commit.</p></div></div></div>
<div class="message assistant" id="msg-2026-02-19T16-38-46-142Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T16-38-46-142Z" class="timestamp-link"><time datetime="2026-02-19T16:38:46.142Z" data-timestamp="2026-02-19T16:38:46.142Z">2026-02-19T16:38:46.142Z</time></a></div><div class="message-content">
<div class="tool-use bash-tool" data-tool-id="toolu_01PH6LbqHtU6kzuQV7cw5fYq">
<div class="tool-header"><span class="tool-icon">$</span> Bash</div>
<div class="tool-description">Stage all changed files</div><div class="truncatable"><div class="truncatable-content"><pre class="bash-command">git add ast/ast.go parser/parser.go parser/parser_test.go codegen/codegen.go codegen/e2e_control_test.go CLAUDE.md TODO.md</pre></div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T16-38-51-407Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T16-38-51-407Z" class="timestamp-link"><time datetime="2026-02-19T16:38:51.407Z" data-timestamp="2026-02-19T16:38:51.407Z">2026-02-19T16:38:51.407Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre></pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T16-39-00-644Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T16-39-00-644Z" class="timestamp-link"><time datetime="2026-02-19T16:39:00.644Z" data-timestamp="2026-02-19T16:39:00.644Z">2026-02-19T16:39:00.644Z</time></a></div><div class="message-content">
<div class="tool-use bash-tool" data-tool-id="toolu_013z84aSS9PGBVUAnMCMz9pL">
<div class="tool-header"><span class="tool-icon">$</span> Bash</div>
<div class="tool-description">Create commit</div><div class="truncatable"><div class="truncatable-content"><pre class="bash-command">git commit -m &#34;$(cat &lt;&lt;&#39;EOF&#39;
Support multi-statement bodies in IF/CASE/WHILE/ALT and call-site channel direction

The parser previously only called parseStatement() once per branch body in
IF/CASE/WHILE/ALT, causing an infinite loop (OOM) when occam programs had
scoped declarations before processes in branch bodies. This changes Body
fields from ast.Statement to []ast.Statement and adds parseBodyStatements()
to parse all statements at the body&#39;s indentation level with a no-progress
safety guard.

Also handles channel direction annotations at call sites (out!, in?) in
parseProcCall(), which are informational and ignored in codegen.

Co-Authored-By: Claude Opus 4.6 &lt;noreply@anthropic.com&gt;
EOF
)&#34;</pre></div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T16-39-05-533Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T16-39-05-533Z" class="timestamp-link"><time datetime="2026-02-19T16:39:05.533Z" data-timestamp="2026-02-19T16:39:05.533Z">2026-02-19T16:39:05.533Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><div class="commit-card"><a href="https://github.com/codeassociates/occam2go/commit/b088adc"><span class="commit-card-hash">b088adc</span> Support multi-statement bodies in IF/CASE/WHILE/ALT and call-site channel direction</a></div><pre>7 files changed, 374 insertions(+), 115 deletions(-)</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T16-39-08-861Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T16-39-08-861Z" class="timestamp-link"><time datetime="2026-02-19T16:39:08.861Z" data-timestamp="2026-02-19T16:39:08.861Z">2026-02-19T16:39:08.861Z</time></a></div><div class="message-content">
<div class="tool-use bash-tool" data-tool-id="toolu_017mQ6GZpgksfYT9vUpj8akr">
<div class="tool-header"><span class="tool-icon">$</span> Bash</div>
<div class="tool-description">Verify clean working tree</div><div class="truncatable"><div class="truncatable-content"><pre class="bash-command">git status</pre></div><button class="expand-btn">Show more</button></div>
</div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T16-39-09-017Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T16-39-09-017Z" class="timestamp-link"><time datetime="2026-02-19T16:39:09.017Z" data-timestamp="2026-02-19T16:39:09.017Z">2026-02-19T16:39:09.017Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>On branch main
Your branch is ahead of &#x27;origin/main&#x27; by 1 commit.
  (use &quot;git push&quot; to publish your local commits)

nothing to commit, working tree clean</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T16-39-12-841Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T16-39-12-841Z" class="timestamp-link"><time datetime="2026-02-19T16:39:12.841Z" data-timestamp="2026-02-19T16:39:12.841Z">2026-02-19T16:39:12.841Z</time></a></div><div class="message-content">
<div class="tool-use" data-tool-id="toolu_01VQzm5VAgLxAE2gVgLGCSmi"><div class="tool-header"><span class="tool-icon">⚙</span> TaskUpdate</div><div class="truncatable"><div class="truncatable-content"><pre class="json">{
  &#34;taskId&#34;: &#34;5&#34;,
  &#34;status&#34;: &#34;completed&#34;
}</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message tool-reply" id="msg-2026-02-19T16-39-12-853Z"><div class="message-header"><span class="role-label">Tool reply</span><a href="#msg-2026-02-19T16-39-12-853Z" class="timestamp-link"><time datetime="2026-02-19T16:39:12.853Z" data-timestamp="2026-02-19T16:39:12.853Z">2026-02-19T16:39:12.853Z</time></a></div><div class="message-content"><div class="tool-result"><div class="truncatable"><div class="truncatable-content"><pre>Updated task #5 status</pre></div><button class="expand-btn">Show more</button></div></div></div></div>
<div class="message assistant" id="msg-2026-02-19T16-39-18-018Z"><div class="message-header"><span class="role-label">Assistant</span><a href="#msg-2026-02-19T16-39-18-018Z" class="timestamp-link"><time datetime="2026-02-19T16:39:18.018Z" data-timestamp="2026-02-19T16:39:18.018Z">2026-02-19T16:39:18.018Z</time></a></div><div class="message-content">
<div class="assistant-text"><p>Committed as <code>b088adc</code>. Working tree is clean. The remaining infinite loop when transpiling the course library demo is a separate issue — likely an unsupported construct in the course library source that causes the parser to spin. That can be investigated safely now without risking loss of these fixes.</p></div></div></div>
        

<div class="pagination">
<a href="index.html" class="index-link">Index</a>
<span class="disabled">&larr; Prev</span>
<span class="current">1</span>
<a href="page-002.html">2</a>
<a href="page-002.html">Next &rarr;</a>
</div>

    </div>
    <script>
document.querySelectorAll('time[data-timestamp]').forEach(function(el) {
    const timestamp = el.getAttribute('data-timestamp');
    const date = new Date(timestamp);
    const now = new Date();
    const isToday = date.toDateString() === now.toDateString();
    const timeStr = date.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' });
    if (isToday) { el.textContent = timeStr; }
    else { el.textContent = date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' }) + ' ' + timeStr; }
});
document.querySelectorAll('pre.json').forEach(function(el) {
    let text = el.textContent;
    text = text.replace(/"([^"]+)":/g, '<span style="color: #ce93d8">"$1"</span>:');
    text = text.replace(/: "([^"]*)"/g, ': <span style="color: #81d4fa">"$1"</span>');
    text = text.replace(/: (\d+)/g, ': <span style="color: #ffcc80">$1</span>');
    text = text.replace(/: (true|false|null)/g, ': <span style="color: #f48fb1">$1</span>');
    el.innerHTML = text;
});
document.querySelectorAll('.truncatable').forEach(function(wrapper) {
    const content = wrapper.querySelector('.truncatable-content');
    const btn = wrapper.querySelector('.expand-btn');
    if (content.scrollHeight > 250) {
        wrapper.classList.add('truncated');
        btn.addEventListener('click', function() {
            if (wrapper.classList.contains('truncated')) { wrapper.classList.remove('truncated'); wrapper.classList.add('expanded'); btn.textContent = 'Show less'; }
            else { wrapper.classList.remove('expanded'); wrapper.classList.add('truncated'); btn.textContent = 'Show more'; }
        });
    }
});
</script>
</body>
</html>
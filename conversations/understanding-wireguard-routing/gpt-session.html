<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChatGPT Session - Understanding WireGuard Routing</title>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f9f9f9;
            margin: 0;
            padding: 20px;
        }
        
        /* Main content container */
        article {
            max-width: 800px;
            margin: 0 auto 2em auto;
            padding: 1.5em;
            background: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        /* User messages bubble styling */
        .user-message-bubble-color {
            background-color: #e3f2fd;
            padding: 12px 16px;
            border-radius: 18px;
            display: inline-block;
        }
        
        /* Prose/markdown content */
        .markdown, .prose {
            max-width: 75ch;
        }
        
        p {
            margin: 1em 0;
        }
        
        h1, h2, h3, h4, h5, h6 {
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }
        
        h2 {
            font-size: 1.4em;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.3em;
        }
        
        h3 {
            font-size: 1.2em;
        }
        
        ul, ol {
            padding-left: 1.5em;
            margin: 1em 0;
        }
        
        li {
            margin: 0.5em 0;
        }
        
        hr {
            border: none;
            border-top: 1px solid #ddd;
            margin: 2em 0;
        }
        
        blockquote {
            border-left: 4px solid #ddd;
            margin: 1em 0;
            padding-left: 1em;
            color: #666;
        }
        
        pre {
            background-color: #1e1e1e;
            color: #d4d4d4;
            padding: 1em;
            border-radius: 8px;
            overflow-x: auto;
            max-width: 100%;
            margin: 1em 0;
        }
        
        code {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Liberation Mono', Menlo, monospace;
            font-size: 0.9em;
        }
        
        :not(pre) > code {
            background-color: rgba(0, 0, 0, 0.05);
            padding: 0.2em 0.4em;
            border-radius: 4px;
        }
        
        pre code {
            background-color: transparent;
            padding: 0;
        }
        
        a {
            color: #2563eb;
        }
        
        strong {
            font-weight: 600;
        }
        
        /* Hide ChatGPT UI elements that don't make sense in static view */
        [class*="sticky"], 
        [class*="bg-token-sidebar"] {
            display: none;
        }
    </style>
</head>
<body>

<!--StartFragment-->
<article class="text-token-text-primary w-full focus:outline-none [--shadow-height:45px] has-data-writing-block:pointer-events-none has-data-writing-block:-mt-(--shadow-height) has-data-writing-block:pt-(--shadow-height) [&amp;:has([data-writing-block])&gt;*]:pointer-events-auto scroll-mt-(--header-height)" tabindex="-1" dir="auto" data-turn-id="5255f2f0-8b9a-49f0-94b8-728c7473e529" data-testid="conversation-turn-1" data-scroll-anchor="false" data-turn="user"><div class="text-base my-auto mx-auto pt-3 [--thread-content-margin:--spacing(4)] @w-sm/main:[--thread-content-margin:--spacing(6)] @w-lg/main:[--thread-content-margin:--spacing(16)] px-(--thread-content-margin)"><div class="[--thread-content-max-width:40rem] @w-lg/main:[--thread-content-max-width:48rem] mx-auto max-w-(--thread-content-max-width) flex-1 group/turn-messages focus-visible:outline-hidden mb-10 relative flex w-full min-w-0 flex-col" tabindex="-1"><div class="flex max-w-full flex-col grow">
    <div>
<span>Notes on this session are <a href="./notes.html">here</a></span>
</div>
<div><span>&nbsp;</span></div>
    <div data-message-author-role="user" data-message-id="5255f2f0-8b9a-49f0-94b8-728c7473e529" dir="auto" class="min-h-8 text-message relative flex w-full flex-col items-end gap-2 text-start break-words whitespace-normal [.text-message+&amp;]:mt-1"><div class="flex w-full flex-col gap-1 empty:hidden items-end rtl:items-start"><div class="user-message-bubble-color corner-superellipse/1.1 relative rounded-[18px] px-4 py-1.5 data-[multiline]:py-3 max-w-[var(--user-chat-width,70%)]" data-multiline=""><div class="whitespace-pre-wrap">I have a question about a problem I'm having with wireguard used between two routers to implement a tunnel. The scenario is quite complex but the basic idea is that the wireguard session between router a and router b should always be active, regardless of the underlying IP route used to carry the wireguard UDP packets. Specifically what I have seen is that when routes change such that router a ends up using a different source IP address than before, the wireguard session becomes a "zombie" -- the session stays up as far as both ends are concerned but no traffic passes. Presumably this is because router b tries to send any wireguard packets to router a's old IP address and so they never arrive. In this state I've found that if I manually terminate the wireguard session then re-start it, everything works as expected. My question is: is there a way that I can have router a re-start the wireguard session it has with router b in the event that its routing topology changes? The routers are running RouterOS by the way.</div></div></div></div></div></div></div></article><article class="text-token-text-primary w-full focus:outline-none [--shadow-height:45px] has-data-writing-block:pointer-events-none has-data-writing-block:-mt-(--shadow-height) has-data-writing-block:pt-(--shadow-height) [&amp;:has([data-writing-block])&gt;*]:pointer-events-auto [content-visibility:auto] supports-[content-visibility:auto]:[contain-intrinsic-size:auto_100lvh] scroll-mt-[calc(var(--header-height)+min(200px,max(70px,20svh)))]" tabindex="-1" dir="auto" data-turn-id="ec298971-61ec-4cab-a9e8-a0590eef8822" data-testid="conversation-turn-2" data-scroll-anchor="false" data-turn="assistant"><div class="text-base my-auto mx-auto [--thread-content-margin:--spacing(4)] @w-sm/main:[--thread-content-margin:--spacing(6)] @w-lg/main:[--thread-content-margin:--spacing(16)] px-(--thread-content-margin)"><div class="[--thread-content-max-width:40rem] @w-lg/main:[--thread-content-max-width:48rem] mx-auto max-w-(--thread-content-max-width) flex-1 group/turn-messages focus-visible:outline-hidden relative flex w-full min-w-0 flex-col agent-turn" tabindex="-1"><div class="flex max-w-full flex-col grow"><div data-message-author-role="assistant" data-message-id="93da3d84-71ad-4117-997b-00d26153bbc4" dir="auto" class="min-h-8 text-message relative flex w-full flex-col items-end gap-2 text-start break-words whitespace-normal [.text-message+&amp;]:mt-1" data-message-model-slug="gpt-5-2"><div class="flex w-full flex-col gap-1 empty:hidden first:pt-[1px]"><div class="markdown prose dark:prose-invert w-full break-words light markdown-new-styling"><p data-start="0" data-end="338">This is a <strong data-start="10" data-end="48">very well-known WireGuard behavior</strong>, and what youâ€™re seeing is not a bug so much as a consequence of how WireGuard is deliberately designed. Let me first ground the behavior, then get specific about <strong data-start="212" data-end="264">what <em data-start="219" data-end="224">can</em> and <em data-start="229" data-end="237">cannot</em> be automated on RouterOS</strong>, and finally give you <strong data-start="287" data-end="337">practical RouterOS patterns that actually work</strong>.</p>
<hr data-start="340" data-end="343">
<h2 data-start="345" data-end="415">Why this happens (and why WireGuard calls it â€œworking as designedâ€)</h2>
<p data-start="417" data-end="494">WireGuard is <strong data-start="430" data-end="472">stateless with respect to connectivity</strong>, not to cryptography.</p>
<p data-start="496" data-end="507">Key points:</p>
<ol data-start="509" data-end="791">
<li data-start="509" data-end="560">
<p data-start="512" data-end="560"><strong data-start="512" data-end="560">Peers are identified by public keys, not IPs</strong></p>
</li>
<li data-start="561" data-end="661">
<p data-start="564" data-end="661"><strong data-start="564" data-end="615">The â€œendpointâ€ (IP:port) is learned dynamically</strong> from the <em data-start="625" data-end="661">last authenticated packet received</em></p>
</li>
<li data-start="662" data-end="715">
<p data-start="665" data-end="715"><strong data-start="665" data-end="715">WireGuard does not actively probe reachability</strong></p>
</li>
<li data-start="716" data-end="791">
<p data-start="719" data-end="791"><strong data-start="719" data-end="791">WireGuard does not reset a session just because packets stop flowing</strong></p>
</li>
</ol>
<p data-start="793" data-end="813">So in your scenario:</p>
<ul data-start="815" data-end="1211">
<li data-start="815" data-end="863">
<p data-start="817" data-end="863">Router Aâ€™s routing changes â†’ source IP changes</p>
</li>
<li data-start="864" data-end="949">
<p data-start="866" data-end="949">Router A continues to <em data-start="888" data-end="902">send nothing</em> (or only sends data packets that never arrive)</p>
</li>
<li data-start="950" data-end="1009">
<p data-start="952" data-end="1009">Router B keeps the <strong data-start="971" data-end="994">last-known endpoint</strong> for A (old IP)</p>
</li>
<li data-start="1010" data-end="1060">
<p data-start="1012" data-end="1060">Router Bâ€™s replies go to the old IP â†’ black hole</p>
</li>
<li data-start="1061" data-end="1135">
<p data-start="1063" data-end="1135">Handshake timers never trigger because <strong data-start="1102" data-end="1135">no new handshake is initiated</strong></p>
</li>
<li data-start="1136" data-end="1211">
<p data-start="1138" data-end="1211">Result: <strong data-start="1146" data-end="1211">cryptographically valid, operationally dead (â€œzombieâ€) tunnel</strong></p>
</li>
</ul>
<p data-start="1213" data-end="1251">This is exactly what youâ€™re observing.</p>
<hr data-start="1253" data-end="1256">
<h2 data-start="1258" data-end="1302">Important RouterOS-specific clarification</h2>
<p data-start="1304" data-end="1316">On RouterOS:</p>
<ul data-start="1318" data-end="1535">
<li data-start="1318" data-end="1415">
<p data-start="1320" data-end="1415">WireGuard <strong data-start="1330" data-end="1369">will not automatically re-handshake</strong> just because the local source address changes</p>
</li>
<li data-start="1416" data-end="1480">
<p data-start="1418" data-end="1480">There is <strong data-start="1427" data-end="1463">no native â€œon route changeâ€ hook</strong> that restarts WG</p>
</li>
<li data-start="1481" data-end="1535">
<p data-start="1483" data-end="1535">There is <strong data-start="1492" data-end="1535">no built-in keepalive failure detection</strong></p>
</li>
</ul>
<p data-start="1537" data-end="1575">So you must <strong data-start="1549" data-end="1574">force a new handshake</strong>.</p>
<hr data-start="1577" data-end="1580">
<h2 data-start="1582" data-end="1626">What actually forces WireGuard to recover</h2>
<p data-start="1628" data-end="1693">There are only <strong data-start="1643" data-end="1659">three things</strong> that reliably fix this situation:</p>
<h3 data-start="1695" data-end="1741">1. A new handshake initiated from Router A</h3>
<h3 data-start="1742" data-end="1808">2. Router B receiving <em data-start="1768" data-end="1773">any</em> authenticated packet from Router A</h3>
<h3 data-start="1809" data-end="1870">3. Restarting or disabling/enabling the peer or interface</h3>
<p data-start="1872" data-end="1942">The good news: <strong data-start="1887" data-end="1942">you can trigger #1 and #3 automatically on RouterOS</strong></p>
<hr data-start="1944" data-end="1947">
<h2 data-start="1949" data-end="2002">The single most important fix: PersistentKeepalive</h2>
<p data-start="2004" data-end="2054">If you are <strong data-start="2015" data-end="2022">not</strong> using this already, start here:</p>
<pre class="overflow-visible! px-0!" data-start="2056" data-end="2161"><div class="contain-inline-size rounded-2xl corner-superellipse/1.1 relative bg-token-sidebar-surface-primary"><div class="sticky top-[calc(--spacing(9)+var(--header-height))] @w-xl/main:top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-routeros"><span>/interface wireguard peers
set [find where comment="to-router-b"] persistent-keepalive=25
</span></code></div></div></pre>
<h3 data-start="2163" data-end="2181">Why this helps</h3>
<ul data-start="2182" data-end="2372">
<li data-start="2182" data-end="2239">
<p data-start="2184" data-end="2239">Forces Router A to send authenticated packets every 25s</p>
</li>
<li data-start="2240" data-end="2308">
<p data-start="2242" data-end="2308">When routing changes, those packets go out via the <em data-start="2293" data-end="2298">new</em> source IP</p>
</li>
<li data-start="2309" data-end="2354">
<p data-start="2311" data-end="2354">Router B updates the endpoint automatically</p>
</li>
<li data-start="2355" data-end="2372">
<p data-start="2357" data-end="2372">No zombie state</p>
</li>
</ul>
<h3 data-start="2374" data-end="2401">When this is sufficient</h3>
<p data-start="2402" data-end="2479">âœ” NAT<br data-start="2407" data-end="2410">
âœ” Multiple uplinks<br data-start="2428" data-end="2431">
âœ” Route failover<br data-start="2447" data-end="2450">
âœ” Dynamic source IP changes</p>
<p data-start="2481" data-end="2537">In <strong data-start="2484" data-end="2504">most deployments</strong>, this alone solves your problem.</p>
<blockquote data-start="2539" data-end="2621">
<p data-start="2541" data-end="2621">If youâ€™re already using PersistentKeepalive and still seeing zombies â†’ continue.</p>
</blockquote>
<hr data-start="2623" data-end="2626">
<h2 data-start="2628" data-end="2690">Forcing a re-handshake on route changes (RouterOS patterns)</h2>
<p data-start="2692" data-end="2777">RouterOS doesnâ€™t expose routing events directly, but you can <strong data-start="2753" data-end="2776">infer route changes</strong>.</p>
<h3 data-start="2779" data-end="2832">Option 1: Script-based peer reset (most reliable)</h3>
<p data-start="2834" data-end="2855">Create a script that:</p>
<ol data-start="2856" data-end="2984">
<li data-start="2856" data-end="2910">
<p data-start="2859" data-end="2910">Checks the current source IP used to reach router B</p>
</li>
<li data-start="2911" data-end="2953">
<p data-start="2914" data-end="2953">Compares it to the last known source IP</p>
</li>
<li data-start="2954" data-end="2984">
<p data-start="2957" data-end="2984">If changed â†’ reset the peer</p>
</li>
</ol>
<h4 data-start="2986" data-end="3017">Example logic (simplified)</h4>
<pre class="overflow-visible! px-0!" data-start="3019" data-end="3448"><div class="contain-inline-size rounded-2xl corner-superellipse/1.1 relative bg-token-sidebar-surface-primary"><div class="sticky top-[calc(--spacing(9)+var(--header-height))] @w-xl/main:top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-routeros"><span>:local peerName "to-router-b"
:local dstIP "B.PUBLIC.IP"

:local currentSrc [/ip route get [find dst-address=$dstIP/32 active=yes] pref-src]

:if ($currentSrc != [/system script environment get wg_last_src]) do={
    /interface wireguard peers disable [find comment=$peerName]
    :delay 2
    /interface wireguard peers enable [find comment=$peerName]
    /system script environment set wg_last_src $currentSrc
}
</span></code></div></div></pre>
<p data-start="3450" data-end="3493">Run this every 10â€“30 seconds via scheduler.</p>
<p data-start="3495" data-end="3573">âœ” Brutally effective<br data-start="3515" data-end="3518">
âœ” RouterOS-friendly<br data-start="3537" data-end="3540">
âœ” No WireGuard internals needed</p>
<hr data-start="3575" data-end="3578">
<h3 data-start="3580" data-end="3620">Option 2: Netwatch-triggered restart</h3>
<p data-start="3622" data-end="3655">If Router B has a stable address:</p>
<pre class="overflow-visible! px-0!" data-start="3657" data-end="3875"><div class="contain-inline-size rounded-2xl corner-superellipse/1.1 relative bg-token-sidebar-surface-primary"><div class="sticky top-[calc(--spacing(9)+var(--header-height))] @w-xl/main:top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-routeros"><span>/tool netwatch
add host=B.PUBLIC.IP interval=10s down-script="\
/interface wireguard peers disable [find comment=to-router-b]; \
:delay 2; \
/interface wireguard peers enable [find comment=to-router-b]"
</span></code></div></div></pre>
<p data-start="3877" data-end="3964">This works because <strong data-start="3896" data-end="3938">failed routing causes netwatch to flap</strong>, which resets the tunnel.</p>
<hr data-start="3966" data-end="3969">
<h3 data-start="3971" data-end="4026">Option 3: Periodic handshake reset (crude but safe)</h3>
<p data-start="4028" data-end="4065">If you want <strong data-start="4040" data-end="4064">absolute reliability</strong>:</p>
<pre class="overflow-visible! px-0!" data-start="4067" data-end="4267"><div class="contain-inline-size rounded-2xl corner-superellipse/1.1 relative bg-token-sidebar-surface-primary"><div class="sticky top-[calc(--spacing(9)+var(--header-height))] @w-xl/main:top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre! language-routeros"><span>/system scheduler
add interval=5m on-event="\
/interface wireguard peers disable [find comment=to-router-b]; \
:delay 2; \
/interface wireguard peers enable [find comment=to-router-b]"
</span></code></div></div></pre>
<p data-start="4269" data-end="4309">WireGuard tolerates this extremely well.</p>
<hr data-start="4311" data-end="4314">
<h2 data-start="4316" data-end="4351">What you <em data-start="4328" data-end="4336">cannot</em> do (important)</h2>
<p data-start="4353" data-end="4520">âŒ Force WireGuard to â€œnoticeâ€ routing changes automatically<br data-start="4412" data-end="4415">
âŒ Hook directly into routing table changes<br data-start="4457" data-end="4460">
âŒ Make WireGuard re-resolve endpoints unless traffic flows</p>
<p data-start="4522" data-end="4581">This is by design and applies to Linux, BSD, RouterOS, etc.</p>
<hr data-start="4583" data-end="4586">
<h2 data-start="4588" data-end="4631">Best-practice summary (what I recommend)</h2>
<p data-start="4633" data-end="4678">For RouterOS in complex routing environments:</p>
<ol data-start="4680" data-end="4903">
<li data-start="4680" data-end="4720">
<p data-start="4683" data-end="4720"><strong data-start="4683" data-end="4720">Always set <code data-start="4696" data-end="4718">persistent-keepalive</code></strong></p>
</li>
<li data-start="4721" data-end="4776">
<p data-start="4724" data-end="4776"><strong data-start="4724" data-end="4776">Add a scripted peer reset tied to routing health</strong></p>
</li>
<li data-start="4777" data-end="4849">
<p data-start="4780" data-end="4849"><strong data-start="4780" data-end="4849">Treat WireGuard as cryptographic plumbing, not a routing protocol</strong></p>
</li>
<li data-start="4850" data-end="4903">
<p data-start="4853" data-end="4903"><strong data-start="4853" data-end="4903">Let RouterOS scripts handle topology awareness</strong></p>
</li>
</ol>
<p data-start="4905" data-end="4971">This combination gives you <strong data-start="4932" data-end="4959">carrier-grade stability</strong>, even with:</p>
<ul data-start="4972" data-end="5035">
<li data-start="4972" data-end="4978">
<p data-start="4974" data-end="4978">ECMP</p>
</li>
<li data-start="4979" data-end="4985">
<p data-start="4981" data-end="4985">VRFs</p>
</li>
<li data-start="4986" data-end="5004">
<p data-start="4988" data-end="5004">Multiple uplinks</p>
</li>
<li data-start="5005" data-end="5021">
<p data-start="5007" data-end="5021">Policy routing</p>
</li>
<li data-start="5022" data-end="5035">
<p data-start="5024" data-end="5035">Dynamic IPs</p>
</li>
</ul>
<hr data-start="5037" data-end="5040">
<p data-start="5042" data-end="5072">If you want, you can describe:</p>
<ul data-start="5073" data-end="5176">
<li data-start="5073" data-end="5091">
<p data-start="5075" data-end="5091">How many uplinks</p>
</li>
<li data-start="5092" data-end="5117">
<p data-start="5094" data-end="5117">Whether NAT is involved</p>
</li>
<li data-start="5118" data-end="5157">
<p data-start="5120" data-end="5157">Whether Router B is static or dynamic</p>
</li>
<li data-start="5158" data-end="5176">
<p data-start="5160" data-end="5176">RouterOS version</p>
</li>
</ul>
<p data-start="5178" data-end="5262" data-is-last-node="" data-is-only-node="">â€¦and I can give you a <strong data-start="5200" data-end="5227">drop-in RouterOS script</strong> tailored exactly to your topology.</p></div></div></div></div></div></div></article><article class="text-token-text-primary w-full focus:outline-none [--shadow-height:45px] has-data-writing-block:pointer-events-none has-data-writing-block:-mt-(--shadow-height) has-data-writing-block:pt-(--shadow-height) [&amp;:has([data-writing-block])&gt;*]:pointer-events-auto scroll-mt-(--header-height)" tabindex="-1" dir="auto" data-turn-id="483cad4d-ed83-47f5-b9a0-c39eef99547d" data-testid="conversation-turn-3" data-scroll-anchor="false" data-turn="user"><div class="text-base my-auto mx-auto pt-12 [--thread-content-margin:--spacing(4)] @w-sm/main:[--thread-content-margin:--spacing(6)] @w-lg/main:[--thread-content-margin:--spacing(16)] px-(--thread-content-margin)"><div class="[--thread-content-max-width:40rem] @w-lg/main:[--thread-content-max-width:48rem] mx-auto max-w-(--thread-content-max-width) flex-1 group/turn-messages focus-visible:outline-hidden mb-10 relative flex w-full min-w-0 flex-col" tabindex="-1"><div class="flex max-w-full flex-col grow"><div data-message-author-role="user" data-message-id="483cad4d-ed83-47f5-b9a0-c39eef99547d" dir="auto" class="min-h-8 text-message relative flex w-full flex-col items-end gap-2 text-start break-words whitespace-normal [.text-message+&amp;]:mt-1"><div class="flex w-full flex-col gap-1 empty:hidden items-end rtl:items-start"><div class="user-message-bubble-color corner-superellipse/1.1 relative rounded-[18px] px-4 py-1.5 data-[multiline]:py-3 max-w-[var(--user-chat-width,70%)]" data-multiline=""><div class="whitespace-pre-wrap">Thank you. I am a bit confused by your answer. On the one hand you said that RouterOS has no automatic keepalive failure detection, but then you say to enable persistent keepalives. For your information I do have persistent keepalive enabled with a 25 second interval. That doesn't seem to help with the problem.</div></div></div></div></div></div></div></article><article class="text-token-text-primary w-full focus:outline-none [--shadow-height:45px] has-data-writing-block:pointer-events-none has-data-writing-block:-mt-(--shadow-height) has-data-writing-block:pt-(--shadow-height) [&amp;:has([data-writing-block])&gt;*]:pointer-events-auto [content-visibility:auto] supports-[content-visibility:auto]:[contain-intrinsic-size:auto_100lvh] scroll-mt-[calc(var(--header-height)+min(200px,max(70px,20svh)))]" tabindex="-1" dir="auto" data-turn-id="1ae1774a-7b47-4c7a-a0c5-c144ba47cc8d" data-testid="conversation-turn-4" data-scroll-anchor="false" data-turn="assistant"><div class="text-base my-auto mx-auto [--thread-content-margin:--spacing(4)] @w-sm/main:[--thread-content-margin:--spacing(6)] @w-lg/main:[--thread-content-margin:--spacing(16)] px-(--thread-content-margin)"><div class="[--thread-content-max-width:40rem] @w-lg/main:[--thread-content-max-width:48rem] mx-auto max-w-(--thread-content-max-width) flex-1 group/turn-messages focus-visible:outline-hidden relative flex w-full min-w-0 flex-col agent-turn" tabindex="-1"><div class="flex max-w-full flex-col grow"><div class="absolute flex h-8 w-3 origin-center items-center justify-center"><div class="bg-token-text-primary h-3 w-3 rounded-full"></div></div><div class="relative my-1 min-h-6"><div class="relative flex origin-top-left flex-col gap-2 overflow-x-clip rtl:origin-top-right"><div class="relative w-full text-start"><div class="flex w-full flex-row items-start justify-between gap-4 text-start"><button class="flex min-w-0 shrink-1 items-center gap-0.5"><span class="font-medium w-full"><span class="flex items-center gap-1 truncate text-start align-middle text-token-text-secondary hover:text-token-text-primary dark:hover:text-token-text-primary dark:text-[var(--interactive-label-tertiary-default)]"><span class="flex min-w-0 items-center gap-1"><span class="min-w-0 truncate">Thought for 21s</span></span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" aria-hidden="true" data-rtl-flip="" class="icon-xs"><use href="/cdn/assets/sprites-core-jtokmzgv.svg#b140e7" fill="currentColor"></use></svg></span></span></button></div></div><div class="max-w-[calc(0.8*var(--thread-content-max-width,40rem))]"></div></div></div><div data-message-author-role="assistant" data-message-id="d71151a1-fc51-4ae0-beab-9371d0fecf37" dir="auto" class="min-h-8 text-message relative flex w-full flex-col items-end gap-2 text-start break-words whitespace-normal [.text-message+&amp;]:mt-1" data-message-model-slug="gpt-5-2-thinking"><div class="flex w-full flex-col gap-1 empty:hidden first:pt-[1px]"><div class="markdown prose dark:prose-invert w-full break-words light markdown-new-styling"><p data-start="0" data-end="83">Youâ€™re totally right to call that out â€” I used â€œkeepaliveâ€ in two different senses.</p>
<h3 data-start="85" data-end="123">Two different â€œkeepaliveâ€ concepts</h3>
<p data-start="125" data-end="322"><strong data-start="125" data-end="161">1) WireGuard PersistentKeepalive</strong><br data-start="161" data-end="164">
This is <em data-start="172" data-end="177">not</em> a health check. It does <strong data-start="202" data-end="209">not</strong> detect failure and it does <strong data-start="237" data-end="244">not</strong> restart anything. It only sends an authenticated packet periodically so that:</p>
<ul data-start="324" data-end="433">
<li data-start="324" data-end="348">
<p data-start="326" data-end="348">NAT mappings stay open</p>
</li>
<li data-start="349" data-end="433">
<p data-start="351" data-end="433">the <em data-start="355" data-end="367">other side</em> can learn a new â€œcurrent endpointâ€ if it <strong data-start="409" data-end="421">receives</strong> that packet</p>
</li>
</ul>
<p data-start="435" data-end="575">WireGuard itself still happily considers the peer â€œconfiguredâ€ even if nothing is getting through. (Thatâ€™s the â€œno failure detectionâ€ part.)</p>
<p data-start="577" data-end="732">WireGuardâ€™s own docs describe PersistentKeepalive as simply making WireGuard â€œmore chatty,â€ mainly for NAT traversal. <span class="" data-state="closed"></span></p>
<p data-start="734" data-end="901"><strong data-start="734" data-end="786">2) A â€œtunnel is deadâ€ detector + recovery action</strong><br data-start="786" data-end="789">
Thatâ€™s what RouterOS does <em data-start="815" data-end="820">not</em> have built-in for WireGuard. You have to add it (script/netwatch/routing rules).</p>
<hr data-start="903" data-end="906">
<h2 data-start="908" data-end="964">Why PersistentKeepalive might <em data-start="941" data-end="946">not</em> help in your case</h2>
<p data-start="966" data-end="1176">PersistentKeepalive only fixes the zombie state <strong data-start="1014" data-end="1075">if Router B actually receives those packets from Router A</strong>. If B never receives them, B canâ€™t update its â€œcurrent endpoint,â€ so it keeps sending to the old IP.</p>
<p data-start="1178" data-end="1248">Common reasons B might not be receiving them when Aâ€™s routing changes:</p>
<ol data-start="1250" data-end="2078">
<li data-start="1250" data-end="1651">
<p data-start="1253" data-end="1651"><strong data-start="1253" data-end="1340">Your policy routing / marks arenâ€™t applied to WireGuard handshake/keepalive traffic</strong>, so RouterOS may emit the handshake out the â€œwrongâ€ WAN/interface after a topology change. MikroTik explicitly warns about this class of issue and mentions using the peer â€œresponderâ€ option and correct routing-mark handling so handshakes donâ€™t leave via the wrong route. <span class="" data-state="closed"></span></p>
</li>
<li data-start="1652" data-end="1816">
<p data-start="1655" data-end="1816"><strong data-start="1655" data-end="1699">The new path changes source NAT behavior</strong> (different public IP/CGNAT mapping/firewall), and inbound UDP from B to Aâ€™s new source IP/port doesnâ€™t make it back.</p>
</li>
<li data-start="1817" data-end="2078">
<p data-start="1820" data-end="2078"><strong data-start="1820" data-end="1858">B has an <code data-start="1831" data-end="1849">endpoint-address</code> pinned</strong> and Aâ€™s packets arenâ€™t arriving to override it (same root cause: B isnâ€™t seeing A). RouterOS shows both â€œendpointâ€ and â€œcurrent endpointâ€ for exactly this reason â€” they can diverge. <span class="" data-state="closed"></span></p>
</li>
</ol>
<hr data-start="2080" data-end="2083">
<h2 data-start="2085" data-end="2148">What to do on RouterOS when PersistentKeepalive isnâ€™t enough</h2>
<p data-start="2150" data-end="2248">At that point, you need <strong data-start="2174" data-end="2247">a RouterOS-side â€œdead tunnel detectorâ€ + â€œforce new handshakeâ€ action</strong>.</p>
<p data-start="2250" data-end="2287">The most RouterOS-native approach is:</p>
<h3 data-start="2289" data-end="2332">A) Detect: â€œtunnel canâ€™t carry trafficâ€</h3>
<p data-start="2333" data-end="2427">Ping something across the tunnel (the peerâ€™s WG IP is ideal), or check handshake age + a ping.</p>
<h3 data-start="2429" data-end="2475">B) Recover: bounce the peer (or interface)</h3>
<p data-start="2476" data-end="2549">Disable/enable the peer (or the WG interface) to force a fresh handshake.</p>
<p data-start="2551" data-end="2761">This is a common operational workaround on MikroTik and there are multiple community scripts built around â€œif last-handshake is too old / ping fails â†’ disable+enable peer.â€ <span class="" data-state="closed"></span></p>
<blockquote data-start="2763" data-end="3030">
<p data-start="2765" data-end="3030">Note: there are also reports that â€œdisable/enable peer from scriptâ€ can behave differently than clicking in WinBox in some RouterOS versions. If you hit that, bouncing the <em data-start="2937" data-end="2948">interface</em> instead of the peer is often more reliable. <span class="" data-state="closed"></span></p>
</blockquote>
<hr data-start="3032" data-end="3035">
<h2 data-start="3037" data-end="3087">Practical recovery pattern (what Iâ€™d implement)</h2>
<h3 data-start="3089" data-end="3145">1) Add a watchdog that pings Router Bâ€™s WireGuard IP</h3>
<ul data-start="3146" data-end="3217">
<li data-start="3146" data-end="3217">
<p data-start="3148" data-end="3217">If ping fails for (say) 3 intervals â†’ bounce WG peer or WG interface.</p>
</li>
</ul>
<h3 data-start="3219" data-end="3306">2) (If you use multiple WANs / PBR) ensure WireGuard traffic is routed consistently</h3>
<p data-start="3307" data-end="3427">This is the â€œhandshake left via wrong uplinkâ€ class of issue MikroTik warns about. <span class="" data-state="closed"></span></p>
<hr data-start="3429" data-end="3432">
<h2 data-start="3434" data-end="3487">The key troubleshooting check (quick, high-signal)</h2>
<p data-start="3489" data-end="3526">When itâ€™s â€œzombie,â€ look at Router B:</p>
<ul data-start="3528" data-end="3664">
<li data-start="3528" data-end="3605">
<p data-start="3530" data-end="3605"><strong data-start="3530" data-end="3550">Current Endpoint</strong> for Router Aâ€™s peer â€” does it still show the <em data-start="3596" data-end="3601">old</em> IP?</p>
</li>
<li data-start="3606" data-end="3664">
<p data-start="3608" data-end="3664"><strong data-start="3608" data-end="3628">Latest handshake</strong> â€” is it updating every ~25s or not?</p>
</li>
</ul>
<p data-start="3666" data-end="3899">If <strong data-start="3669" data-end="3697">handshake isnâ€™t updating</strong>, PersistentKeepalive packets from A are <strong data-start="3738" data-end="3756">not reaching B</strong> (routing/NAT/PBR issue).<br data-start="3781" data-end="3784">
If handshake <em data-start="3797" data-end="3801">is</em> updating but data doesnâ€™t pass, thatâ€™s a different problem (routes/allowed-address/firewall/NAT).</p>
<hr data-start="3901" data-end="3904">
<p data-start="3906" data-end="3951">If you paste (redact public IPs if you want):</p>
<ul data-start="3953" data-end="4116">
<li data-start="3953" data-end="4037">
<p data-start="3955" data-end="4037"><code data-start="3955" data-end="3996">/interface wireguard peers print detail</code> from both routers (the peer in question)</p>
</li>
<li data-start="4038" data-end="4116">
<p data-start="4040" data-end="4116">how you do multi-WAN / PBR (routing marks? check-gateway? recursive routes?)</p>
</li>
</ul>
<p data-start="4118" data-end="4252">â€¦I can tell you which of the two failure modes youâ€™re in and give you the exact RouterOS script + rule placement to make it self-heal.</p>
</div></div></div></div><button class="group/footnote bg-token-bg-primary flex w-fit items-center gap-1.5 px-3 py-1.5 hover:bg-token-bg-tertiary rounded-3xl" aria-label="Sources"><div class="flex flex-row-reverse"><div class="border-token-bg-primary bg-token-bg-primary flex items-center overflow-clip rounded-full -ms-1.5 first:me-0 border-2 group-hover/footnote:border-token-bg-tertiary relative"><div class="relative inline-block shrink-0"><img alt="" width="32" height="32" class="icon-sm rounded-full border border-token-border-light border-[0.5px] duration-200 motion-safe:transition-opacity opacity-100" src="https://www.google.com/s2/favicons?domain=https://forum.mikrotik.com&amp;sz=32"></div></div><div class="border-token-bg-primary bg-token-bg-primary flex items-center overflow-clip rounded-full -ms-1.5 first:me-0 border-2 group-hover/footnote:border-token-bg-tertiary relative"><div class="relative inline-block shrink-0"><img alt="" width="32" height="32" class="icon-sm rounded-full border border-token-border-light border-[0.5px] duration-200 motion-safe:transition-opacity opacity-100" src="https://www.google.com/s2/favicons?domain=https://help.mikrotik.com&amp;sz=32"></div></div><div class="border-token-bg-primary bg-token-bg-primary flex items-center overflow-clip rounded-full -ms-1.5 first:me-0 border-2 group-hover/footnote:border-token-bg-tertiary relative"><div class="relative inline-block shrink-0"><img alt="" width="32" height="32" class="icon-sm rounded-full border border-token-border-light border-[0.5px] duration-200 motion-safe:transition-opacity opacity-100" src="https://www.google.com/s2/favicons?domain=https://www.wireguard.com&amp;sz=32"></div></div></div><div class="text-token-text-secondary mt-[-1px] text-[13px] font-medium">Sources</div></button></div></div></article><article class="text-token-text-primary w-full focus:outline-none [--shadow-height:45px] has-data-writing-block:pointer-events-none has-data-writing-block:-mt-(--shadow-height) has-data-writing-block:pt-(--shadow-height) [&amp;:has([data-writing-block])&gt;*]:pointer-events-auto scroll-mt-(--header-height)" tabindex="-1" dir="auto" data-turn-id="55a0897c-2383-4ccc-b7fb-7580c8331da2" data-testid="conversation-turn-5" data-scroll-anchor="false" data-turn="user"><div class="text-base my-auto mx-auto pt-12 [--thread-content-margin:--spacing(4)] @w-sm/main:[--thread-content-margin:--spacing(6)] @w-lg/main:[--thread-content-margin:--spacing(16)] px-(--thread-content-margin)"><div class="[--thread-content-max-width:40rem] @w-lg/main:[--thread-content-max-width:48rem] mx-auto max-w-(--thread-content-max-width) flex-1 group/turn-messages focus-visible:outline-hidden mb-10 relative flex w-full min-w-0 flex-col" tabindex="-1"><div class="flex max-w-full flex-col grow"><div data-message-author-role="user" data-message-id="55a0897c-2383-4ccc-b7fb-7580c8331da2" dir="auto" class="min-h-8 text-message relative flex w-full flex-col items-end gap-2 text-start break-words whitespace-normal [.text-message+&amp;]:mt-1"><div class="flex w-full flex-col gap-1 empty:hidden items-end rtl:items-start"><div class="user-message-bubble-color corner-superellipse/1.1 relative rounded-[18px] px-4 py-1.5 data-[multiline]:py-3 max-w-[var(--user-chat-width,70%)]" data-multiline=""><div class="whitespace-pre-wrap">Ok thanks. I understand the concept that the keepalive packets may be black-holed but I don't see how that can happen but packets from a newly initiated wireguard session do get through. I'd expect both kinds of packet to be subject to the same routing regime. But you have given me some ideas for further diagnosis. The next time I see this failure condition I will take some packet traces to attempt to diagnose further.</div></div></div></div></div></div></div></article><article class="text-token-text-primary w-full focus:outline-none [--shadow-height:45px] has-data-writing-block:pointer-events-none has-data-writing-block:-mt-(--shadow-height) has-data-writing-block:pt-(--shadow-height) [&amp;:has([data-writing-block])&gt;*]:pointer-events-auto [content-visibility:auto] supports-[content-visibility:auto]:[contain-intrinsic-size:auto_100lvh] scroll-mt-[calc(var(--header-height)+min(200px,max(70px,20svh)))]" tabindex="-1" dir="auto" data-turn-id="0d329669-040b-492e-9707-1255310257ce" data-testid="conversation-turn-6" data-scroll-anchor="true" data-turn="assistant"><div class="text-base my-auto mx-auto pb-10 [--thread-content-margin:--spacing(4)] @w-sm/main:[--thread-content-margin:--spacing(6)] @w-lg/main:[--thread-content-margin:--spacing(16)] px-(--thread-content-margin)"><div class="[--thread-content-max-width:40rem] @w-lg/main:[--thread-content-max-width:48rem] mx-auto max-w-(--thread-content-max-width) flex-1 group/turn-messages focus-visible:outline-hidden relative flex w-full min-w-0 flex-col agent-turn" tabindex="-1"><div class="flex max-w-full flex-col grow"><div data-message-author-role="assistant" data-message-id="06743b67-e549-49d8-9593-8e0acfcd6631" dir="auto" class="min-h-8 text-message relative flex w-full flex-col items-end gap-2 text-start break-words whitespace-normal [.text-message+&amp;]:mt-1" data-message-model-slug="gpt-5-2"><div class="flex w-full flex-col gap-1 empty:hidden first:pt-[1px]"><div class="markdown prose dark:prose-invert w-full break-words light markdown-new-styling"><p data-start="0" data-end="313">Thatâ€™s a very reasonable expectation â€” and your intuition is basically <em data-start="71" data-end="78">right</em>. If <strong data-start="83" data-end="146">keepalive packets are black-holed but a fresh session works</strong>, something subtle and RouterOS-specific is going on. Let me try to reconcile that apparent contradiction and give you some concrete things to look for in your traces.</p>
<hr data-start="315" data-end="318">
<h2 data-start="320" data-end="371">Why this <em data-start="332" data-end="337">can</em> happen even though it â€œshouldnâ€™tâ€</h2>
<p data-start="373" data-end="423">From a pure IP routing perspective youâ€™re correct:</p>
<blockquote data-start="424" data-end="550">
<p data-start="426" data-end="550"><em data-start="426" data-end="550">A WireGuard keepalive and a WireGuard handshake packet are both just UDP packets and should follow the same routing logic.</em></p>
</blockquote>
<p data-start="552" data-end="633">However, in practice on RouterOS there are <strong data-start="595" data-end="632">three differences that can matter</strong>.</p>
<hr data-start="635" data-end="638">
<h2 data-start="640" data-end="696">1. â€œCurrent endpointâ€ vs â€œendpoint-addressâ€ asymmetry</h2>
<p data-start="698" data-end="742">When a peer is established, RouterOS stores:</p>
<ul data-start="744" data-end="831">
<li data-start="744" data-end="777">
<p data-start="746" data-end="777"><code data-start="746" data-end="764">endpoint-address</code> (configured)</p>
</li>
<li data-start="778" data-end="831">
<p data-start="780" data-end="831"><code data-start="780" data-end="798">current-endpoint</code> (learned from last valid packet)</p>
</li>
</ul>
<p data-start="833" data-end="878">If the tunnel is already â€œupâ€ (zombie state):</p>
<ul data-start="880" data-end="1021">
<li data-start="880" data-end="950">
<p data-start="882" data-end="950">RouterOS continues to <strong data-start="904" data-end="950">send data/keepalives to <code data-start="930" data-end="948">current-endpoint</code></strong></p>
</li>
<li data-start="951" data-end="1021">
<p data-start="953" data-end="1021">It does <strong data-start="961" data-end="1021">not re-evaluate the endpoint until a handshake is forced</strong></p>
</li>
</ul>
<p data-start="1023" data-end="1065">When you manually disable/enable the peer:</p>
<ul data-start="1066" data-end="1204">
<li data-start="1066" data-end="1104">
<p data-start="1068" data-end="1104">RouterOS discards <code data-start="1086" data-end="1104">current-endpoint</code></p>
</li>
<li data-start="1105" data-end="1169">
<p data-start="1107" data-end="1169">It re-resolves and re-evaluates routing for <code data-start="1151" data-end="1169">endpoint-address</code></p>
</li>
<li data-start="1170" data-end="1204">
<p data-start="1172" data-end="1204">A <em data-start="1174" data-end="1181">fresh</em> handshake is generated</p>
</li>
</ul>
<p data-start="1206" data-end="1357">So although both packets are UDP, <strong data-start="1240" data-end="1291">they are addressed to different destination IPs</strong> in the failure case. That alone is enough to make routing differ.</p>
<p data-start="1359" data-end="1513">ğŸ‘‰ <strong data-start="1362" data-end="1375">In traces</strong><br data-start="1375" data-end="1378">
Check whether keepalives are still destined to the <em data-start="1429" data-end="1434">old</em> peer IP, while the new session starts with packets to the configured endpoint.</p>
<hr data-start="1515" data-end="1518">
<h2 data-start="1520" data-end="1562">2. Source-address selection differences</h2>
<p data-start="1564" data-end="1645">RouterOS chooses a source address at <em data-start="1601" data-end="1612">send time</em>, not at peer configuration time.</p>
<p data-start="1647" data-end="1665">In a zombie state:</p>
<ul data-start="1666" data-end="1822">
<li data-start="1666" data-end="1729">
<p data-start="1668" data-end="1729">Keepalives may continue using the <strong data-start="1702" data-end="1729">old preferred source IP</strong></p>
</li>
<li data-start="1730" data-end="1822">
<p data-start="1732" data-end="1822">Especially if <code data-start="1746" data-end="1756">pref-src</code>, routing marks, or VRFs were involved when the peer first came up</p>
</li>
</ul>
<p data-start="1824" data-end="1850">When you restart the peer:</p>
<ul data-start="1851" data-end="1946">
<li data-start="1851" data-end="1897">
<p data-start="1853" data-end="1897">RouterOS recomputes source address selection</p>
</li>
<li data-start="1898" data-end="1946">
<p data-start="1900" data-end="1946">New source IP matches the new routing topology</p>
</li>
</ul>
<p data-start="1948" data-end="2065">This behavior has been observed with policy routing and recursive routes on RouterOS even when the FIB looks correct.</p>
<p data-start="2067" data-end="2094">ğŸ‘‰ <strong data-start="2070" data-end="2083">In traces</strong><br data-start="2083" data-end="2086">
Compare:</p>
<ul data-start="2095" data-end="2181">
<li data-start="2095" data-end="2127">
<p data-start="2097" data-end="2127">Source IP of keepalive packets</p>
</li>
<li data-start="2128" data-end="2181">
<p data-start="2130" data-end="2181">Source IP of packets in the newly initiated session</p>
</li>
</ul>
<p data-start="2183" data-end="2229">If they differ, youâ€™ve found your explanation.</p>
<hr data-start="2231" data-end="2234">
<h2 data-start="2236" data-end="2287">3. Connection tracking &amp; NAT state (very common)</h2>
<p data-start="2289" data-end="2333">If NAT is involved anywhere (even upstream):</p>
<ul data-start="2335" data-end="2456">
<li data-start="2335" data-end="2378">
<p data-start="2337" data-end="2378">Keepalives reuse the <strong data-start="2358" data-end="2378">same UDP 5-tuple</strong></p>
</li>
<li data-start="2379" data-end="2435">
<p data-start="2381" data-end="2435">NAT state may still point to the old path or interface</p>
</li>
<li data-start="2436" data-end="2456">
<p data-start="2438" data-end="2456">Replies go nowhere</p>
</li>
</ul>
<p data-start="2458" data-end="2474">A fresh session:</p>
<ul data-start="2475" data-end="2553">
<li data-start="2475" data-end="2503">
<p data-start="2477" data-end="2503">Uses a <strong data-start="2484" data-end="2503">new source port</strong></p>
</li>
<li data-start="2504" data-end="2533">
<p data-start="2506" data-end="2533">Creates a fresh NAT mapping</p>
</li>
<li data-start="2534" data-end="2553">
<p data-start="2536" data-end="2553">Works immediately</p>
</li>
</ul>
<p data-start="2555" data-end="2586">This is especially common with:</p>
<ul data-start="2587" data-end="2676">
<li data-start="2587" data-end="2602">
<p data-start="2589" data-end="2602">Multiple WANs</p>
</li>
<li data-start="2603" data-end="2610">
<p data-start="2605" data-end="2610">CGNAT</p>
</li>
<li data-start="2611" data-end="2631">
<p data-start="2613" data-end="2631">Asymmetric routing</p>
</li>
<li data-start="2632" data-end="2676">
<p data-start="2634" data-end="2676">FastTrack (worth disabling for WG traffic)</p>
</li>
</ul>
<p data-start="2678" data-end="2706">ğŸ‘‰ <strong data-start="2681" data-end="2694">In traces</strong><br data-start="2694" data-end="2697">
Look for:</p>
<ul data-start="2707" data-end="2790">
<li data-start="2707" data-end="2752">
<p data-start="2709" data-end="2752">Same source port reused during zombie state</p>
</li>
<li data-start="2753" data-end="2790">
<p data-start="2755" data-end="2790">Different source port after restart</p>
</li>
</ul>
<hr data-start="2792" data-end="2795">
<h2 data-start="2797" data-end="2851">What to capture when it happens (high-value traces)</h2>
<p data-start="2853" data-end="2916">When you catch it again, Iâ€™d suggest capturing <strong data-start="2900" data-end="2915">four things</strong>:</p>
<ol data-start="2918" data-end="3345">
<li data-start="2918" data-end="3040">
<p data-start="2921" data-end="2955"><strong data-start="2921" data-end="2955">On Router A (egress interface)</strong></p>
<ul data-start="2959" data-end="3040">
<li data-start="2959" data-end="2988">
<p data-start="2961" data-end="2988">Do keepalive packets leave?</p>
</li>
<li data-start="2992" data-end="3014">
<p data-start="2994" data-end="3014">What source IP/port?</p>
</li>
<li data-start="3018" data-end="3040">
<p data-start="3020" data-end="3040">What destination IP?</p>
</li>
</ul>
</li>
<li data-start="3042" data-end="3143">
<p data-start="3045" data-end="3086"><strong data-start="3045" data-end="3086">On Router A (any other WAN interface)</strong></p>
<ul data-start="3090" data-end="3143">
<li data-start="3090" data-end="3143">
<p data-start="3092" data-end="3143">Make sure theyâ€™re not exiting the â€œwrongâ€ interface</p>
</li>
</ul>
</li>
<li data-start="3145" data-end="3247">
<p data-start="3148" data-end="3163"><strong data-start="3148" data-end="3163">On Router B</strong></p>
<ul data-start="3167" data-end="3247">
<li data-start="3167" data-end="3210">
<p data-start="3169" data-end="3210">Are <em data-start="3173" data-end="3178">any</em> packets from Router A arriving?</p>
</li>
<li data-start="3214" data-end="3247">
<p data-start="3216" data-end="3247">Is <code data-start="3219" data-end="3237">current-endpoint</code> updating?</p>
</li>
</ul>
</li>
<li data-start="3249" data-end="3345">
<p data-start="3252" data-end="3286"><strong data-start="3252" data-end="3286">Immediately after peer restart</strong></p>
<ul data-start="3290" data-end="3345">
<li data-start="3290" data-end="3345">
<p data-start="3292" data-end="3345">Compare handshake packet headers vs keepalive headers</p>
</li>
</ul>
</li>
</ol>
<p data-start="3347" data-end="3403">You donâ€™t need a long capture â€” 10â€“20 seconds is plenty.</p>
<hr data-start="3405" data-end="3408">
<h2 data-start="3410" data-end="3448">A key RouterOS knob to double-check</h2>
<p data-start="3450" data-end="3476">If you use policy routing:</p>
<ul data-start="3478" data-end="3627">
<li data-start="3478" data-end="3627">
<p data-start="3480" data-end="3532">Make sure <strong data-start="3490" data-end="3532">WireGuard traffic is explicitly routed</strong></p>
<ul data-start="3535" data-end="3627">
<li data-start="3535" data-end="3561">
<p data-start="3537" data-end="3561">Either via routing marks</p>
</li>
<li data-start="3564" data-end="3627">
<p data-start="3566" data-end="3627">Or by forcing the peer endpoint into a specific routing table</p>
</li>
</ul>
</li>
</ul>
<p data-start="3629" data-end="3830">Many MikroTik multi-WAN zombie WG issues ultimately come down to handshake packets not matching the intended routing rules. MikroTik themselves call this out in RouterOS WG examples and forum threads.</p>
<hr data-start="3832" data-end="3835">
<h2 data-start="3837" data-end="3851">Bottom line</h2>
<p data-start="3853" data-end="3927">Youâ€™re not missing something obvious â€” this <em data-start="3897" data-end="3901">is</em> one of those cases where:</p>
<ul data-start="3929" data-end="4047">
<li data-start="3929" data-end="3984">
<p data-start="3931" data-end="3984">IP theory says â€œthese packets should behave the sameâ€</p>
</li>
<li data-start="3985" data-end="4047">
<p data-start="3987" data-end="4047">RouterOS implementation details make them behave differently</p>
</li>
</ul>
<p data-start="4049" data-end="4200">Your plan to take packet traces is exactly the right next step. Once you have them, the explanation almost always becomes obvious within a few minutes.</p>
<p data-start="4202" data-end="4256">If you want, feel free to paste a redacted snippet of:</p>
<ul data-start="4257" data-end="4362">
<li data-start="4257" data-end="4291">
<p data-start="4259" data-end="4291">packet headers (src/dst IP+port)</p>
</li>
<li data-start="4292" data-end="4334">
<p data-start="4294" data-end="4334"><code data-start="4294" data-end="4312">current-endpoint</code> vs <code data-start="4316" data-end="4334">endpoint-address</code></p>
</li>
<li data-start="4335" data-end="4362">
<p data-start="4337" data-end="4362">routing table at the time</p>
</li>
</ul>
<p data-start="4364" data-end="4414" data-is-last-node="" data-is-only-node="">â€¦and Iâ€™m happy to help you interpret what you see.</p></div></div></div></div></div></div></article><!--EndFragment-->
</body>
</html>